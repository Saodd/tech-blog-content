```yaml lw-blog-meta
title: Go源码：encoding/json标准库
date: "2020-09-26"
brev: 数据结构的序列化与反序列化，是网络通信中的重要基础功能之一。而Json应该可以说是当前最流行的格式之一。
tags: [Golang, 源码]
```

## 前言

本文阅读的Go版本是 `1.14.2`，系统是 darwin

## 基本使用

```go
func main() {
    j, _ := json.Marshal(&Blog{
        Title:   "First Blog",
        Content: "Hello, world!",
    })
    fmt.Println(string(j))
}
```

其实 json 这个包最主要的函数就是两个： `Marshal` 和 `Unmarshal`，前者负责将结构体转为字符串（字节数组），后者相反。

重点在于，Go是静态类型的语言，那么这个包是如何读取到静态结构体的字段名称等信息呢？

## 序列化： Marshal

这个函数的注释特别的长，我们慢慢地看一下：

```go
func Marshal(v interface{}) ([]byte, error) {
    e := newEncodeState()

    err := e.marshal(v, encOpts{escapeHTML: true})
    if err != nil {
        return nil, err
    }
    buf := append([]byte(nil), e.Bytes()...)

    encodeStatePool.Put(e)

    return buf, nil
}
```

`Marshal` 递归地遍历参数v 。如果遇到一个实现了`Marshaler`接口的值并且它是非nil的，就会调用这个值的`MarshalJSON`方法；没有的话就检查`encoding.TextMarshaler`接口的`MarshalText`方法。

如果上述两个接口都没有，则按照以下规则：
+ Boolean values encode as JSON booleans.
+ Floating point, integer, and Number values encode as JSON numbers.
+ String 则强制使用UTF-8编码。并且默认使用 HTMLEscape （将 `<` `>` `&` `U+2028` `U+2029` 替换为 `\u003c` `\u003e` `\u0026` `\u2028` `\u2029`），这个行为可以通过 `Encoder` 来自定义。
+ Array, slice 相应地转化为 JSON array，但是 `[]byte`会编为 base64字符串。空数组则转换为 JSON null 。
+ Struct 转为为 JSON object 。每个公开成员（大写开头）都会作为object的一个成员，使用字段名作为键，除非：
    * 可以通过 字段tag 来指定名称，作为 object的键；
    * 名称后面，可以用逗号分割来附带一些额外的配置；名称可以留空，以保留默认的键，同时附带配置。
    * 配置`omitempty`时，则当字段为空值（零值）的时候忽略这个字段。
    * 如果名称指定为`-`，则总是忽略这个字段。（注意如果想让键就是`-`，则要写`-,`）