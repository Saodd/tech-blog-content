```yaml lw-blog-meta
title: "记一次破解小程序后端接口的经历"
date: "2021-06-13"
brev: "包吃包住的生活似乎也不错……？"
tags: ["网络","安全"]
```

## 背景

这是一个业余项目。简单说，就是在某个小程序上有个类似抢票的功能，我们希望能够实现自动化更快更稳地抢到票。

之前已经有同学用模拟操作实现了自动脚本，但是因为某些原因好像运行结果并不理想。

于是我这个后端出身的程序员就想，能不能直接破解一下接口呢？

## 思路

其实思路很简单，找到接口的出入参数，推理出它的运行逻辑，然后再尝试自己构建请求。

问题就是怎么去找工具实现罢了。

最核心的就是要代理劫持抓包，要抓包的话有很多现成的工具，例如 Charles，这个工具在网上已经有无数的中文文章来讲解了（例如 [这篇](https://juejin.cn/post/6874903020677791758) ），不过我还是喜欢折腾，（我也不信任这些简单无脑的工具），所以想到了手边最熟悉的V家的代理，所以就用它来看看！

## 步骤一：确定后端域名

先在手机上开启v家代理客户端，在配置中要开启流量探测、并且将日志级别调到debug。

然后开启小程序。

查看日志，用肉眼很快就能找到那个后端域名，`xxx.xxx.com`，这就是我们的劫持目标了。同时可以发现请求的端口是`443`，因此我们是无法直接看到请求内容的，所以必须要劫持HTTPS。

## 步骤二：自签证书

在我之前的博客文章中已经对HTTPS的安全性做过深入的探讨，结论是：只要客户端运维正常、服务端证书不泄露、根证书秘钥不泄露，那么HTTPS无法破解。

在上述条件中，我们能够控制的只有客户端了。so，方法就是给客户端安装一个自签名证书、给这个域名签个子证书（证书劫持），然后在代理上将这个域名的请求发到我自己的安装了自签名证书的服务端上（反向代理或者DNS劫持）。

关于自签证书，网上的文章不少，但是实际操作中发现有一大堆坑…… 最终我的解决方案参考： [stackoverflow](https://stackoverflow.com/a/66980106/12159549) 

随便找个目录，最好是你方便访问的的地方，先签根证书：

```shell
openssl genrsa -out ca.key 2048
openssl req -new -x509 -days 365 -key ca.key -subj "/C=CN/ST=GD/L=SZ/O=起个名字吧, Inc./CN=起个名字吧 Root CA" -out ca.crt
```

然后用上述根证书，对指定域名签发一个泛域名证书：

```shell
openssl req -newkey rsa:2048 -nodes -keyout server.key -subj "/C=CN/ST=GD/L=SZ/O=起个名字吧, Inc./CN=*.目标域名.com" -out server.csr
openssl x509 -req -extfile <(printf "subjectAltName=DNS:*.目标域名.com,DNS:*.目标域名.com") -days 365 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt
```

此时你会得到一共6个文件。

将`ca.crt`安装到本机中（准确的说，是安装到客户端中，例如运行小程序的手机中）。以Mac为例，打开 钥匙串-系统钥匙串-系统-证书 页面，然后将`ca.crt`拖进去；然后右键单击刚才导入的证书，显示简介，信任页面，选择"始终信任"。

将`server.crt`和`server.key`放在你的反向代理服务器上，例如可以启动一个nginx来处理，这个是基本操作，略过。

然后改DNS。一种思路是直接修改系统Hosts文件，以Mac为例，文件位于`/etc/hosts`，sudo修改一下就行。同时，对于反向代理，要有能力越过DNS直接访问真实目标地址，如果跟我一样用的是Golang，可以设置`Transport`对象来修改解析结果，这个之前有文章介绍过。

最后验证一下。不出意外的话此时在代码中已经可以正常访问`https://xx.目标域名.com`了，但是Chrome中依然会提示「您的连接不是私密连接」，后者的解决方法参考 [文章](https://aibofan.com/jie-jue-chrome-liu-lan-qi-zi-qian-ming-zheng-shu-zai-chrome/) ，简单说就是在这个页面上手动输入`thisisunsafe`这11个字母（页面上而不是控制台上，类似以前玩游戏输入作弊密码）（实测Mac需要，Win不需要）。

## 插话：一些golang代码

得益于Golang的完整加密套件实现，用gin框架可以直接使用ssl证书，不需要依赖nginx。用法是：

```go
g.RunTLS("0.0.0.0:443", "server.crt", "server.key")
```

做代理时，使用通配符可以匹配任意路径，用法：

```go
g.Any("/*proxyPath", func(c *gin.Context) {
    fmt.Println(c.Param("proxyPath"))
    c.String(200, "hello, from gin.")
})
```

在上面的基础上，就可以实现一个反向代理了。这个事情标准库已经帮我们做好了（ [参考阅读](https://le-gall.bzh/post/go/a-reverse-proxy-in-go-using-gin/) ），我们可以直接用，也可以照着抄然后根据自己的需要来修改。（得益于Golang的接口设计和静态类型，随便改都能用，这是其他语言不敢想的）

```go
func main() {
    remote, _ := url.Parse("https://目标地址.com")
	proxy := httputil.NewSingleHostReverseProxy(remote)
    //proxy.Director = ...
    //proxy.Transport = ...
    //proxy.ModifyResponse = ...
	
	g := gin.Default()
	g.Any("/*proxy", proxy)
    g.RunTLS("0.0.0.0:443", "server.crt", "server.key")
}
```

然后还要注意一个细节，当需要读取`http.Request.Body`或者`http.Response.Body`的时候，一定要记得，他们会记录读取的状态，例如一旦`ReadAll`了之后，它们的内容就清空了，会导致后续函数读到空的Body。所以读取之后要重新赋值一个`Reader`回去。

## 插话：搭建V代理

简单介绍一下V家代理的原理，每个core都是一个节点。

- 客户端的core，`inbound`是本地代理，`outbound`是另一个V节点，比如说你配置好的服务器。
- 服务端的core，`inbound`是来源于客户端或者另一个节点，`outbound`则发往外面的世界。

所以，只要在本地电脑上作为服务器启动一个core，然后对原来手机客户端配置一下，那么手机上所有的流量都进入到电脑上启动的V进程中了。

在本例中，先配置电脑（服务端）上的core，设置一个`vmess`作为`inbound`，然后设置`freedom`作为`outbound`即可。然后配置手机（客户端）的代理，添加一个`vmess`配置，内容跟刚才电脑上配置的一样即可（主要是`id`）。

> 话说，我今天终于理解了这个freedom的意思，哭笑不得。

我这里是下载了V的源码，直接在根目录下建立`config.json`就可以运行了，可以打断点查看运行状态，并且不会跟电脑上已经运行的其他V客户端相冲突。

## 步骤三：客户端安装证书

前面说了要将`ca.crt`安装到客户端中，但其实这里还不少坑的，说说我踩过的。

在Mac上安装证书，体验还行，钥匙串管理起来还挺方便的。

在Android（我用的红米）上，坑就来了。

安装方法倒是简单，随便启动一个gin挂载一个静态文件路径，然后用手机去访问下载就行了。

但是，我在Mac上生成的证书始终无法在红米上安装，提示「需要私钥才能安装证书」。而我用同样的命令，在Windows的WSL的Ubuntu环境中生成的证书，是可以顺利安装的。猜测是不同环境下的`openssl`实现有细微差别。

然后最最最大的坑，是证书信任的问题。证书可以任意安装，但是一般情况下安装之后它会被认为是「不可信」的，通过这个不可信的证书访问资源，客户端会感知到，例如Chrome地址栏会变红，例如微信就是直接拒绝握手……

要信任证书，就要root，so，安卓放弃。

在Windows上安装证书，装是能装上，也能设置信任，但是那个证书管理界面还是上个世纪的风格，看着就心很慌……而且我关闭窗口重新进入之后，我居然找不到我刚才安装的证书了，++心慌……

因为微信Windows版现在也可以运行小程序了，而且我们可以实现对Windows的完全控制，所以Windows是最好的实验平台。

## 步骤四：结果

到此为止，我已经破解了接口的出入参数，看了看，嗯，大部分接口都是JSON格式，做的还挺规范的。

但是很快我发现事情并没有那么简单……

首先有一些比较重要的接口带有一大段二进制内容，而正是这些接口上我没有找到我所期待的内容，也就是说，我期待的内容应该就在这段二进制数据里。我猜测是 protobuf 格式，或者aes加密，或者简单的`hex.DecodeString()`等等等等，转化二进制的思路很多，所以我也懒得做实验去猜了。

其次，我们要预定的票，它的编号是没有规律的（即不是简单按照时间、位置等参数相加的），而是对应一个类似 Mongo ObjectID 的东西。所以我没办法预先猜测下一批票源的编号。

第三，最重要的下单接口，居然是加了前端签名的…… 我淦啊…… 虽然理论上说，前端是不设防的，它的加密秘钥和算法一定就在前端代码的某个地方明文写着，但是我要把它逆向出来还得费多少工夫啊……

综上所述，接口破解计划宣告失败。

## 总结

虽然计划失败了，但是感觉这个过程还是有点意思的，学了很多工具的使用方法，还第一次站在攻击者的角度体会了一下接口安全的各项手段对于实际操作的影响。这些东西是平时工作接触不到的。

说实话，之前我还以为这种小程序应该是这种国企养的混子开发团队开发的，或者要不就是处于鄙视链底端的外包团队开发的。然而实际接触之后（不仅仅是这些接口，还包括他们官网），我发现这是一家足够专业的服务提供商，至少对得起他们「xxx整体解决方案服务提供商」的自称。是我太飘了。
