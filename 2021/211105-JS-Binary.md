```yaml lw-blog-meta
title: "JS二进制数据操作"
date: "2021-11-05"
brev: "关键字: ArrayBuffer Blob"
tags: ["前端"]
```

## 背景

如果只是个 CRUD Boy ，那其实是不用在乎二进制的，全部用语言运行时提供的常规类型就足够完成产品需求了；但一旦开始搞一些高端应用或者性能优化领域，那么直接操作二进制肯定是十有八九的事情。

本文稍微深入理解一下JS中的常规二进制操作。

## 字节序

> 参考阅读： [Endianness - MDN](https://developer.mozilla.org/en-US/docs/Glossary/Endianness) 

我们知道计算机的数据流都是二进制是吧，010011100这个样子的。在二进制之上，有「字节`byte`」的概念，一个字节是 8bit 。在字节之上，有了我们常见的各种数据类型，例如`int`，现在一般情况都是`int64`，意思是有 64bit，也就是 8字节 。

然后再回顾一下十六进制表示法。一个十六进制数，是 4bit 对吧，那么两个十六进制数可以表示为 1字节，那么`int32`则可以用8个十六进制数表示。

举个例子，我们用十六进制数声明一个数字变量：`var a int32 = 0x10203040`。（这个数字用十进制表示是`270544960`）

那么这个数字在内存中是如何存放的？想象一下，在一堆二进制（十六进制表示）数据流中，它会是`..` `..` `10` `20` `30` `40` `..` `..`这样排列的吗？

像上面这种，从高位写到低位的写法、也是符合人类直觉的写法，叫做「大端序`big-endian`」。

但它并不符合计算机的直觉。因为这个变量中的数据`0x10203040`在内存中只是一堆二进制中的一部分而已；在用某种规则去分析之前，计算机并不知道，`10`这个字节，是要跟前面三个字节组合起来才有意义呢，还是跟后面三个字节组合起来才有意义呢？

所以，对计算机来说效率最高的是从低位读到高位，即`40` `30` `20` `10` 这个顺序。这叫「小端序`big-endian`」

（注意，字节是一个最小单位，一个字节(byte)内部的位(bit)的顺序是不会打乱的。所以`Endianness`也被是翻译为字节序而不是位序）

某台设备到底大端序还是小端序，取决于它的硬件平台，跟软件无关（当然操作系统硬要模拟一下也不是不行）。而目前我们主流的 x86, ARM 等芯片都是**小端序**，所以至少在大前端开发的领域，可以默认都是小端序，不需要额外的兼容逻辑。

什么时候会碰到大端序？大概只有在某些嵌入式开发领域，以及网络通信协议中才会有。

我现在使用的机器是 MBP 2018 Intel Core i5 。尝试在JS（浏览器环境）中验证一下字节序：

```javascript
const buffer = new ArrayBuffer(4);
(new Int32Array(buffer))[0] = 0x10203040;
String(new Int8Array(buffer));  // '64,48,32,16'
```

尝试在Golang中验证一下字节序：

```go
func main() {
	var num int32 = 0x10203040
	var array = (*[4]byte)(unsafe.Pointer(&num))  // 将int32强制转化为[4]byte
	fmt.Println(array)  // &[64 48 32 16]
}
```

## ArrayBuffer家族

### ArrayBuffer

> 本节参考自 [ArrayBuffer - MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 

`ArrayBuffer`对象代表着一个通用的、固定长度的、二进制数据缓冲区。

它是一个"字节组成的数组"，在其他语言中一般被称为「字节数组`byte array`」（在Golang就是`[n]byte`）。但是你不能直接用这个对象去操作底层的那个二进制缓冲区，你只能用 `TypedArray`或者`DataView`去操作。

(TODO)
