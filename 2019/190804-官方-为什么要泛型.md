```yaml lw-blog-meta
title: '[TheGoBlog] Why Generics?'
date: "2019-08-04"
brev: 发布时间2019-07-31。官方博客这篇文章引起了我的兴趣，是说有关于泛型的。
tags: [Golang]
```


原文地址：[The Go Blog](https://blog.golang.org/why-generics)

## Why Generics?

Ian Lance Taylor  
31 July 2019

## 介绍

这是`Gophercon 2019`一篇演讲的记录，可以找到视频。

这篇文章是关于：向Go中添加`泛型`意味着什么，以及为什么我认为我们应该这么做。

Go诞生于2009年11月10日，在不到24小时的时间内我们就看见了第一条关于`泛型`的评论（这条评论还提到了`异常`，我们在2010年添加了`panic`和`recover`来应对）。

在为其三年的Go语言调研中，`泛型的缺乏`在所有fix问题中位列前三名。

## 为什么要泛型？

引用 Jazayeri, et al 的话：`泛型编程`允许以通用的形式来表示`函数`和`数据结构`，并分析出`类型`。

一个简单的例子，假设我们反转`切片`中`元素`的顺序，这是很常见的：

```go
func ReverseInts(s []int) {
    first := 0
    last := len(s)
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

非常简单，但即使是这样一个简单的程序你也会想要写一些测试案例。事实上，我测试的时候发现了bug。
我敢肯定你们都发现了：

```go
func ReverseInts(s []int) {
    first := 0
    last := len(s) - 1   // 译者注：这里
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

接下来我们反转一个`字符串`：

```go
func ReverseStrings(s []string) {
    first := 0
    last := len(s) - 1
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

两个函数比较，它们真的极度相似，除了参数的类型不同以外。

很多Go的初学者都会被这个问题震惊：居然没有任何办法写一个简单的`Reverse`函数来处理任何类型对应的切片。

而绝大多数其他的语言允许你实现。

在动态类型语言，比如`Python`或者`JS`你可以非常简单的写，根本不用考虑类型问题。
而Go不行，它是静态类型的，而且要求你写下准确的`切片`类型和`元素`类型。

其他静态类型语言，比如`C++`, `Java`等，都支持泛型来解决你的这个问题。

## 现在的Go泛型

那么现在的人们如何在Go中实现这样的功能？

你可以用`接口`，并在你想要传入的`切片`类型上定义一个`方法`。
这也是标准库中`sort.Sort`的实现原理。

换句话说，`接口`就是Go中的`泛型编程`。
`接口`允许我们捕捉不同`类型`之间相同的特性(They let us capture the common aspects of different types)并将它们表达为`接口方法`。
我们可以根据`接口`来编程，然后这个函数可以在任何实现了这些`接口方法`的类型上运行。

但这不是我们想要的。使用`接口`你不得不自己写`接口方法`。就为了一个简单的功能，你不得不给一个已有的`类型`定义一批`接口方法`，这会是非常烦人的。并且你给每个`类型`写的`接口方法`都是极度相似的。
所以`接口`并不是真正的`泛型`。

另一种可以不用自己为`类型`写`接口方法`的方法，将会是让语言本身给某些`类型`定义`接口方法`。
现在Go并不支持，举个例子，语言可以定义每种`切片类型`都有一个`Index`方法可以返回一个`元素`。但是为了实现它，那返回值`类型`就必须是一个`空接口`，那么我们`静态类型语言`所带来的好处就一无所有了。再讲细节一些，我们将没有办法写一个允许接收两个相同`类型`的不同`切片`对象的`泛型`函数，或者一个允许接收某种元素类型的map并返回相应元素类型的slice的`泛型`函数。Go是`静态类型语言`是因为这使得编写大型程序更容易，我们不希望损失了`静态类型语言`的好处来获得`泛型`的好处。

还有一种办法是用`反射`包，但它写起来很烦人，而且效率很慢，所以很少人用它。而这种方法依然要求准确的`类型断言`并且没有`静态类型检查`了。

再再再有一种办法，就是你写一个`代码生成器`来给每个`类型`生成相应的方法。目前就有几种`代码生成器`实现了类似的功能。但是，它增加了额外的步骤；并且使`构建`变得复杂，因为必须`编译`所有不同的副本；而且每次修复bug都要重新`编译`所有的`实例`，其中一些`实例`可能完全位于不同的项目中。

所有的方法都非常麻烦，所以我认为人们必须每次现写一个函数来为特定的`类型`实现这样简单的功能。然后接着又是`测试案例`，来确保不会不小心犯下低级错误。

> 译者注：的确，我现在就是这样做的，每一个简单的功能都要附带测试，非常麻烦。

## 泛型能给Go带来什么

首先我们最想要`泛型`带给我们的是，允许我们编写类似`Reverse`这样通用的函数而不用考虑具体的`类型`。我们想要分解出元素类型，然后我们就只需要写一次这个函数，写一次测试，然后放在GoPATH，就可以随心所欲的用它了。

更理想的是，既然处在开源的世界中，只要某人写了一次`Reverse`函数，那么全世界的人都可以用了。

其实`泛型`意味着很多很多很多好处，但此时我只说这些。特别地，我不是指c++那种`模板`(templates)，它支持的功能比我在这里所写的要多很多。

除了`Reverse`，还有很多例子可以实现，比如：

- Max(), Min()  in slice
- Average(), StandardDeviation()   of slice
- union(), intersection()   of map
- `图`中的最短路径

还有一些例子，是Go特有的（利用其强大的`并发`特性）:

- 带有等待时间限制地从`信道`中读取
- 将两个`信道`合并为一个
- `并发`调用一批`函数`，并将结果以`切片`形式返回
- 使用`上下文`(Context)来`并发`调用一批`函数`，只需要第一个完成的返回结果，同时取消其他的Go程

这些功能已经有很多实现了，在Go中并不难。但是如果能够`复用`一个高效的并且经过调试的`实现`，将会是很棒的。

除了函数，还有数据结构。

Go有两种类型通用的数据结构——Map和slice。它们可以持有任何类型的数据，还能带有`静态类型检查`，并且所有数值都是原样保存，而不是用了`接口`。

除了它们以外，还有：

- Sets  集合
- Self-balancing trees   平衡树，能高效、有序地插入和遍历
- Multimaps   多重字典，允许多个对象作为键
- Concurrent hash maps   同步哈希表，允许并发插入和查询，而不需要锁

如果我们能实现`泛型`，我们就可以定义像上面这些的`数据结构`。而且我们可以引入更多的`算法`。

## 收益和成本

但是`泛型`并不是天上掉下来的，每一个语言上的改进都是有代价的。毫无疑问引入`泛型`会让语言变得更加复杂。和其他特性一样，我们必须要讨论如何最大化利益并且最小化代价。

在Go中，我们的目标是通过可以自由组合的独立的、正交的语言特性来降低复杂性。我们让独立的特性保持简单，并允许它们自由组合，以此降低复杂性。对于`泛型`，我们也想要这样做。

我必须强调几个大纲：

1. 尽可能少的新概念(concepts)

    即最少的新语法、新关键字和其他名称。

2. 复杂度应该由泛型开发者承担，而不是使用者

    我们不希望用户担为`泛型`感到焦虑。这意味着调用`泛型函数`必须通过自然的方式，意味着错误处理也要易于理解和修复。

    > 译者注：这里说的开发者，并不是说语言层面的开发者，而是指某个泛型类库的开发者。

3. 开发者和用户互不干涉

    我们希望`泛型`功能的开发者与用户二者关心的东西能够很容易地分开，这样他们可以互相独立地开发。他们不必担心另一个函数在做什么，就像不同包中的正常函数的编写者和调用者不必担心一样。这听起来很奇怪，但是其他任何语言的`泛型`功能都没有做到这一点。

4. 减少编译实践，加速执行效率

    我们想要保持目前Go语言的快速编译与高效执行的特性。`泛型`往往会让我们在编译效率与执行效率之间做权衡，但我们希望鱼与熊掌兼得。

5. 保持语言的清晰和简单

    最重要的是，现在的Go是一门非常简洁的语言。Go程序总是非常清晰并且容易理解。我们在探索这个领域的漫长过程中，一直试图理解如何添加泛型，同时保持这种清晰和简单。我们需要找到一种机制来尽可能地适配现在地语言，而不是把它变成一个新的玩意。

以上几点内容适用于任何一个Go的`泛型`实现。最最重要的一点就是，虽然`泛型`可以给语言带来巨大的好处，但是**如果它使得Go不再像Go了，那就没有任何意义了。**

## 设计草稿

幸运的是，我认为以上都可以做到。现在我们将目光从理由和需求上移开，来简单讨论一下我们设计的一个初稿。

在今年的`Gophercon`上，`Robert Griesemer`和我发表了一份Go语言的`泛型`设计初稿。细节请去看那份文件，我这里简单介绍一下主要内容：

这是用初稿版本`泛型`实现的Reserve函数：

```go
func Reverse (type Element) (s []Element) {
    first := 0
    last := len(s) - 1
    for first < last {
        s[first], s[last] = s[last], s[first]
        first++
        last--
    }
}
```

> 译者注：第一眼看到这个泛型实现，真的很惊喜，的确在最大程度上保留了Go语言原有的样子。

你会注意到函数的主体完全相同，只有`函数签名`变了。

不再强制声明切片元素的`类型`了。它（元素类型）现在被命名为`Element`（仅在这个函数中）并且变成了我们所谓的`类型参数`。`类型参数`没有成为函数参数的一部分，而是一个独立的、附加的类型参数。

在调用一个带有`类型参数`的函数的时候，一般来说你要传递一个`类型参数`，它跟其他的参数看起来非常相似，只不过它是一个类型而已。

```go
func ReverseAndPrint(s []int) {
    Reverse(int)(s)  // 译者注：这里
    fmt.Println(s)
}
```

在这个例子中就是`(int)`这个东西了。

更幸运的是！在绝大多数情况下，`编译器`可以自行从`常规参数`推断出`类型参数`，那么你就根本不需要再去关注`类型参数`了。

调用一个`泛型`函数就跟调用一个非泛型函数一样了：

```go
func ReverseAndPrint(s []int) {
    Reverse(s)  // 译者注：这里
    fmt.Println(s)
}
```

换句话说，虽然`泛型`版本的Reserve函数比普通的ReserveInts和ReverseStrings函数稍微复杂一点点，但是这种复杂度全都负担在函数的`开发者`身上，而不是`使用者`。

## 契约

因为Go是一门静态类型的语言，我们必须要讨论一下`类型参数`的`类型`。这个`原始类型(meta-type)`会告诉`编译器`在调用`泛型`函数时允许使用哪种类型的`类型参数`，以及`泛型`函数可以对`类型参数`的`值`执行哪些操作。

上面的Reserve函数现在可以用于任何类型的切片了。它对`类型参数`Element的`值`所做的唯一一件事就是赋值，这可以对任何Go中的类型生效。对于这种常见的`泛型`函数，我们不需要写任何关于`类型参数`的代码。

让我们看一个不同的例子：

```go
func IndexByte (type T Sequence) (s T, b byte) int {
    for i := 0; i < len(s); i++ {
        if s[i] == b {
            return i
        }
    }
    return -1
}
```

目前，`bytes`包和`strings`包都有一个IndexByte函数。这个函数返回字符`b`在序列`s`中的`索引`，同时`s`既可以是string也可以是[]byte。我们用这个`泛型`函数来代替这两个函数。

现在我们需要知道`类型参数 T`是如何扮演了sting或者[]byte的角色的。我们可以对它调用`len`，我们可以用索引去查询它，并且将索引查询的结果与一个`byte`类型的值进行比较。

为了编译这个，`类型参数 T`它自己需要一个类型。它是一种`原始类型(meta-type)`，但是有时我们需要描述一些有共同特征的`类型`，并且这种描述必须在`泛型`函数和其调用者之间建立联系，我们实际上将`类型参数 T`称为`契约(contract)`。这是一个名为`Sequence`的`契约`：

> 译者注：契约(contract)应该是伴随泛型引入的新概念了，从这里看来，其用法很像接口的感觉。

```go
contract Sequence(T) {
    T string, []byte
}
```

它非常简单，因为这就是一个简单的例子。这个`contract`可能会称为一个新的`关键字`，或者是一个在包范围内的`特殊标识符`。详情请去看初稿设计。

如果有谁记得我们在`Gophercon 2018`上公布的设计，会发现这种`契约`的写法比以前简洁了许多。我们之前的设计获得了大量的反馈，都说`契约`太复杂了，所以我们已经尽力把它简化了。新版的`契约`更容易写，更容易读，更容易被理解。

`契约`允许你限定一个`类型参数`的底层类型，和/或列举这个`类型参数`应该带有的`方法`。它也允许你描述不同的`类型参数`之间的关联。

## 带有方法的契约

这是另一个简单的例子，是一个使用了String方法来返回一个`[]string`，这个`[]string`表示`s`中的所有元素。

```go
func ToStrings (type E Stringer) (s []E) []string {
    r := make([]string, len(s))
    for i, v := range s {
        r[i] = v.String()
    }
    return r
}
```

这非常直观：遍历整个切片，对每个元素分别调用String方法，然后把结果字符串们以`[]string`的形式返回。

这个函数需要一个带有String方法的类型参数。这个名为`Stringer`的`契约`保证了这一点。

```go
contract Stringer(T) {
    T String() string
}
```

这个`契约`只是说`T`必须实现了String方法。

你可能注意到了这个`契约`长得非常像`fmt.Stringer`接口，所以值得一提的是上面写的这个ToStrings泛型函数的参数并不是一个`fmt.Stringer`的切片。它是一个对应某种元素类型的切片，这个元素类型实现了`fmt.Stringer`。在内存中，元素类型的切片与接口的切片是完全不同的。Go也不支持他们之间的直接转换。所以这个函数是值得写的，即使`fmt.Stringer`已经存在了。

## 多种类型的契约

```go
type Graph (type Node, Edge G) struct { ... }

contract G(Node, Edge) {
    Node Edges() []Edge
    Edge Nodes() (from Node, to Node)
}

func New (type Node, Edge G) (nodes []Node) *Graph(Node, Edge) {
    ...
}

func (g *Graph(Node, Edge)) ShortestPath(from, to Node) []Edge {
    ...
}
```

以上我们描述了一个由节点和边构成的`图`。我们不需要特别定义一种数据结构来实现这个`图`，我们只需要规定Node类型必须有一个（会返回所有与Node相连的Edge的列表的）Edges方法。并且Edge类型必须有一个（会返回这个Edge连接的两个Node）Nodes方法。

我直接跳过了具体的实现，但写出了New函数和ShortestPath函数的签名。

我想说的是，`契约`并不只限定于单个类型。它可以描述两个或更多个类型之间的联系。

## 有序类型

Go语言有一个令人惊讶的常见的抱怨，那就是它没有一个Min函数（或者Max函数）。这是因为一个有效的Min函数应该对任何有序类型都适用，这意味着`泛型`。

虽然你自己写一个Min函数也轻而易举，但是如果有一个`泛型`的实现添加在标准库中那也是极好的。它可能长这样：

```go
func Min (type T Ordered) (a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

以上的Ordered契约规定了，类型T必须是一个`有序类型`，即它必须支持大于、小于等操作符。

```go
contract Ordered(T) {
    T int, int8, int16, int32, int64,
        uint, uint8, uint16, uint32, uint64, uintptr,
        float32, float64,
        string
}
```

Ordered契约只是一个所有在语言中定义了的`有序类型`的一个集合而已。这个契约接受任何有序的类型，或者底层类型是上述类型的任何自定义类型。基本上是任何你可以用小于操作符的类型。

事实证明，简单地枚举支持小于操作符的类型，要比发明一种适用于所有操作符的新符号容易得多。毕竟，在Go中，只有内置类型支持操作符。

同样的方法可以适用于任何操作符，或者再通用一些，适用于任何想要操作`内建类型`的泛型函数。它允许泛型函数的开发者明确这个函数适用的类型。它允许泛型函数的适用者清楚地看见这个函数是否对指定的类型适用。

在实践中这个`契约`可能会写进标准库，并且Min函数（可能也会写到标准库的某个地方）将会像这样：

```go
func Min (type T contracts.Ordered) (a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

## 泛型数据结构

最后，让我们看一个简单的`泛型数据结构`，一个`二叉树`。在这个例子中，`二叉树`有一个比较函数，所以不需要指定`元素类型`。

```go
type Tree (type E) struct {
    root    *node(E)
    compare func(E, E) int
}

type node (type E) struct {
    val         E
    left, right *node(E)
}
```

下面是如何创建一个新的`二叉树`。比较函数通过New函数来传递。

```go
func New (type E) (cmp func(E, E) int) *Tree(E) {
    return &Tree(E){compare: cmp}
}
```

以下方法会返回一个指针，指向与参数`v`的值相等的节点（命中），或者是指向树中它应该指向的位置（未命中）：

```go
func (t *Tree(E)) find(v E) **node(E) {
    pn := &t.root
    for *pn != nil {
        switch cmp := t.compare(v, (*pn).val); {
        case cmp < 0:
            pn = &(*pn).left
        case cmp > 0:
            pn = &(*pn).right
        default:
            return pn
        }
    }
    return pn
}
```

在这里我们不关心细节，我只是想展示一下，写一个`泛型数据结构`会是什么样子。

以下代码可以查询某个`树`是否含有某个值：

```go
func (t *Tree(E)) Contains(v E) bool {
    return *t.find(e) != nil
}
```

以下代码用于插入：（译者注：插入成功返回true，如果已经存在该值则返回false）

```go
func (t *Tree(E)) Insert(v E) bool {
    pn := t.find(v)
    if *pn != nil {
        return false
    }
    *pn = &node(E){val: v}
    return true
}
```

注意`node`类型的类型参数`E`。这就是`泛型数据结构`的样子。可以看到，这很像典型的Go代码的写法，只是有一些类型参数散布在这里和那里。

使用这个`树`将会非常简单：

```go
var intTree = tree.New(func(a, b int) int { return a - b })

func InsertAndCheck(v int) {
    intTree.Insert(v)
    if !intTree.Contains(v) {
        log.Fatalf("%d not found after insertion", v)
    }
}
```

这就是它应该有的样子。也许要写一个`泛型数据结构`会有一点点难度，因为你经常要为允许的`类型`显式地指出`类型参数`。但是对于使用者来说，这与使用一个普通的非泛型数据结构几乎没有区别。

## 展望

我们正在努力写出一版实现，来允许我们来试验这个设计。在实践中测试设计是很重要的，以此来保证我们可以写出我们想要的程序的样子。进度没有我们想象中快，但是当它可以使用的时候我们会告诉大家的。

Robert Griesemer写了一个`preliminary CL`来修改原来的`go/types`包。这允许测试使用了`泛型`和`契约`的代码是否正常执行`类型检查`。现在还没有完成，但它只对一个包进行修改，我们将持续改进它。

我们希望大家做的是，尝试使用`泛型`来编写代码，并且观察会发生什么。我们想要确保人们可以写出他们需要的代码，并且能够像预期的那样使用它。当然最初可能不是一切都正常工作，而且当我们继续探索的时候我们也许不得不进行改变。并且必须强调的是，我们更感兴趣的是`语义(semantics)`的反馈，而不是`语法(syntax)`的细节。

我要谢谢所有对前版设计进行评论的大家，以及那些讨论过Go的泛型到底应该怎样的人们。我们阅读了所有的评论，并且非常感谢所有对此付出的努力。如果没有这些，我们走不到今天这个地步。

我们的目标是实现这样一种设计:既能编写我今天讨论过的那种泛型代码，又不会使语言过于复杂而无法使用，也不会让人觉得它已经过时了。我们希望这个设计是朝着这个目标迈出的一步，我们希望在学习的过程中继续调整它，从我们的经验和你们的经验中，学习什么可行，什么不可行。如果我们真的达到了这个目标，那么我们就可以为Go的未来版本提出一些建议。

（完）

## 小结

翻译全篇真的好累啊，虽然都能看懂，但是**看懂**和**用中文复述一遍**真的相差太多了。可能自己看一遍只要1个小时，翻译一遍恐怕花了七八个小时。

以后的文章如果不是特别重要的，我都懒得翻译了lol……

不过仔细看了一遍也收获很大，英语方面的就不提了，关键的是接触了很多最新的思想（比如在当前没有泛型的版本下，强行实现泛型有哪些方法），感觉打开了一扇全新的大门。

唯一想要吐槽一下的是，Golang的官方资料真的太难接触到了，看个Blog都需要技术手段，至于那些CL更是根本都打不开……

且学且珍惜吧。
