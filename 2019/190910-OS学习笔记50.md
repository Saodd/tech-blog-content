```yaml lw-blog-meta
title: OS学习笔记50：分布式：AFS
date: "2019-09-10"
brev: NFS的设计目标是单服务器，那么当请求量太多，如何拓展为多服务器？
tags: [OS]
```


# 第五十章 <The Andrew File System (AFS)>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/dist-afs.pdf)

AFS的主要设计目标是`扩容scale`，即如何让文件系统可以为尽可能多的客户端提供服务？

有很多方面的设计与实现能够影响扩展性。但是最重要的还是对于协议的设计。在NFS中，客户端会时不时地向服务器刷新缓存，当客户端数量达到一定程度，单一服务器就受不了。

## 50.1 AFS v1

我们讨论两个备案本，第一个版本实际上叫做`ITC`，做了一些基础上的改进，但是未能达到预期目标。

第一个根本的区别是，AFS会在客户端的硬盘上保存一个文件的副本，当close文件的时候将脏数据发回服务端。（NFS将文件的区块缓存在客户端内存中）

详细描述一下这个过程。当open时，AFS将完整的路径发到服务端（NFS是逐级目录发送），服务端将整个文件发给客户端；客户端在硬盘中保存该文件，因此read与write有较高的性能；close时检查文件是否被修改，如果是就将脏数据发回给服务端。

下一次再open这个文件时，AFS会发现它还在硬盘上，然后向服务端询问文件是否是最新的，如果是那就直接用，如果不是再重新下载。（AFS每次open才有一次查询请求，比NFS少很多）

## 50.2 v1的缺点

- 完整路径的检索太慢了：每次客户端请求文件都是完整路径（比如`/home/remzi/notes.txt`），因此服务端每次都要从根目录出发去寻找文件，这占用了太多CPU时间。
- 客户端的验证请求还是太多了。
- 负载不平衡：解决办法是引入`卷volume`，管理员可以移动卷，以此来尽可能做好平衡。
- 上下文切换开销太多了：服务器对每个客户端启用一个独立的进程。解决办法是使用线程。

## 50.3 改进协议

v1协议下，一台服务器只能服务20个客户端……

**关键问题：如何建立一个可扩容的文件系统协议？如何减少验证请求、如何让交互更高效？**

## 50.4 AFS v2

引入`回调callback`的概念来减少请求数量。回调就是如果某个客户端缓存着的文件如果发生了改变，客户端会主动通知客户端。因此客户端不再需要经常发起验证请求了，而是相信，在服务端通知之前文件一直是有效的。（其实就是同步与异步的区别，联想一下轮询与中断的机制区别）

引入`文件辨识器file identifier (FID)`来取代完整路径（它与NFS中的file-handle很像）。客户端用FID来指明它所需要的文件。因此服务端不需要逐级检索，由客户端逐级请求并缓存沿途的数据。

AFS与NFS最大的区别是，AFS每经历一个目录或文件，都会为其设置回调；因此沿途路径有任何的变化，服务端都会通知客户端。
虽然在初次建立连接时会有更多的通信，但是如果文件/目录很少被更新的话，那么也就很少回调通知了，因此大大较少了验证请求的数量。

## 50.5 缓存一致性

因为有了回调通知机制以及完整文件缓存，因此在AFS中缓存一致性自然就实现了。

当有客户端修改了文件，在关闭文件时，脏数据会被冲到服务端。然后服务端通知所有的在此文件上设置了回调的客户端，通知它们这个文件的缓存失效了，并关闭所有的回调。这样，在客户端如果再次访问这个文件，客户端就会重新抓取这个文件。

AFS不会通知同一个机器上的客户端。

如果多个客户端同时写入，AFS使用`后来居上last writer wins`的策略。注意与NFS的不同，NFS是基于区块的，因此最后的文件可能一部分来自A一部分来自B；而AFS是基于整个文件的，最后的文件是完整的。

## 50.6 故障恢复

AFS的故障恢复会比NFS更复杂。比如，假如有一段时间服务器无法连接到客户端C1，而C2更新了某个文件。那么服务器应该多次尝试通知C1，C1在恢复正常以后也应当认为所有的缓存都失效了。

服务器故障恢复更麻烦。因为callback都是储存在内存中的，当服务器故障后就都丢失了。因此当服务器重启后，所有的客户端都应该认为所有的缓存失效，并且重新从服务器拿取并重建callback。

## 50.7 拓展性与性能

AFSv2的性能有了极大的提升，一个服务器可以支持50个客户端。在客户端看来，性能也有极大提升，因为多数情况下都是从本地缓存中读取数据。

- 在许多情况下，NFS与AFS差距并不大。
- 在初次打开文件时，AFS较慢，因为要将整个文件写到本地文件系统中；但是在连续read时性能很高，因为都是在本地文件系统上。
- 在连续写入时二者性能相当。
- AFS在文件更新时性能很差。
- 获取大文件中的小区块时，AFS性能很差。

因此如何选择二者，还是要看实际的工作负荷。

## 50.8 其他改进

AFS提供一个全局的命名空间，所有用户使用完全相同的路径来访问。而NFS很灵活，因此需要一定的管理才能统一。

AFS更重视安全，提供多种验证机制。

AFS提供更灵活的用户权限控制，允许更灵活的文件共享。而NFS与UNIX的理念一样，对文件共享的支持有限。

AFS对系统管理员更加友好，提供更加简单的维护方式。

## 50.9 小结

AFS最关键的其实就是它的协议设计：尽可能地减少C/S交互。

但是，AFS正在逐渐衰落。现在流行的是NFS和CIFS（windows的分布式文件系统协议）。所以AFS目前对于世界的影响，也只剩下它的设计理念了。

# 第五一章 <Summary Dialogue on Distribution>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/dist-dialogue.pdf)

在学硬盘的时候我们就知道了，很多地方都可能出故障。而在分布式文件系统中，加入了网络的功能，因此故障点更加的多了。

但是我们可以设计一定的逻辑来隐藏这些故障，并且通过重试来消除这些故障。
