```yaml lw-blog-meta
title: OS学习笔记：总结
date: "2019-09-16"
brev: 刚好一个月的时间学完这本书。这本至少有六七百页全英文的大部头，啃完之后，受益良多。
tags: [OS, 杂谈]
```


## 学到了什么

### CPU的虚拟化

作为入门章节，先了解了进程是独立的资源管理单位。然后说了调度器的原理，陷阱指令与SystemCall，还有一些常用的调度算法。接着讲到多线程，知道了线程是CPU执行的最小调度单位。然后说到并发问题，讲了锁、信号之类的概念，以及并发编程中常见的错误。

我有什么收获呢？

- 调度器看起来没什么用。不过它应该可以帮助解释一些『性能』问题，可以让我遇到相关问题的时候不会懵逼。
- 陷阱指令帮助我理解Linux的权限控制。
- SystemCall让我理解了OS内核是如何与上层应用程序交互的。
- 多线程收获最大，因为这实际上是程序开发所需的知识。而且其中的锁和信号的概念我还需要更加深入的理解。
- 尝试了一下C程序的多线程编程，感觉还是怪怪的，不如Golang来的清爽。

### 内存的虚拟化

内存主要就是一个映射的问题。

- 映射首先将内存分页，分页需要翻译，翻译词条TLB会缓存起来。
- 虚拟地址空间，以此实现了内存隔离与保护。
- 硬盘交换区的一些概念。
- 重要的是了解了『时空局限性』，也就是学会如何利用缓存。这个概念对开发是很有帮助的。

### 硬盘的虚拟化

硬盘其实也就是一个映射的问题；不过比内存更复杂的是，硬盘会有故障，要考虑如何应对这些故障；而且，这种IO还有性能问题，因此要考虑数据结构问题，还牵涉到异步的概念。

- 通用IO设备的大致结构。
- 硬盘与RAID。
- 文件系统，学了这一章之后很多文件相关的问题都迎刃而解了，比如mount。
- 日志结构文件系统，具有更高的性能，并且适用于SSD。
- 分布式文件系统（网络文件系统），学到了一些网络通信方面的知识，比如TCP/UDP的选择，错误处理与重试，回调与缓存的更新等概念。

## 简单来说！

其实学的东西并不多，一句话说就是：

知道了OS在做什么！知道了程序如何与OS打交道！学了一些OS发展历史上遇到的坑以及相应的解决办法！

很难确切的定义这本书到底教会了我什么，但我内心深处能够踏实地感受到：我的的确确进步了。

再结合这几个月对算法与数据结构的学习，当我重新构思一个新程序（程序以及配套的数据库和部署）时，**我能以更准确的眼光来选择我所需的框架，我能以更精巧的代码来实现我所需的功能。**

而程序员所追求的，无非就是这个目标吧。

学海无涯，想成为一个合格的后端程序员，我的list上依然还有很多条目：网络通信、数据库原理是我接下来还需要去啃的两个硬骨头。

但是也说学以致用，当下还是稍微回归一下真实的开发，写个千三百行代码再继续泛舟吧。
