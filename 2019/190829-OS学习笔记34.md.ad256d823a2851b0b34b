```json lw-blog-meta
{"title":"OS学习笔记34：并发：总结","date":"2019-08-29","brev":"章节总结。","tags":["OS"],"path":"2019/190829-OS学习笔记34.md.ad256d823a2851b0b34b"}
```



# 第三四章

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/threads-dialogue.pdf)

## 如何写出正确的并发代码？

- 第一，保持简单！避免复杂的线程间互动，并且使用成熟的实现思路（比如简单锁，生产者/消费者模型等概念）。
- 第二，只在必须的时候使用并发！不成熟的优化（草率采用并发）是最糟糕的事情。
- 第三，如果需要并行，那么考虑一下其他的简单的并行方式。比如`Map-Reduce`用于大数据计算（译者注：我的理解是将数据进行分割然后求解）
- 多看，多学，多写！

## 我的小结

这个章节的名字叫『并发』，并发的基本单元是线程（多线程模型）或者协程（事件驱动模型）。核心问题就是资源的共享与互斥保护问题，因此有了锁、条件变量、信号等内容。

我记得Golang关于并发讲的最精彩的一句话叫做：

> Do not communicate by sharing memory. Instead, share memory by communicating.

不要通过共享内存来通信，而要通过通信来共享内存。

前者，通过共享内存来通信，正是传统的、C派系的并发实现方式。我虽然没有大量的运用，但是就凭这一章所见所学，以及在Python中的并发实操经验，我真的无比认同Golang的观点：这种方式太痛苦了！

相反，Golang中通过`goruntine`和`channel`（虽然可能只是老概念的新封装），非常非常便利地支持了并发操作。这种思想也许并不是Golang原创，但将其作为至高理念推广出来，我觉得就是一件丰功伟绩。
