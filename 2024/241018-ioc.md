```yaml lw-blog-meta
title: "什么是控制反转和依赖注入"
date: "2024-10-18"
brev: "尝试用最简单直白的语言来解释我所理解的控制反转和依赖注入"
tags: ["杂谈"]
```

## 背景

最近大半年我一直在琢磨设计模式。背过了八股、看过了书、也看了很多博客和帖子、也结合自己手头的项目做了反思总结和新的尝试，逐渐有了一些明悟，但总感觉还缺一点火候，所以暂时不长篇大论，先揪出一个小点来讲讲。

最近由于某些机缘巧合，我学习了`Nest.js`这个框架。它几乎将JAVA那套框架完整地复刻到了Typescript的世界中，我在学习之后认为，对前端工程师来说，它是一个非常好的学习设计模式的案例。其中我感触最深的就是控制反转和依赖注入模式。

## 控制反转-依赖注入

什么是控制反转？

我从一个常见的案例来解释。一个软件系统中往往会有多个代码模块（或者说逻辑单元），多个模块之间会相互依赖，A依赖B、B依赖CD、C依赖AD……等等。

一种典型的写法是直接引用依赖的模块，示例代码如下：

```ts
import { B } from '../b';

class A {
    b: B = new B();
}
```

上述代码，A模块依赖B，就直接在A里面引用（并实例化）B，这就是“控制正转”。

这样的直接引用，在系统代码规模增大以后，很容易形成复杂的交叉循环引用。虽然很多现代语言的模块系统能够处理循环引用，但是这种交叉循环引用所导致的代码逻辑耦合的问题仍然无法消除。举个形象例子，假如某天你想要复用模块A，你把代码复制出去一看，A依赖B、B依赖C、C依赖D，所有的东西都藕断丝连在一起，最后可能顺藤摸瓜把大半个项目的代码都牵连到了。

那所谓“控制反转”，就是不再主动控制依赖的东西、而是转为被动声明，示例代码如下：

```ts
interface IB {
    xxx(): void;
}

class A {
    b: IB;
}
```

A不再直接引用B，而是声明“我需要一个可以做xxx事情的东西”，只要能满足 IB 这个接口，无论给我 B 还是 B2、B3 我都无所谓。这样A、B两个模块之间就实现了解耦。

但是实际的业务逻辑是需要二者合作完成的，那么如何在运行过程中如何将二者关联起来呢？

一种解决方案就是“依赖注入”，即通过一个第三者来管理所有的模块，并在运行时传递，示例代码如下：

```ts
// a.ts
interface IB {
    xxxx(): void;
}

class A {
    b: IB;

    constructor(b: IB) {
        this.b = b;
    }
}
```

```ts
// ioc.ts
import A from './a';
import B from './b';

class IOC {
    constructor() {
        this.b = new B();
        this.a = new A(this.b);
    }
}
```

也就是说，原来的 A-B-C-D-E 之间的复杂依赖关系，现在全部切断并由一个共同的第三者 ioc 来进行组织，依赖关系变成了ioc对所有模块的单向依赖，所有模块互相之间完全解耦了。

依赖注入顺便还有另一个好处是方便替换。例如假如我要在本地对A做单元测试，那我可以直接mock一个B传进去：

```ts
// a.spec.ts
test(()=>{
    const b = new MockB();
    const a = new A(b);
})
```

## 控制反转-注册模式

与前面类似的思想，只不过方向调换一下，第三者不再主动提供，而是被动的注册再由调用方自行获取。示例代码如下：

全局注册树：

```ts
interface IA {};
interface IB {};

class Register {
    a: IA;
    b: IB;
}
```

业务模块依赖注册树：

```ts
// a.ts
import { register } from '../register'

class A {
    run() {
        register.b.xxx()
    }
    static register() {
        register.a = new A();
    }
}
```

这样的话，依赖关系就变成了所有模块依赖注册树（与之相反，依赖注入模式是IOC容器依赖所有模块）。

虽然理论上可行，但实际上仍然需要做与依赖注入模式相同并且更多的准备工作，模块有依赖也降低了灵活性，因此不如依赖注入模式。所以我们平常只考虑依赖注入模式。
