```yaml lw-blog-meta
title: '开放平台的接口安全'
date: "2020-12-02"
brev: "对接开放平台时，面对复杂的签名规则，我总是会默默吐槽：加签到底有什么鬼用？"
tags: ["网络"]
```

## 背景

作为开发者，总是会需要调用各种各样的"平台"的接口。在调用接口时，总是会见识到各种各样的验签规则。如果平台方没有提供你所使用的语言的SDK的话，那么，写一个签名函数总会是一个虽然不难但是挺烦人的这么一个事。

我就想，就非得这么啰嗦地给所有参数进行签名吗？

终于有一天我忍不住在技术交流会里提了这个问题。

于是在一番"友好"的讨论和我自己的反思总结之后，归纳如下：

## 1. 加密原理

可以从我的博客中找到简单的讲解： [191108-网络学习笔记8](https://lewinblog.com/blog/page/2019/191108-%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08.md)

简单来说，无论何种秘钥何种算法，其强度终究只和其秘钥长度正相关。

HTTPS的核心原理，是用高强度的非对称秘钥（RSA），交换一个临时的低强度（但高性能的）对称秘钥（AES），然后用对称秘钥来加密这个连接中的后续通信。过程中还会用到MD5之类的校验算法作为辅助。

以当前计算机的计算速度，其实：256bit的秘钥就已经算是无法破解了（AES属于此范围）；1024bit的秘钥则可以认为是完全不可能（RSA属于此范围）。

> 参考： [知乎 - 破解AES256位加密有多难？](https://www.zhihu.com/question/34563299) [暴力解决一切？破解AES也是妄想！](https://www.sdnlab.com/21145.html)

但毕竟并不是所有的AES都是256位的，说不定可能还有老古董在用56位的DES（TLS1.0最低支持40bit的加密协议）。但本文不考虑这种情况了，过时技术没有人权。

好，那有人可能要问了，除了暴力破解之外，有没有可能在算法层面找到漏洞？

——这个问题超纲了。但我愿意相信在2020年的今天，见证到AES出现致命bug的几率可能比川建国感染新冠的几率还低（……

**强调：本文讨论的情况是全部基于`HTTPS`的。**~~证书都没有还搞什么网络安全~~

## 2. 传输过程中

假设网络中间人可以控制从请求方发出请求之后，到被请求的服务之间的所有路径并且可以做任何事情。

那么从逻辑上分析，他只有几种方案：

1. 抓下数据包，破解其中的内容。
2. 抓下数据包，不破解，用完整的数据搞点事情。
3. 从连接握手阶段就开始伪装身份，欺骗客户端使用假的秘钥来加密。

### 2.1 破解内容

HTTPS保护的范围是HTTP层的数据。因此，在TCP层及以下的层级的数据，都是公开的。（不公开的话路由器怎么把你的数据发到该去的地方？）

在传输过程中，攻击者能做的，就是把TCP的数据完整地录制下来进行分析。攻击者可以从中过滤出你发往某个平台的所有数据包，甚至识别出每一"根"TCP连接，但是此时数据包中的内容是被加密的。

这些加密数据有没有可能被破解？答案是：有。虽然AES256很难很难破解，但是如果破解之后的收益比成本更高（比如破解了支付宝），也许就真有人会去尝试破解，也许找到一个算法上的漏洞，找个超算算个十年八年的真给算出来也不是不可能？

应对方法：毕竟暴力破解需要时间。因此我们只需要在认证所需的数据中增加一个具有有效期的东西，让这个东西的有效期低于我们保守估计的暴力破解时间，那么暴力破解的方式就自然失效了。

参考实现：

- 微信小商店平台。平台方定时发放一个2小时有效期的token。
- JWT认证方式：JWT都是有一定有效期的。
- 终极大招：隔一段时间就手动改密码。

但，对于99.9999999……%的互联网从业者来说，应该都不用操心这个层面上的事情。需要做的，就是选择一个当下最安全的加密算法套装，然后偶尔改改密码就行了。

### 2.2 不需要破解的重放攻击？

如果攻击者就算是捣乱也能满足的话，如果不选择破解对称秘钥，那么拿着一份加密着的完整HTTPS请求去做`重放攻击`是他剩下唯一的选择。

但是，HTTPS 本身就是无法重放的。因为至少从 TLS1.0 开始，TLS层就增加了顺序号。

标准答案：
- [RFC 2246 - R.2](https://tools.ietf.org/html/rfc2246)

从一些论坛上可以发现很多人都搞不清楚这一点：
- [stackoverflow - Replay attacks for HTTPS requests](https://stackoverflow.com/questions/2769992/replay-attacks-for-https-requests)
- [v2ex - 使用 https 后，还有必要用 md5(secret+参数+时间戳)类似这样的方法做数据完整校验吗？](https://www.v2ex.com/t/469414)

### 2.3 伪造证书

假如攻击者劫持DNS，或者更深的层级，并伪装成被请求方给你发一个公钥，这样可行吗？（公钥用于TLS握手生成对称秘钥）

答案也是否定的。在正常的运维状态下。

需要使用TLS的网络设备都应当预先安装一些「根证书」（典型的是随着操作系统一起安装），这个世界上所有的HTTPS证书都是由这些根证书一级一级地验证出去的。所以说，在正常的运维状态下，使用正确的根证书，攻击者发来的伪造证书是会被一眼识破的。

所以问题就出在"不正常的运维状态"下。比如不懂技术的普通互联网用户，比如使用自签证书的，等等。为了我的Jenifer考虑，我不想去想。

> Linux环境根证书的一次踩坑： [Ubuntu遇到x509证书错误的解决办法](https://lewinblog.com/blog/page/2020/200305-Ubuntu%E9%81%87%E5%88%B0x509%E8%AF%81%E4%B9%A6%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.md)

### 2.4 小结

到这里，已经可以得出结论：在通信过程中的数据安全可以说是万无一失。

那么接下来在通信的两端有什么安全问题？在两端，我觉得安全问题都应该算是管理问题，而非技术问题。

我纸上谈兵地简单分析一下：

## 3. 开发者

开发者是开放平台接口的使用者。

对于平台方来说，开发者其实也就是一个用户。既然是用户那就得有密码，不论以何种形式，总归是需要一个"密码"之类的东西在开发者这边保管着。因此可以说，所有的安全策略也都是围绕着这个"密码"来做的。

在下文中，我将"密码"称为"secret"。

### 3.1 secret 本身

规范来说， secret 本身应当由专人（核心人员）保管，并通过运行时环境注入的方式提供给服务使用。

至于这个注入，是从环境变量呢，还是内存呢，是一个数据库呢，还是一项单独的服务呢，我觉得应该都可以。但是我没能搜索到一个比较被广泛接受的开源解决方案。（理由也许是：小公司根本不需要搞这么严格，大传统公司会有类似Oracle的专业敲竹杠服务，大IT公司会自己搞一套？）

参考实现： Github_Secret

参考讨论： [stackoverflow - Where should I keep the credentials of my database?](https://stackoverflow.com/questions/23693796/where-should-i-keep-the-credentials-of-my-database/23859726#23859726)

那么，运行时环境的secret会不会被泄露？是有可能的。假如攻击者能够登陆你的服务器，那他可以入侵容器，访问环境变量，或者做 memory snapshot，直接对你的内存进行分析。不过这就是另外一个问题了，如何保证服务器安全？这又是一个很大的问题，不讲。

那么，假设万一真被入侵了，我们选择何种通信加密方式会有区别吗？我想不会有任何区别。

### 3.2 源代码与日志

能够接触到公司源代码的开发人员，特别是有merge权限的人，往往肯定有查看日志的权限，两者相加，就可以从运行时环境中把secret套出来。

所以这就是个公司权限管理的问题。

### 3.3 仅靠日志就泄露了？

明知道日志的安全等级不高的情况下，还敢往里乱塞东西，恕我直言，只能说活该？

### 3.4 现实

现实情况中，我估计99.9999……%的互联网项目都做不到这么严格的保密措施，而且往往是自暴自弃走上另一个极端——直接把secret直接写在源代码里。

所以这其实是一个经济问题，即，一个项目到底值得花多少成本去做安全措施？如果做不到一定程度的话，干脆放弃也不失为一种明智的选择。

## 4. 平台方

平台方总是会比一般开发者有更大的体量，和相对更健全的管理机制。说白了，就是风险成本高，值得去考虑更多的安全细节。

但我想解决方案无非也就是权限的分级管理问题。就像几个根证书可以签发出那么多互联网证书一样，靠分级管理来实现。

## 5. 一个有趣的问题：secret到底能不能放在请求里

开发者对于平台来说也就只是个用户而已。所以这个问题与「网页/客户端用户登录时密码要不要哈希处理」其实是一样的。

所以secret到底能不能直接传？

这个问题可能需要分两种情况来考虑：一种是创建/修改secret本身，另一种是利用secret来做其他的业务请求。

### 5.1 创建/修改secret

无论多么牛逼规范的云服务/平台服务提供商，终归是要提供一个web（或者其他客户端形式）提供给用户来管理账户信息的。

一个前提是，无论是web还是客户端程序，只要发送到用户这边，还想要能运行，那就一定无法做到真正的「加密」，只能做混淆而已。因此客户端代码某种程度上来说是不设防的，所以，在客户端对secret本身做任何的安全措施其实都意义不大。

> 客户端加密只有一种安全的方式：公钥。因此一种可能的解决方案是，在客户端代码内再内置一个公钥，来对secret部分再次加密。这种情况暂时不讨论。

因此，在这个过程中，secret一定是以明文（或者等同明文）的形式传递到平台方。（这个过程由HTTPS保护请参考本文第2章）

明文secret传到平台方后，如何储存，有2种选择：

1. 原样存进数据库
2. 用服务端秘钥加密后存进数据库

正常的toC思维肯定会说，当然要加密后存进数据库啊！——好，问题来了，加密之后你就无法利用这个secret做两端签名验证了，后续的用户认证都只能使用明文密码。

现在我见过的绝大多数的平台方对于使用者的secret，都是原样储存并且能够查询的，然后secret是用来签名而不是直接传递的。

### 5.2 使用secret在开发者和平台方两端签名验证

我们先想象一下一个规范的认证过程的secret流向：

```text
开发者业务服务 -> 开发者secret网关 -> HTTPS -> 平台方secret网关 -> 平台方业务服务
```

当前最主流的方案就是，开发者（第三方服务商）用secret给自己的所有请求参数进行签名，请求到达平台方后，平台方用相同的secret对参数再次签名并对照指纹是否相符。

这样做的话，就是选择了本文5.1节所说的选项一：平台方原样储存和使用secret 。

这样做的好处：secret本身并没有在 「HTTPS环节」 中出现，而是以一种"精神"的形式传递着，不会在「HTTPS环节」环节中被暴露。

这样做的坏处：「平台方secret网关」 这个环节，secret是明文的，因此「平台方secret网关」的相关人员有机会窃取所有开发者的secret。

### 5.3 使用明文secret附带在请求中做验证

听起来好像很恐怖？

但是实际想一想，假如是做 toC 服务的，你会担心放在HTTPS请求中的C端用户的密码在传输过程中被暴露吗？

再回顾一下整个认证过程：

```text
开发者业务服务 -> 开发者secret网关 -> HTTPS -> 平台方secret网关 -> 平台方业务服务
```

这样做的话，就是选择了本文5.1节所说的选项二：平台方可以在「平台方secret网关」这个环节，储存并使用加密后的secret而非其本身。

这样做的好处和坏处，是与本文5.2节描述的情形刚好相反。

### 5.4 小结

所以，明文secret总归是要暴露的，无非就是选择，是暴露在HTTPS请求体中呢，还是暴露在数据库中呢？

OAuth2.0是推荐使用签名的方式传输的： [RFC 6749](https://tools.ietf.org/html/rfc6749)

我认为，这个问题的关键在于，一个请求的传输路径是否比我们想象的更长。一个典型的场景是，服务端前置一个Nginx做反向代理并且**顺便解密了HTTPS**，这意味着，在Nginx后面的服务集群内网中，所有请求是以明文形式传递的；而内网中的安全防范等级往往是很低的，因此明文的secret可能会在这个不安全的环境中被泄露，因此可以认为明文secret的风险点更多。

那么，是否有大厂在用明文这种方式呢？

微信小商店平台就是在用这种明文传输的方式。然后为了满足查询和管理secret的需求，采用了一个固定 api_key 和一个2小时有效期的 api_ticket 两者同时使用。 

但并不是说有大厂在用就证明这个方案完美。至少微信有一点洗不白的是，它把secret直接放在url或者body里了，这两个地方的确是真的很容易被日志打出来。我想，好歹放在一个X-Header里也能减少一些被意外泄露的情况。

然后，可能还需要强调的一点是，我上面的讨论，都是基于「岁月静好，我很规范」的情况下的。而现实情况往往是充斥着各种各样的妥协和将就，因此，选择用secret以签名的形式传递，控制点会更少一些，在现实环境中也许是能免去一些意外的沙雕情况的。

简而言之，两种方案各有各的毛病，我们只是从中选择了一个稍微好一些些的方式而已。

## 附：对这个问题的思考路径

0. 热身：来搞我的api啊
    我的api相当于是一个微型开放平台。我的secret就是明文传输的。大家来康康有什么漏洞啊。

1. HTTPS是万无一失的。
    就连重放也能防御。
    也许能够暴力破解，但是只要经常修改密码，暴力破解也没用。
    
2. 一套理想的认证体系应该是怎样的？（画图）
    
3. 在这个理想的体系中，有哪些风险点？以及应对方案？

4. 现实中作死的姿势有哪些？分别讨论：这些作死行为的风险在哪里？应对方案？
    列举一些：例如把secret写死在代码里

5. 各大平台的认证方式对比，优缺点讨论。
