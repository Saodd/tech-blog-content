```yaml lw-blog-meta
title: 'Golang: Chan 性能初探'
date: "2020-02-27"
brev: Golang语言的灵魂是协程，而协程的灵魂是chan。作为我们最常用的数据结构之一，chan的性能问题到底如何呢。
tags: [Golang, TODO]
```


## 缓冲区与性能

在公司项目中需要使用一个全局的唯一ID。以前用python的时候知道可以用生成器的概念来实现这种功能，因此现在用golang我也打算用类似的方法来实现。

因此我做了一个简单的chan，用一个go程来向其中推送ID。没有用锁，一方面是因为用锁更复杂，另一方面是go语言希望大家用chan来代替锁。

```go
var IdCounter = make(chan int)

func init() {
    go func() {
        for i := 0; ; i++ {
            IdCounter <- i
        }
    }()
}
```

那么问题来了。这个`IdCounter`要不要设置缓冲区？

一开始我认为，如果只有两个线程执行的情况，这边不断计算新的ID推送，另一边不断拿取最新的ID，理论上来说，两个线程并行执行，缓冲区是可有可无的。

但是做了一个简单的实验发现，问题并不是这么简单。我把缓冲区分别设置为`0,1,100,10000`，然后计算取10000000个ID所需的时间，代码如下：

```go
func main() {
    var i int
    now := time.Now()
    for i < 10000000 {
        i = <-huobi.IdCounter
    }
    fmt.Println(time.Now().Sub(now))
}
```

运行结果：

```text
make(chan int)          5.1959986s
make(chan int, 1)       3.9770013s
make(chan int, 100)     1.2439975s
make(chan int, 10000)   653.9966ms
```

这个结果与我之前的理论分析完全不同。结果表明，缓冲区对于性能的影响是十分明显的。这里可以看到，一次切换的时间损耗约为0.3-0.5us这个等级。

那么问题出在哪里？可能的解释有：

1. 两个协程运行在两个线程上，但是每次阻塞时，都进行了线程切换，造成了大量的性能损耗。
2. 两个协程运行在一个线程上，每次阻塞时，在线程内做协程切换，造成了一定的性能损耗。

（等忙完手头工作，再找机会仔细研究一下。）
