```json lw-blog-meta
{"title":"Gin 框架源代码速读","date":"2020-06-23","brev":"截止目前，在go的世界中，gin 应当算是最最流行的框架了。它简单、轻便，非常适合前后端分离的开发模式（即后端只负责数据交互，不负责渲染）。它的流行程度，从各大招聘平台的岗位描述上可见一斑。","tags":["Golang","坑","源码"],"path":"blog/2020/200623-Gin框架源代码速读.md"}
```



## 概况

开源在[Github](https://github.com/gin-gonic/gin)上。选用的是`MIT`开源许可，截止目前有 36.6k star、21 release、259 contributor、200+ open-issue、1300+ commit，使用了`go mod`并且最新版本已经迭代到了v1.6.2，设置了travis-CI，travis报告测试覆盖率98%。

gin文档中自称是高性能的web框架（我好像记得以前自称是『最快的web框架』）。但是就我个人从一些渠道的“榜单”上看到，好像gin并不经常上榜，可能有很多原因吧。具体有多快，我没有做过定量的测评，不过主观感觉上来说是很不错的。

这是一个非常丰富和全面的框架，所以我们顺着几个常用的方法向下挖掘。

> 阅读提示：请按顺序阅读，并仔细观察各个方法的名称。中途开小差的话，就算是我自己也会看不懂的 ：）

## 1. 服务的构建与启动

我们看一段最基本的启动代码：

```go
func main() {
	g := gin.Default()
	// ...然后注册路由、配置中间件等，都是对g对象的操作。
	g.Run()
}
```

其中`Default()`创建了一个默认配置的引擎，它配置了内置的Logger中间件和Recover中间件，以及打印出一些提示信息。

```go
// Default returns an Engine instance with the Logger and Recovery middleware already attached.
func Default() *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())
	return engine
}
```

这里值得一提的是，这两个内置的中间件是可以配置的。`Logger`中间件可以配置 Formatter, io.Writer 和 SkipPaths（不打印日志的url路径）；`Recovery`中间件只能配置 io.Writer 。

然后是 `New()` 函数，创建了一个 `Engine`对象并做了一些初始化的操作（这里的 `Engine` 的概念与其他框架中的 `app` 的概念是相同的）。我们可以也可以不用`Default()`而直接调用它，这样可以得到一个不带任何中间件的纯净引擎对象，然后自己配置所需的中间件。

```go
func New() *Engine {
	engine := &Engine{
		RouterGroup: RouterGroup{
			Handlers: nil,
			basePath: "/",
			root:     true,
		},
		FuncMap:                template.FuncMap{},
		RedirectTrailingSlash:  true,
		RedirectFixedPath:      false,
		HandleMethodNotAllowed: false,
		ForwardedByClientIP:    true,
		AppEngine:              defaultAppEngine,
		UseRawPath:             false,
		RemoveExtraSlash:       false,
		UnescapePathValues:     true,
		MaxMultipartMemory:     defaultMultipartMemory,
		trees:                  make(methodTrees, 0, 9),
		delims:                 render.Delims{Left: "{{", Right: "}}"},
		secureJsonPrefix:       "while(1);",
	}
	engine.RouterGroup.engine = engine
	engine.pool.New = func() interface{} {
		return engine.allocateContext()
	}
	return engine
}
```

其中有两个比较扎眼的对象，`RouterGroup` 和 `pool`，这两个分别在注册路由和执行请求的时候会用到，我们后面分析。

得到引擎实例后，我们启动它：

```go
// 注释说：这个函数将路由加载到 http.Sever 上然后开始监听请求。可以认为它是一个快捷方式。
func (engine *Engine) Run(addr ...string) (err error) {
	address := resolveAddress(addr)
	err = http.ListenAndServe(address, engine)
	return
}
```

它这个快捷方式好像也就是处理了一下监听地址，我们看一下它做了什么事情：

```go
func resolveAddress(addr []string) string {
	switch len(addr) {
	case 0:
		if port := os.Getenv("PORT"); port != "" {
			debugPrint("Environment variable PORT=\"%s\"", port)
			return ":" + port
		}
		debugPrint("Environment variable PORT is undefined. Using port :8080 by default")
		return ":8080"
	case 1:
		return addr[0]
	default:
		panic("too many parameters")
	}
}
```

哦，原来是我们可以偷懒，如果不在代码中写死监听地址和端口，它会自行生成一个默认的地址和端口。

## 2. 监听请求：http & net 标准库

接上，我们的业务引擎（`engine`）被作为事件的处理句柄，注册到了一个`http.Server`对象中。然后随着这个 server 对象的运行，我们的业务引擎自然就上线了：

```go
// http 标准库

// 注释说：这个函数监听TCP，并对每个请求调用handler去处理。默认支持keep-alives.
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)  // 1.申请监听者
	if err != nil {
		return err
	}
	return srv.Serve(ln)  // 2. 阻塞监听
}
```

### 2.1 申请监听者

在`Server.ListenAndServe()`方法中做了两步操作，先是利用`net`包申请一个监听端口号（获得一个监听者`ln`），然后就开始阻塞循环监听。

我们先看一下上面这个「监听者`Listener`」对象是个什么东西：

```go
// Listener 是流式网络协议的泛用监听者。一个监听者可能同时唤起多个go程。
type Listener interface {
	// Accept 等待并返回下一个连接。
	Accept() (Conn, error)

	// Close 关闭监听者。所有等待着的操作都会被释放并返回错误。
	Close() error

	// Addr 查询当前监听者对应的地址
	Addr() Addr
}
```

那么 `Accept` 是个什么概念？回顾一下tcp网络协议，tcp数据片段有四个地址信息（源IP，源端口，目标IP，目标端口），这四个信息定义了一个 tcp套接字，## todo

然后再回到前面看看这个监听者是如何被创建的：

```go
// net 标准库
func Listen(network, address string) (Listener, error) {
	var lc ListenConfig
	return lc.Listen(context.Background(), network, address)
}

func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) {
	addrs, err := DefaultResolver.resolveAddrList(ctx, "listen", network, address, nil)
	if err != nil {
		return nil, &OpError{Op: "listen", Net: network, Source: nil, Addr: nil, Err: err}
	}
	sl := &sysListener{
		ListenConfig: *lc,
		network:      network,
		address:      address,
	}
	var l Listener
	la := addrs.first(isIPv4)
	switch la := la.(type) {
	case *TCPAddr:
		l, err = sl.listenTCP(ctx, la)  // 看这里
	case *UnixAddr:
		l, err = sl.listenUnix(ctx, la)
	default:
		return nil, &OpError{Op: "listen", Net: sl.network, Source: nil, Addr: la, Err: &AddrError{Err: "unexpected address type", Addr: address}}
	}
	if err != nil {
		return nil, &OpError{Op: "listen", Net: sl.network, Source: nil, Addr: la, Err: err}
	}
	return l, nil
}
```

上面第一步`DefaultResolver.resolveAddrList`是将字符串类型的监听地址转化为结构化的监听地址。然后因为返回值是个列表，所以通过`la := addrs.first(isIPv4)`来取出符合条件（Ipv4）的第一项。

然后根据地址对应的协议类型，选择一个方式来执行，我们这里只看`listenTCP`：

```go
// net/tcpsock_posix.go
func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) {
	fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, "listen", sl.ListenConfig.Control)
	if err != nil {
		return nil, err
	}
	return &TCPListener{fd: fd, lc: sl.ListenConfig}, nil
}

// net/ipsock_posix.go
func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
	if (runtime.GOOS == "aix" || runtime.GOOS == "windows" || runtime.GOOS == "openbsd") && mode == "dial" && raddr.isWildcard() {
		raddr = raddr.toLocal(net)   // 这里不执行
	}
	family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)  // 底层网络参数
	return socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)  // 包装套接字
}
```

在上面代码中，`internetSocket`负责向底层申请一个套接字，然后这个套接字会作为「文件描述符`fd`」的形式包装在一个「监听者`Listener`」对象中，返回给上层。之后上层代码调通过监听者来操作网络数据。

到这里，我们从文件名中也可以看出，已经非常接近底层系统了。具体的系统底层网络参数我们暂时不深入了解，以后找机会再专门深入研究一下。

## 2.2 操作监听者

回到前面的`http.ListenAndServe()`函数中。我们现在已经获得了一个包含底层网络套接字的`TCPListener`，我们通过`http.Serve(ln)`来操作它。注意看下面代码中的注释：

```go
// Serve 接受从监听者传入的连接，并给每个连接创建一个新的go程去处理。在服务go程中，读取request内容，并调用Handler进行响应。
// Serve 结束时，一定会返回一个错误，并关闭监听者。
func (srv *Server) Serve(l net.Listener) error {
	// ...省略

	// 这里将listener包装起来防止被多次关闭
	origListener := l
	l = &onceCloseListener{Listener: l}
	defer l.Close()

	// 默认会给配置HTTP/2
	if err := srv.setupHTTP2_Serve(); err != nil {
		return err
	}

	// ...省略

	var tempDelay time.Duration // how long to sleep on accept failure

	// 重点：下面开始无限循环监听
	ctx := context.WithValue(baseCtx, ServerContextKey, srv)
	for {
		rw, err := l.Accept()  // 等待从监听者处获取一个连接
		// 情况1: 获取连接失败
		if err != nil {
			select {
			case <-srv.getDoneChan():
				return ErrServerClosed
			default:
			}  // 如果是暂时性网络错误就沉睡一会儿
			if ne, ok := err.(net.Error); ok && ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay > max {
					tempDelay = max
				}
				srv.logf("http: Accept error: %v; retrying in %v", err, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return err  // 否则返回错误（并关闭服务）
		}
		// 情况2: 处理这个连接中的请求
		connCtx := ctx
		if cc := srv.ConnContext; cc != nil {
			connCtx = cc(connCtx, rw)
			if connCtx == nil {
				panic("ConnContext returned nil")
			}
		}
		tempDelay = 0
		c := srv.newConn(rw)
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve(connCtx)
	}
}
```

> 拓展阅读：http包中出现的`TLSNextProto`，是谷歌提出的、解决HTTP/2升级问题的协议。详情参考[谈谈 HTTP/2 的协议协商机制 - Jerry Qu](https://imququ.com/post/protocol-negotiation-in-http2.html)

上面的`Serve`方法在获取到连接后，首先会利用`context`将这个新的连接与服务引擎绑定成父子关系（如果不懂的话请查看我关于context的源码解析文章），这样在异常情况出现时可以优雅地结束掉所有的连接。

然后把连接封装成一个新的`conn`对象，将这个连接和当前的服务引擎的引用放在一起：

```go
func (srv *Server) newConn(rwc net.Conn) *conn {
	c := &conn{
		server: srv,
		rwc:    rwc,
	}
	if debugServerConnections {
		c.rwc = newLoggingConn("server", c.rwc)
	}
	return c
}
```

为什么要把引擎也挂进去？因为所有的业务逻辑都是挂在引擎的 Handler 上的啊。这样有了需要处理的连接、以及处理方法，在新的go程里就可以做所有需要它做的事情。

## 3. 处理请求

```go
// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
	// todo
}
```
