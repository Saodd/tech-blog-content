```json lw-blog-meta
{"title":"Gin 框架源代码速读","date":"2020-06-23","brev":"截止目前，在go的世界中，gin 应当算是最最流行的框架了。它简单、轻便，非常适合前后端分离的开发模式（即后端只负责数据交互，不负责渲染）。它的流行程度，从各大招聘平台的岗位描述上可见一斑。","tags":["Golang","坑","源码"]}
```



## 概况

开源在[Github](https://github.com/gin-gonic/gin)上。选用的是`MIT`开源许可，截止目前有 36.6k star、21 release、259 contributor、200+ open-issue、1300+ commit，使用了`go mod`并且最新版本已经迭代到了v1.6.2，设置了travis-CI，travis报告测试覆盖率98%。

gin文档中自称是高性能的web框架（我好像记得以前自称是『最快的web框架』）。但是就我个人从一些渠道的“榜单”上看到，好像gin并不经常上榜，可能有很多原因吧。具体有多快，我没有做过定量的测评，不过主观感觉上来说是很不错的。

这是一个非常丰富和全面的框架，所以我们顺着几个常用的方法向下挖掘。

## 1. 服务端应用的构建与启动

我们看一段最基本的启动代码：

```go
eng := gin.Default()
eng.Run()
```

其中`Default()`创建了一个默认配置的引擎，它配置了内置的Logger中间件和Recover中间件，以及打印出一些提示信息。

```go
// Default returns an Engine instance with the Logger and Recovery middleware already attached.
func Default() *Engine {
	debugPrintWARNINGDefault()
	engine := New()
	engine.Use(Logger(), Recovery())
	return engine
}
```

这里值得一提的是，这两个内置的中间件是可以配置的。`Logger`中间件可以配置 Formatter, io.Writer 和 SkipPaths（不打印日志的url路径）；`Recovery`中间件只能配置 io.Writer 。

然后是 `New()` 函数，创建了一个 `Engine`对象并做了一些初始化的操作。我们可以直接调用它，这样可以得到一个不带任何中间件的纯净引擎对象。（这里的 `Engine` 的概念与其他框架中的 `app` 的概念是相同的）

```go
func New() *Engine {
	engine := &Engine{
		RouterGroup: RouterGroup{
			Handlers: nil,
			basePath: "/",
			root:     true,
		},
		FuncMap:                template.FuncMap{},
		RedirectTrailingSlash:  true,
		RedirectFixedPath:      false,
		HandleMethodNotAllowed: false,
		ForwardedByClientIP:    true,
		AppEngine:              defaultAppEngine,
		UseRawPath:             false,
		RemoveExtraSlash:       false,
		UnescapePathValues:     true,
		MaxMultipartMemory:     defaultMultipartMemory,
		trees:                  make(methodTrees, 0, 9),
		delims:                 render.Delims{Left: "{{", Right: "}}"},
		secureJsonPrefix:       "while(1);",
	}
	engine.RouterGroup.engine = engine
	engine.pool.New = func() interface{} {
		return engine.allocateContext()
	}
	return engine
}
```

其中有两个比较扎眼的对象，RouterGroup 和 pool，这两个分别在注册路由和执行请求的时候会用到，我们后面分析。

得到引擎实例后，我们启动它：

```go
// 注释说：这个函数将路由加载到 http.Sever 上然后开始监听请求。可以认为它是一个快捷方式。
func (engine *Engine) Run(addr ...string) (err error) {
	address := resolveAddress(addr)
	err = http.ListenAndServe(address, engine)
	return
}
```

它这个快捷方式好像也就是处理了一下监听地址，我们看一下它做了什么事情：

```go
func resolveAddress(addr []string) string {
	switch len(addr) {
	case 0:
		if port := os.Getenv("PORT"); port != "" {
			debugPrint("Environment variable PORT=\"%s\"", port)
			return ":" + port
		}
		debugPrint("Environment variable PORT is undefined. Using port :8080 by default")
		return ":8080"
	case 1:
		return addr[0]
	default:
		panic("too many parameters")
	}
}
```

哦，原来是我们可以偷懒，在不输入监听地址的情况下，它会自行生成一个默认的地址和端口。

## 2. 监听请求：http & net 标准库

接上，我们的业务逻辑（`engine`）被传入了http标准库中执行：

```go
// 注释说：这个函数监听TCP，并对每个请求调用handler去处理。默认支持keep-alives.
func ListenAndServe(addr string, handler Handler) error {
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}

func (srv *Server) ListenAndServe() error {
	if srv.shuttingDown() {
		return ErrServerClosed
	}
	addr := srv.Addr
	if addr == "" {
		addr = ":http"
	}
	ln, err := net.Listen("tcp", addr)
	if err != nil {
		return err
	}
	return srv.Serve(ln)
}
```

在`Server.ListenAndServe()`方法中做了两步操作，一步是申请一个监听端口号（获得一个tcp文件描述符），然后就开始阻塞循环监听。

底层网络部分是使用了 `net` 标准库：

```go
func Listen(network, address string) (Listener, error) {
	var lc ListenConfig
	return lc.Listen(context.Background(), network, address)
}

func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) {
	addrs, err := DefaultResolver.resolveAddrList(ctx, "listen", network, address, nil)
	if err != nil {
		return nil, &OpError{Op: "listen", Net: network, Source: nil, Addr: nil, Err: err}
	}
	sl := &sysListener{
		ListenConfig: *lc,
		network:      network,
		address:      address,
	}
	var l Listener
	la := addrs.first(isIPv4)
	switch la := la.(type) {
	case *TCPAddr:
		l, err = sl.listenTCP(ctx, la)
	case *UnixAddr:
		l, err = sl.listenUnix(ctx, la)
	default:
		return nil, &OpError{Op: "listen", Net: sl.network, Source: nil, Addr: la, Err: &AddrError{Err: "unexpected address type", Addr: address}}
	}
	if err != nil {
		return nil, &OpError{Op: "listen", Net: sl.network, Source: nil, Addr: la, Err: err} // l is non-nil interface containing nil pointer
	}
	return l, nil
}
```

上面第一步`DefaultResolver.resolveAddrList`是将字符串类型的监听地址转化为结构化的监听地址，是个很常规的操作，或者说，这么晚才做这一步是让我有点意外。然后因为返回值是个列表，所以通过`la := addrs.first(isIPv4)`来取出第一项。

然后根据地址类型选择一个方式来执行，我们一般用的是`listenTCP`：

```go
// net/tcpsock_posix.go
func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) {
	fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, "listen", sl.ListenConfig.Control)
	if err != nil {
		return nil, err
	}
	return &TCPListener{fd: fd, lc: sl.ListenConfig}, nil
}

// net/ipsock_posix.go
func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
	if (runtime.GOOS == "aix" || runtime.GOOS == "windows" || runtime.GOOS == "openbsd") && mode == "dial" && raddr.isWildcard() {
		raddr = raddr.toLocal(net)
	}
	family, ipv6only := favoriteAddrFamily(net, laddr, raddr, mode)
	return socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)
}
```

到这里，我们从文件名中也可以看出，已经非常接近底层系统了。