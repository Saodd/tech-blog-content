```yaml lw-blog-meta
title: "[官方] Type Parameters - Draft Design"
date: "2020-09-26"
brev: "发布时间2020-09-21，当前最新的一版泛型设计稿。"
tags: [Golang]
```

# Type Parameters - Draft Design

[原文链接](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md)

Ian Lance Taylor  
Robert Griesemer  
September 21, 2020

## 摘要

我们建议给 「类型 type」和「函数声明 function declaration」 增加可选的「类型参数type parameters」。类型参数受限于「接口类型 interface types」——允许指定的一系列的类型作为参数传入。通过统一算法进行的「类型推断`Type inference`」允许在很多情况下从函数调用中省略类型参数。

这个设计向前兼容 Go 1 .

## 如何阅读这份设计稿

- 我们从一个非常简短的归纳开始。
- 然后详细介绍。
- 然后讨论实现，讨论问题，对比其他实现方式。
- 应用举例
- 一些次要的细节放在附录中

## 归纳

- 函数 可以通过一个中括号来额外指定类型参数(看起来就像普通的参数一样)： `func F[T any](p T) { ... }`
- 指定的类型参数可以用于参数列表，也可以用在函数体内。
- 类型 也可以指定参数列表： `type M[T any] []T`
- 每个类型参数都有一个「类型约束`type constraint`」，就像每个参数都有一个类型一样： `func F[T Constraint](p T) { ... }`
- 类型约束 是接口类型。
- 一个新的关键字 `any` 是一个允许任意类型的类型约束。
- 用作类型约束的接口类型，可以定义一系列的类型；只有类型符合其中一项的参数才满足类型约束要求。
- 泛型函数只能使用类型约束允许的操作。
- 使用泛型函数或者类型的时候，需要传入类型参数。
- 类型推断 允许在常见情况下省略函数调用的类型参数。

## 背景

此前我们有许多关于泛型的讨论。

这个设计稿建议，以添加一种形式的参数多态性的形式扩展Go语言。其中类型参数不是由声明的子类型关系(如某些面向对象语言)限制的，而是由显式定义的结构约束限制的。（译者注：很赞！我就喜欢这种把类型写死的感觉）

这个版本的设计稿很像 2019-7-31 提出的方案，但是从中去除了契约，用接口类型代替，并且语法也发生了改变。

这个版本不支持「模板编程`template metaprogramming`」或任何其他形式的编译时编程。

由于「泛型`generic`」这个术语已经被社区广泛地使用了，我们将它作为一个便捷的术语，来描述一个使用了类型参数的函数或者类型。请不要把 `generic` 这个词与其他语言（例如 C++ C# Java Rust 等）中的概念混为一谈，他们相似但是并不相等。

## 设计

### Type parameters 类型参数

在运行泛型代码时，`type parameter`会被转换为`type argument` （译者注：两个单词都是参数的意思，实在不知道怎么翻译……）

这里有一个函数，打印切片(数组)中的所有元素。切片元素的类型，`T`，是未知的。（译者注：现在可以通过`interface{}`来实现，但是这样的话允许范围太宽泛了），我们想要类似这样的实现：

```go
func Print(s []T) { // Just an example, not the suggested syntax.
	for _, v := range s {
		fmt.Println(v)
	}
}
```

那么问题来了，我们在哪里去声明这个`T`呢？毕竟在Go语言中，我们希望所有标识符都通过某种方式定义好。

因此我们做了一个决定：像定义参数一样，定义类型参数。当然，类型参数肯定不能跟普通参数一样，因此我们又做了一个决定：我们将类型参数的定义规定为可选的，并且用方括号包起来。

```go
func Print[T any](s []T) {
	// same as above
}
```

上面代码的意思是，在函数`Print`内，定义了`T`作为类型参数——在当前（函数声明时）未知类型但是在函数调用时明确。`any`代表着`T`可以使任意的类型。

与常规参数列表不同，类型参数列表中类型参数的名称是必需的。这避免了语法上的歧义，而且，如果出现这种情况，就没有理由忽略类型参数名称。

现在，由于`Print`函数声明了类型参数，因此在调用`Print`函数的时候也必须指定类型参数。稍后我们介绍通过类型推断来偷懒的方法，现在先看一下显式指定的情况：

```go
Print[int]([]int{1, 2, 3})
```

### Constraints 类型约束

接下来我们看一个稍微更复杂的例子。我们需要一个函数，逐个调用切片中所有元素的`String()`方法，将一个切片转化为一个字符串切片。我们预想中应该是这样的写法：

```go
// This function is INVALID.
func Stringify[T any](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String()) // INVALID
	}
	return ret
}
```

上面的代码会报错，因为`any`类型不一定有`String()`方法。

自然地，在其他编程语言中也会面临类似的问题。例如在 C++ 中，一个泛型函数（在C++中称为「函数模板`function template`」）可以调用一个泛型类型值（对象）的任意方法，如果该值（对象）没有这个方法，那么在编译时会抛出错误。但是这个错误可能会非常冗长，因为在一次错误的调用前面可能会有很多层级的模板调用。

C++ 的方法并不是 Go 的理想选择。因为在Go的世界里，我们不引用名称，我们不会傻傻地祈愿某个对象会有某个方法。当看到任意标识符时，Go将它们解析到它们的声明中。

总之，所有的泛型代码都应该要求类型参数满足某种要求。我们将此称为「类型约束`Constraint`」。

调用方只需要传入满足约束的类型参数；泛型函数本身只能按照约束所规定的方式去使用对参数进行操作 —— 这是Go的泛型实现中的重要规则：泛型代码只能使用类型参数已知的实现去进行操作（`generic code can only use operations that its type arguments are known to implement`）

### `any`类型 所允许的操作

参考前面的`Print`函数，对于一个`any`类型`T`，泛型函数可以执行的操作有：

- 声明一个该类型的变量
- 把另一个相同类型的值赋给该类型的变量
- 传递给另一个函数，或者从另一个函数取得返回值
- 取地址
- 转换到`interface{}`
- 把一个类型`T`的值转换为类型`T`（允许 但是废话）
- 使用类型断言，把一个接口值转化为该类型
- 在 type switch 中使用这个类型作为一个 case
- 定义并使用基于该类型的符合类型，例如该类型的切片
- 把该类型传递给一些内置函数，例如 new

以后可能会有增加吧，但现在已经想不到还有什么别的了。

### 定义约束

Go语言现在已经有一个非常接近类型约束所需的结构了 —— 接口类型。一个接口类型就是一些方法签名的集合，只有实现了接口所有方法的值才能传递给一个接口变量，并且，对这个接口变量所能做的操作也就只有接口定义的那些方法。

所以接口类型与参数约束看起来高度相似。

因此，在本次设计稿中，约束就是接口。（后面我们会介绍除了方法调用之外的操作，例如二进制操作符等操作）

对于前面的`Stringify`的例子，我们需要定义一个接口类型，带有`String()`方法：

```go
type Stringer interface {
	String() string
}
```

### `any`约束

既然约束是接口，那么`any`实际上也就等同于`interface{}`：

```go
func Print[T interface{}](s []T) {
	// same as above
}
```

因为写`interface{}`可能显得很烦，所以我们引入一个`any`关键字。它会被隐式地声明，并且只能用于参数约束中。

（当然，我们可以考虑将 `any` 作为 `interface{}` 的别名来处理。但是我们不希望我们关于泛型的设计稿里，有出现对语言其他方面的改动。因此这件事应该被另外讨论。）

### 使用约束

```go
func Stringify[T Stringer](s []T) (ret []string) {
	for _, v := range s {
		ret = append(ret, v.String())
	}
	return ret
}
```

### 多个类型参数

接下来我们写一个函数，它定义两个类型参数，功能是将两个切片数组逐项相加组成一个新的字符串数组：

```go
type Stringer interface {
	String() string
}
type Plusser interface {
	Plus(string) string
}

func ConcatTo[S Stringer, P Plusser](stringers []S, plussers []P) []string {
	r := make([]string, len(stringers))
	for i, s := range stringers {
		r[i] = plussers[i].Plus(s.String())
	}
	return r
}
```

### 泛型类型

我们不仅仅想要泛型函数，还想要泛型数据类型。

使用泛型类型时，我们需要提供类型参数，这个过程称为「实例化`instantiation`」。实例化后，我们对类型参数(parameter)的调用都会被替换成相应的类型参数(argument)。

比如像这样定义一个任意类型的数组：

```go
// Vector is a name for a slice of any element type.
type Vector[T any] []T

var v Vector[int]
```

泛型参数可以拥有自己的方法！方法的接收器必须声明相同数量的类型参数，注意仅仅是数量，无需任何约束。另外，也不需要相同的名字，如果没被用到，则用 `_` 代替。

```go
// Push adds a value to the end of a vector.
func (v *Vector[T]) Push(x T) { *v = append(*v, x) }
```

如果泛型类型引用它自己（例如链表节点），那么类型参数必须完全一致，包括顺序：

```go
// List is a linked list of values of type T.
type List[T any] struct {
	next *List[T] // this reference to List[T] is OK
	val  T
}

// This type is INVALID.
type P[T1, T2 any] struct {
	F *P[T2, T1] // INVALID; must be [T1, T2]
}
```

也包括隐式声明：

```go
// ListHead is the head of a linked list.
type ListHead[T any] struct {
	head *ListElement[T]
}

// ListElement is an element in a linked list with a head.
// Each element points back to the head.
type ListElement[T any] struct {
	next *ListElement[T]
	val  T
	head *ListHead[T]
}
```

（注：等我们更加了解人们希望如何写代码之后，我们也许有可能会解除这个规定。）

### 方法不能有额外的类型参数

虽然泛型类型的方法，可以使用泛型的类型参数，但是它们自己不能再添加额外的类型参数了。如果需要这么做，那可能要额外写一个专门的适配函数。

There is more discussion of this in [the issues section](https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md#No-parameterized-methods).

### 运算符

前面我们说的都是调用函数，但是我们也会需要运算符的支持，比如大于符号、等于符号等：

```go
// This function is INVALID.
func Smallest[T any](s []T) T {
	r := s[0] // panic if slice is empty
	for _, v := range s[1:] {
		if v < r { // INVALID
			r = v
		}
	}
	return r
}
```

在这里，类型参数`T`的约束是`any`，而`any`并没有声明对于`<`操作符的支持，因此上面这段代码是错误的。Go只有`int`和`float64`，以及底层是这两个类型的数据类型才支持`<`运算符。

因此，我们可以不用尝试让约束去声明支持的操作符，我们换个思路，让约束去指定允许的底层数据结构：

### 约束中的 类型 列表

我们用`type`关键字来显式地指定允许的数据结构：

```go
type SignedInteger interface {
	type int, int8, int16, int32, int64
}
```

只要所有声明的数据结构都支持某个操作符，那么就可以对这个泛型类型使用这个操作符。

对于上面的`Smallest()`泛型函数，我们可以定义如下的约束供使用，并且在实践中我们可能会将此类约束放在一个叫`constraints`的包中：

```go
package constraints

// Ordered is a type constraint that matches any ordered type.
// An ordered type is one that supports the <, <=, >, and >= operators.
type Ordered interface {
	type int, int8, int16, int32, int64,
		uint, uint8, uint16, uint32, uint64, uintptr,
		float32, float64,
		string
}
```

### 约束中的 可比较类型

我们为可比较类型也保留了一个关键字`comparable`，这个约束将允许使用`==`和`!=`运算符，例如：

```go
// Index returns the index of x in s, or -1 if not found.
func Index[T comparable](s []T, x T) int {
	for i, v := range s {
		if v == x {
			return i
		}
	}
	return -1
}
```

和其他约束一样，也可以嵌入其他约束中。（译者注：但有点可惜的是，我们并不能像Python那样定义一个方法来实现比较运算；我们依然只能够使用可比较的内置类型）

有个比较tricky的情况是，我们可以把两个矛盾的约束放在一起，做出一个没有任何类型能符合要求的约束：

```go
// ImpossibleConstraint is a type constraint that no type can satisfy,
// because slice types are not comparable.
type ImpossibleConstraint interface {
	comparable
	type []int
}
```

### 接口类型中的 类型列表

带有类型列表的接口类型应当只用作约束，而不该用在传统的接口上。

这个限制也许会在以后放开，因为它可能会在当做综合类型(`sum type`)的时候派上用场。

（未完待续 https://go.googlesource.com/proposal/+/refs/heads/master/design/go2draft-type-parameters.md#mutually-referencing-type-parameters ）
