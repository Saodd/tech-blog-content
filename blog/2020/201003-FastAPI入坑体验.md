```json lw-blog-meta
{"title":"FastAPI 入坑体验","date":"2020-10-03","brev":"FastAPI 是 Python 世界中的一个年轻的web框架。基于 Pydantic，在类型方面做了很大的努力。","tags":["Python","TODO"],"path":"blog/2020/201003-FastAPI入坑体验.md"}
```


## 前言

前阵子跟老板聊到一些技术上的事情，当说到"就像Django和Flask的选择那样，我宁愿选个轻的"时，老板给我安利了 FastAPI 。

这玩意我在更早之前也有简单地了解过，主要特性无非就是提供了类型的封装，以及可以从代码中生成API文档，这两点特色。但是，当时考虑到我们项目的历史包袱（2020年了还在用Python2）我觉得这玩意并不太可能在我们的项目中有什么产出，而且我个人觉得在Python中强调类型真的是个挺蠢的事情，所以，一直懒得去看。

不过，有时间了还是来看一眼吧。

## 概况

开源在[Github](https://github.com/tiangolo/fastapi)上。选用的是`MIT`开源许可，截止目前有 21.5k star、1400+issues。

文档中第一句话自称高性能，还说能把 Node.js 和 Go 比下去。

[中文文档地址](https://fastapi.tiangolo.com/zh/), 翻译得还凑合，应该是社区有中国人专门给翻译的。但是除了翻译准确性之外的其他一些细节还是处理得不太好。因此建议有能力的同学直接阅读英文文档。

## 优点

### 干净的依赖

与想象中完全不同，安装过程非常顺利。

FastAPI 的默认依赖只有两项—— Pydantic 和 starlette 。这点倒是让我挺有好感的。

### 交互式 API 文档

能够自动根据代码（路由和类型等）来生成文档，这的确是个很厉害的东西。

稍微看了下，前端页面是用的js的开源项目，`Swagger`或者`ReDoc`，通过免费cdn来进行提供，免去了本地的渲染和代码体积。文档内容是`OpenAPI`标准内容。这很符合前后端分离的设计原则。

但是呢，也就仅限于查阅文档还算方便。如果想直接在上面调试API，目前看来还是远远不够方便。

另外，两个文档框架都有一些缺陷。

### 路由风格

与 Flask 不同， FastAPI 还是选择了类似 Gin 的风格——把HTTP方法作为路由注册时的函数名称：

```python
# Flask 风格
@app.route("/", methods=["GET"])

# FastAPI 风格
@app.get("/")
```

```go
// gin 风格
app.get("/", Func1)
```

毫无疑问，这种选择是更加前卫的。

### 数据来源

FastAPI 在这里选择了一种较为混沌的方式——把 query, params 和 requestBody 混合在一起，统一通过函数参数的形式传入。

不过，通过`Query`, `Path`, `Body`等来定义类型，还是可以指定数据来源。

此外，同时提供了 Form 和 Json 的支持，相比于 Flask 的 WTF，是一个很大的进步。

### 多种数据模型

可以分别为传入、传出、数据库、甚至更多情况分别定义数据模型，FastAPI （或者说，Pydantic）能够以较好的方式去处理和过滤。

### 异常处理

是与 Flask 相同的，把异常类型注册的方式。

### 最佳实践

文档中对于代码组织的最佳实践也有介绍。这个东西其实很重要，但是很容易被忽略。

### 中间件

使用`call_next`的设计，类似于 Gin。

## 缺点

### 周边资料太少

尝试搜索了一些很常见的功能的最佳实践，结果很少很少。到头来还是要自己想办法解决，但是自己的办法就未必是最佳的了。

### 变量名称的限制

HTTP 数据中大量的是字符串，转换成 Python 变量名时会遭遇问题：比如`-`连字符，比如大小写问题。

FastAPI 会自动将`-`转换为`_`，将首字母大写转换为全小写。也可以自己定义名称。

咋一看是挺好的，但是，当项目越来越大，需要靠全局查找的时候，这个特性肯定要造成麻烦。

### 请求体数据是否可以允许直接平铺？

当从请求体中只解析一个模型时，FastAPI允许（且必须）将该模型的各个字段平铺在请求体中。例如，对于如下代码：

```python
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

我们只能平铺（内联）字段，而不能将内嵌：

```text
# 这个请求体有效：
{
    "name": "Foo",
    "price": 42.0,
}
# 这个请求体无效：
{
    "item": {
        "name": "Foo",
        "price": 42.0,
    }
}
```

乍看起来好像合理，但是，如果不改变当前的`item`模型，同时再增加另一个模型`user`，那么这个时候行为就不同了：

```python
@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item, user: User):  # 增加一个User模型
    results = {"item_id": item_id, "item": item, "user": user}
    return results
```

那么就必须要将两个模型都用他们各自的名字包裹起来：

```text
{
    "item": {
        "name": "Foo",
        "price": 42.0,
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    }
}
```

所以，问题就在于，我只是增加了一个字段，却影响到了另一个字段。这种设计我觉得是不合理的。

强制指定模型必须内嵌的方式是`Body(..., embed=True)`。但我觉得内嵌才应该是默认行为，平铺才应该显式指定（参考`mongo-go-driver`中的`inline`标签的设计思想）。

还有一个问题，我只是指定了一个`Pydantic`的数据模型，它默认从请求体中获取数据；类似的，如果指定为普通的Python内置类型，就会默认从请求参数中获取数据。

这种默认行为都是看起来便利，其实严重地破坏了设计思路的规范性。

### 使用了太多最新特性

Pydantic 以及 FastAPI 这两个库，使用了太多 Python 语言的最新特性语法，例如 `...`, `*` 等等。

还有默认支持`async/await`协程。如果要利用这个特性的话，那所有涉及到IO的第三方库（包括不限于数据库、request等）全部都要换成协程版本的，这一点对于传统多线程Flask用户来说，代价非常大，因此几乎不可能实现转型。

是好事，也是坏事。仁者见仁吧。

### 便利与规范的取舍

FastAPI 有很多为了便利而破坏规范的设计。

## 其他槽点

1. 文档讲的太过于基础了……让我感觉有不少人生被浪费了。
2. 版本号`0.61.1`看着就不是很舒服。

## 总结

FastAPI 提供了一种非常便捷的，通过代码直接生成文档的能力；同时，引入了大量的Python的最新特性和REST设计理念。学会使用它，对于还在使用 Flask, Django 等传统框架的开发者来说，是一个非常好的"与时俱进"的机会。

其实厚脸皮地说一句。在正式学习 FastAPI 之前，我有尝试在 Flask 的体系下搭建一套类似于 Gin 的静态类型+REST风格的接口框架；现在看来，我的很多观念都与 FastAPI 不谋而合。所以最后，总体来说，我对这个新框架还是认可的。

不过最尴尬的还是"在动态类型语言中规定静态类型"这件事，虽然是好事，可是我觉得这是对Python拥簇者的嘲讽吧哈哈哈。

那么问题来了，静态类型语言，例如 Go ，能不能实现这一套生成文档的能力呢？理论上当然是可以的，看看隔壁 Java 就在这方面走得很远了。虽然 Go 没有像 Python 那么多魔法方法（Python一切皆对象，Go一切皆是值）。但其实，无非就是在注册路由的时候传入类型和注释罢了，Go有反射可以读取类型，所以技术上的障碍应该是不存在的。

总之，在 Python 的世界中，FastAPI 这个框架是足够让我满意了。
