


# 『知乎用户』的回答

> 作者：知乎用户  
> 链接：https://www.zhihu.com/question/383079175/answer/1109655276  
> 来源：知乎  
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。  
> 注：下面内容中注释部分为本人个人感悟。

最近 CodeReview（以下简称CR ）心态相当的平和，代码是一个讲道理的东西，是就是，否就否。
在 CR 时，沟通特别轻松，问题讨论也特别聚焦，因为它是量化和定向的。
CR 的过程不是恃强凌弱，也不是一言堂，大家看着代码，当作是一种灵魂的交流，那么每一次的 CR 也是同事间提升和谐度的一种方式。
优良的 CR 传统可以体现团队温度，体现高年级同学传帮带的技术文化。
平时，大家抬头看 PRD ，低头写代码，很少有时间静心气闲地交流一下业务流程、业务逻辑、业务未来扩展，在 CR 时，往往可以反复被讨论到。
一个人的能力不是体现在解决了问题上，也不是发现了问题，而是利用某种手段预知问题并解决问题。
曾经有段代码，我觉得取反逻辑生涩难懂，反复修改之后，发现写代码的小伙伴是错误领会了业务意图。  

提升技术质量、促进人才成长、培养技术情怀这些口号我们今天先放一边，聊聊最近CR的切身体会。
CR 不是互相看天书，而是产生天天看书的感觉，每一段写得好，写得不好的代码都是一本书，好的代码希望见贤思齐，差的代码希望见不贤而内自省也。
总之， CR 是一种修行，也是一种自我积累，苦涩的是看到惨不忍堵的代码，心里说：我去！有意思的是看到优雅的代码，心里也说：我去！

> 非常赞同『CR是灵魂的交流』这个观点。在实际工作中，语言的表达力是有限的，口头说得再多，都要靠最后写出来的代码才能确定双方的真正思想。
为什么这个判断这样写？为什么这个异常不用处理？为什么要加额外的校验？这些代码上的逻辑，其实都真实反映着开发人员对于业务需求和语言特性的理解。
基于代码的讨论是非常高效的，而且往往能让双方都有收获。

## 业务跑得这么快，没时间 Code Review

这是一个很大的谎言，不要为自己的丑代码找华丽的借口，没有时间好好 CR ，总有时间焦头烂额地处理故障和投诉。
时间老人是公平的，我一直认为某个同学在工位上噼里啪啦打字，就是说明他干活快，通过团队打字比赛，发现其中 20% 在按 BACKSPACE 键。
业务跑得快，代码写得快，可能写的是一堆没有营养甚至是有毒的代码。我们需要追求的是 CR 的效能，而不是逃避 CR 。
CR 是一种修行，对于双方都是一样的收获，因为如果想象成一个摊派任务，抵触情绪总会油然而生。
业务跑得快，也得两腿是健康的， CR 就是保证业务持续跑的快的一个小医生，不正常的业务节奏对公司的中长远发展肯定是弊大于利。

> 其实除了CR之外，测试也是同理。没时间做这些健康性的东西，那就要做好为故障买单的准备。  
> 我的上家，旧系统是从一个外包团队处得来的，代码逻辑一团糟，bug满天飞，举个例子，https证书都没有做，前后端通过http明文通信；就这样的系统，还要着急投入上线，运行着相当数量的资金。虽然正常运行时能赚些钱，但是隔三差五出故障造成资金损失。这样真的值得吗？我认为不值得。因为赚钱是有限的，亏钱可以是无限的。

## 代码是讲道理的

我认为靠烧香来保佑代码不出问题时，保平安往往也是暂时的。优秀的代码，就是在小流量、单线程没有问题，在高流量、高并发时还是没有问题，你的限流，你的容灾，你的降级各种导弹防御系统一样自动打开并正确地发挥价值。很多人的思维觉得，代码只要在当前场景和逻辑上没有问题就行，那是因为夜路走得不够多，还没有碰到鬼。代码是讲道理的，就像有一个同学说>=比>更加慢，那只是我们的潜意识猜测，经过深达编译层的分析，发现两个指令几乎是完全一样。其实凭我们的想象，那也是一个位运算级别的操作，从左向右比，如果一处有 1 ，另一个没有 1 ，那么前者一定是更大。没有无缘无故的爱，没有无缘无故的恨，一切的故障总是代码的字里行间。我们需要做的，就是读懂她，用好她，写好她。如果代码任性闯祸，只能是我们不懂代码的心思。

> 关于这一点我恐怕无法完全认同。因为有另一种观点叫做『不成熟的优化往往是工程的灾难』。任何工程都应当有设计运行状态，比如如果只是想在单机上运行个人博客，就完全没必要考虑高并发大流量的极端情况。在前期开发阶段，应该更注重功能的实现，只要做好模块之间的隔离（比如典型的微服务，或者接口设计等概念）便于后期重构即可。  
> 当然，以上观点是从公司角度出发的。作为一个有追求的技术人员，我当然是希望自己写的每段代码都完美无缺，哪怕加班也在所不惜。

## 每一行代码的存在是有意义的

更加严格地说，每一个字符的存在都应该是有意义的。如果某行代码的存在完全是可有可无的，这个时候，我们考虑过 JVM 的感受吗？凭白无故地要编译这些字节码，然后栈进栈出的忙活一阵子，然后告诉它，你的劳动是没有任何价值的。比如，Boolean assetFlag = Boolean.true ; 这里都已经明确地给给出来显示的初始值，可是在调用端，居然还有这样的判断：if ( assetFlag != null && assetFlag == true) {...}，什么情况下为 null 值啊？另外参数在框架里已经做了值的判断，那么下边又是 n 行，对所有参数重新判断一遍，是对我们的代码有多少不自信，还是对框架不自信？每一行的代码，相当于生命，它的存在一定是有意义的，一定是能够被执行到并且能够为实际的业务负责的。

> 关于代码意义这个问题，其实不同语言之间的表现也会不同。以我掌握的python和go为例，go语言是非常严谨的静态类型语言，因此 IDE 可以在大部分场景下发现你的多余代码；而python作为动态类型的语言，这方面的提示能做到的就十分有限了，更多的要靠开发人员自己的经验和意识。

## 我们比拼的不是代码行数

在 Code Review 过程中，发现有些方法，重复用到一段逻辑，这段逻辑如果不抽取出来成为一个方法，未来的修改就成了一个必须多点全部修改的大坑，稍有不慎，容易遗漏。重复代码在提交行数上，似乎挺壮观的。如果在同样的效果上， 3 行代码能够实现功能的价值，就不应该用 4 行来实现。我们经常说晒出代码行数，并非是单纯地鼓励代码行数多，而是提倡大家去写代码，写优质的代码，优质的代码一定是少即是多的原则。代码的实现，不要像鲁迅先生说的一样：懒婆娘的裹脚布又臭又长。

> 把复用的代码抽象出来做成通用函数，这个做法当然是极好的。但是这个做法没有短期效益，而且可能引入新的bug，因此一定要有领导的支持以及充分的测试，才好去做这样的事情。

## 用户视角的成功与失败用户视角的成功与失败

在交付时，调用服务失败，然后返回前台一个空列表，那么前端业务的展示是后台数据正常，这个人不拥有数据列表，这明明是对数据的一种曲解。所以，后台调用服务失败，就应该明确告诉前台，服务出错了，这个用户有没有数据。系统出错的信息给用户看，合适吗？不合适。前后端的用户交界面上，往往飞着两类信息：错误码、错误信息。这样够了吗？用户提示需要额外地再给出来，往往根据不同的错误码，有不同的用户提示，可能是一个多对多的关系。多个错误码，提示给用户的信息：请输入必填项。多个用户信息，可能也对应一个错误码。一般来说后台承包这三者的联动关系， json 串推送给前端时，前端拿来主义即可。

> 这其实是通信规范的问题，只要按照REST等规范来进行设计，一般不会出现这样的错误。  
> 关于错误码，我个人的实践也是在后端做好。比如用 gin 框架，在 Handler 中调用业务模块，要对业务模块返回的 error 进行分析，然后返回对应的 HttpCode 和 ErrMsg （不能直接返回`err.Error()`，因为可能会附带后端的 recover 信息）。前端就直接用`resp.data.error||'请求错误'`来展示，不在前端做额外的判断。

## 有重复使用的量一定要找个地方集中隔离

不管是变量，还是常量，工具类，如果是多个地方同时用到，那么如果硬编码在代码或者沉淀在包里，未来一定是一个灾难。比如，一个组装 SQL 语句的代码，到处都是 "from" "where" "limit" ，都是这类语句直接写死在代码中，注意问题来了，这些单词前后都需要加空格。有时候在复制粘粘时，发现少了一个空格，出现的问题，往往是致命的。再比如，一个互相约定的分隔符 “###” ，定义在本类中 private String ，这明显是两个共同遵守的常量，单独定义的结果就是容易造成不匹配。隔离的目的是复用它，保护程序地正常运行，易于维护。

> 我习惯把复用的变量或常量提取出来，放在`utils`, `config` 或者`common.go`这样的地方。

## 单测没必要代码 Code Review

单测有时候感觉像是阑尾，有或没有感觉都是无关紧急，这是错误的观点。单测感觉就是一个任务。你写单测了吗？写了。单测是否需要 MOCK ，是否进行边界值测试，是否用例覆盖到业务场景，这都也是 CR 的一部分。单测写得好， BUG 肯定少。

> 单测代码主要关注两方面，一方面是覆盖率硬指标，另一方面是逻辑和场景的覆盖度，后者更需要经验丰富的员工或者领导来审核。

## 需要调试来查找错误时，往往是一种对异常处理机制的侮辱

良好的日志和异常机制，是不应该出现调试的。打日志和抛异常，一定要把上下文给出来，否则，等于在破坏命案现场，把后边处理问题的人，往歪路上带。别人传一个参数进来，发现是 null ，立马抛出来一个参数异常提示，然后也不返回哪一个参数是 null ，这在调用参数很多的情况下，简直就是字谜游戏一样。到底是抛异常，还是抛错误码？我不管抛什么，反正错了什么东西，都应该透明出来。到底是抛受检异常，还是非受检异常，我只想说，没有充足的理由，不要乱抛受检异常。异常抛出时，一定要自己消化干净，告诉别人说我的方法签名抛的是 AbcException ，实际运行中，代码某个地方直接抛出 EfgException ，这也是不负责任的。

> 关于异常和日志我暂时没有很多实践教训。目前在go开发中我遵守一个原则：一个函数签名如果不返回error，那么出现error时一定要充分的打印到日志；如果返回error，那么所有的error都向上返回，不打印任何日志。然后可能出现的error类型尽量在函数注释中列举或者说明。  
至于“抛异常”(`panic`或者`raise`)，我个人不太喜欢这种方式。因为从python转到go，我深深的爱上了go这种“返回异常”的方式，它更利于写出健壮的代码。如果只是简单的“抛出异常”然后等上层来recover，就会出现上层总是出现莫名其妙的异常的情况（即无法确定哪里可能会冒出异常）。

## 多个 return 的语句，概率高的一定先进行判定

if(condition1) return; if(condition2) return; if(condition3) return ; 那么需要评估一下 condition1/2/3 出现概率的大小，概念大的在最前边，尽可能快地进行 return ，不需要进行后续无谓的匹配。不要总觉得计算机跑得快，不差这点蝇头小利的，这种思维，和《南辕北辙》里的寓义一样的吗？

> 这个细节我一直有注意，我还担心是不是我个人太多虑了呢。同理的情况还有`boolA && boolB && boolC`这种。

## 吝啬空行

感觉空行是廉价的，到处乱扔是一种；另一种是感觉空行是昂贵的，舍不得用，这种情况更多见。50 行代码没有一个空行，就像英语 50 句话，没有任何标点符号一样。既然标点符号起到隔断和语义区分作用，我们的空行不是同一个道理吗？在以下情形：1、在方法的 return、break、continue、这样断开性语句后必须是空行。2、在不同语义块之间。3、循环之前和之后一般有空行。另外，方法和类定义下方就不需要空行了吧。

> 我一般在语义块之间保留空行。例如一个函数可能有判断参数、组装请求、执行请求与分析结果四个语义块，那么在每块之间都保留注释和空行。

## 命名太随意

代码有两件事情比较头疼：命名和循环。人如其名，如果不是它干的活，名字却是一副道貌岸然，太容易把人带偏了，一个中国人如果取名叫赵C，一个女孩子如果取名叫石敢当，第一印象生生地给扭曲了。英语不好的同学，要么用错英文单词，要么翻词典，整出一个专八的词汇，任何人都不认得这个单词，在 CR 时，还需要打开在线翻译时的命名，绝对不是好命名。当然如果在线翻译都翻不出来的时候，那更头疼。如果表意错误，那更要命。

> 命名其实是一个很重要的事情。不管是产品还是代码，起一个好名字就等于成功了一半。之前不记得在哪里看到一种命名规范：名称应当由动词+形容词+名词的形式来组成，我觉得这个是比较有效而且通用的。至于具体的细节就要看语言特性和团队习惯了吧。

## 注释是电影的旁白

电影的旁白：1）信息量大。2）适时出现。就像 star war 里，开始的一段一样，如果不交代那些背景，可能进入正片是一脸懵逼的。在代码上不需要写正确的废话，名字取得好，自然是自解释的。在嵌套循环中，或者在复杂条件分支中，往往是需要讲明白的。另外，添加业务背景信息，以及执行频率，执行条件，甚至维护者注意点，都是注释的重要理由。识别到哪里要写注释，也是一个对业务的阅读能力，而不是代码阅读能力。

> 一开始我也写很多注释，后来回头看这些注释，其实有很多都是多余的。不记得在哪里看到一个注释规范：只在注释中写 WHY ，用代码本身来表达 HOW 和 WHAT。例如，结构体的注释我会写它应当用于什么地方，或者如果是反序列化的结构体我会写上它原来json字符串长什么样子；一个函数我会写为什么用了这种思路而不是另一种。

## 满天飞的函数式编程好吗？

不好。如果一个 stream 后边的调用超过 5 个，我觉得你是为了炫耀，因为别人不敢改这段代码，体现出来你的不可替代性。这种 10 行都是函数式编程的方式，就像让人在水里憋气超过 10 分钟不能换气一样难受，有点缺氧的感觉。

> 其实对象式编程也同样有这个问题。继承级数太多，就会难以追踪到底调用的是哪个父类的方法，同样有缺氧的感觉。如果不得不实现超长的调用链的话，那么一定要在语义、命名、注释等方面做好解释。