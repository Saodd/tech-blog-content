```json lw-blog-meta
{"title":"OS学习笔记52：虚拟机","date":"2019-09-16","brev":"虚拟机，就是在OS下面再抽象一层；这样就可以运行多个OS了。","tags":["OS"],"path":"blog/2019/190916-OS学习笔记52.md"}
```



# 第五二章 <A Dialogue on Virtual Machine Monitors>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-vmm.pdf)

接下来讲一下`虚拟机监视器virtual machine monitors`，也称`hypervisors`。

比如我们常见的VMware，我们来讲一下它是如何在OS以上又增加一层虚拟化。学习这个，可以让你对虚拟化的理解更加深刻。

# 第五三章 <Virtual Machine Monitors>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/vmm-intro.pdf)

## 53.1 介绍

很多年前，IBM生产昂贵的大型主机时，有了一个问题：如果企业想要在同一台机器上运行多个系统怎么办？因此引入了虚拟机的概念。

详细说，虚拟机管理程序`VMM`给多个OS提供一种控制整个机器的假象。实际上，VMM本身就是一种OS，不过它是底层版本的OS，因此它要实现透明性。

**关键问题：如何在OS的下层将机器进行虚拟化？**

## 53.2 动机：为什么是VMM

如今，VMM是正流行的。

首先一个理由是服务器合并。在很多场景下，人们在不同的机器、不同的OS上运行不同的服务，因此每台机器的负荷是很小的。因此可以把多个OS合并在一个机器上。

另一个常见用法是个人电脑，人们可以同时运行Linux和Windows。

还有一个用途是测试与debug。当程序员编写了某个平台上的程序，他们会需要在其他平台上做兼容性测试。

## 53.3 虚拟化CPU

在VMM上面运行虚拟机，最基本的技术就是前面所学的`limited direct execution`。其实就与OS向应用程序提供虚拟化是一样的。

当我们需要“启动”一个虚拟机时，我们只需要跳转到第一条指令的地址（开机时的指令），然后让它运行下去就可以了。

与『进程上下文切换』类似，VMM要实现『虚拟机上下文切换』。其实也就是保存寄存器之类的数据，然后调取另一个虚拟机的上下文。

我们讲一个例子，比如要进行一个特权操作（内核态操作）。现在的步骤是：虚拟机应用->VMM态，在VMM中才能执行特权操作。应用发起systemcall，但是被VMM捕获到了；而VMM不知道如何处理这个systemcall，它只知道是从哪个虚拟机发起的（因为虚拟机在启动时，将陷阱处理程序注册了），因此要回到虚拟机中；虚拟机内核执行完了之后，又会回到VMM的控制，再返回应用程序。

![Figure 50.2](https://saodd.github.io/tech-blog-pic/2019/2019-09-16-Fig-50-2.png)

可以看到在systemcall时有了额外的步骤，因此虚拟机会降低性能。

另外还要注意，虚拟机的OS运行在什么模态下？肯定不能是内核态，应该是介于内核态和用户态之间的一个状态。

在MIPS指令集中，引入了一个`监督模态supervisor mode`。运行在监督模态下，并不能真正执行特权指令，但是可以接触比用户态更多一些的内存，这些内存用于保存OS内核数据。在不支持监督模态的硬件上，OS只能运行在用户态中，不过可以通过内存保护（比如页面控制）来管理内核数据。

## 53.4 虚拟化内存

回忆一下前面所学，在实体系统中，OS将线性的物理内存虚拟化，通过页码表来映射。应用程序分配虚拟地址，然后通过OS来翻译为物理地址。

那么现在再加一层虚拟机，也是在陷阱指令上做手脚：多映射一层就可以了。

![Figure 50.4](https://saodd.github.io/tech-blog-pic/2019/2019-09-16-Fig-50-4.png)

![Figure 50.5](https://saodd.github.io/tech-blog-pic/2019/2019-09-16-Fig-50-5.png)

同样，这样的额外虚拟层也会让页面翻译的性能下降。为了减轻这种影响，VMM给虚拟机内核实现软件管理的TLB页码表。

## 53.5 信息隔断

正如OS不知道应用程序在做什么，VMM也不知道虚拟机OS在做什么。比如某个OS正在运行一个空循环的进程。

因此VMM最好需要一些手段。比如监测虚拟机的运行状态，或者运行`准虚拟化para-virtualized`系统。

## 53.6 小结

VMM向虚拟机提供的虚拟化，其实与OS向进程提供的虚拟化是非常相似的。不过关键的一点就是，增加一层抽象，就损失了一层性能。

## 我的小结

虚拟机的确提供了一种强大的虚拟化。但是目前更加先进的应该是另一种：容器化技术（代表产品`Docker`）。

VM的本质是在VMM址上构建多个OS内核，而容器的本质是所有容器共享宿主内核。两种方式提供的虚拟化程度不同，性能损耗也不同。

虚拟机可以提供一种真实的、干净的系统，不同OS之间互不影响。而容器之间的影响还是有一些的（特别是在计算机管理员的角度），但是对于多数情况来说，使用容器化就可以了。

挺遗憾这本书没有介绍Docker相关的技术，不过这本书已经将得很好了，无可挑剔。
