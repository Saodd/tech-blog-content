```yaml lw-blog-meta
title: OS学习笔记44：持久化：基于闪存的固态硬盘
date: "2019-09-05"
brev: 固态硬盘目前有两种介质，flash和DRAM。简单介绍一下它的原理、特征和使用场景。
tags: [OS]
```


# 第四四章 <Flash-based SSDs>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/file-ssd.pdf)

`固态硬盘solid-state storage`是一种新的持久化存储设备。它没有机械装置，而是使用晶体管来构建的，更像内存的样子。

我们这里说`闪存flash`。它有一些特性，比如，如果要写入指定的区域，你可能要先擦除一个更大的区域；还有，写入寿命也有限制。

**关键问题：如何用闪存来构建固态硬盘？如何控制昂贵的擦除操作？如何延长写入寿命？发展前景如何？**

## 44.1 储存一个bit

闪存芯片是在晶体管上储存一些位数据，晶体管内部的电荷水平被映射成一个二进制值。在`单层单元single-level cell (SLC)`中，只有0/1所以只能存1位；在`多层单元multi-level cell (MLC)`中可以保存2位；还有`三层单元triple-level cell (TLC)`。其中SLC是性能最好，也是最贵的。

## 44.2 将bit转换为bank

文件系统并不会直接处理bit，所以闪存芯片被组织成`bank`或者叫`palne`，应该翻译为存储单元。

bank有两种操作尺度，一种是`块block`，一般128/256KB；另一种是`页page`，一般4KB。在每个bank中有很多block，每个block有很多page。

下图展示了一个bank的例子，它含有3个block，12个page：

![Figure 44.1](https://raw.githubusercontent.com/Saodd/Saodd.github.io.backup-Jun2020/master/static/blog/2019-09-05-Fig-44-1.png)

有个很重要的特性是，如果你要写一个page，那么你必须擦除整个block。因此如何安排写入操作是非常有挑战的。

## 44.3 闪存的基本操作

- `Read`：读一个page，只需要页面编号就可以了，速度非常快（大约10us）而且不需要定位时间。
- `Erase`：擦除一个blcok。擦除就是将其中所有值设为1，大概需要几毫秒。完成后，其中的每个page都可以被programmed。
- `Program`：写入一个page。其实就是将一部分1设置为0，大概需要100us。

可以想象每个page有一个状态位，来表示当前的状态：

```text
                iiii    Initial: pages in block are invalid (i)
Erase()     →   EEEE    State of pages in block set to erased (E)
Program(0)  →   VEEE    Program page 0; state set to valid (V)
Program(0)  →   error   Cannot re-program page after programming
Program(1)  →   VVEE    Program page 1
Erase()     →   EEEE    Contents erased; all pages programmable
```

## 44.4 闪存的性能与可靠性

![Figure 44.2](https://raw.githubusercontent.com/Saodd/Saodd.github.io.backup-Jun2020/master/static/blog/2019-09-05-Fig-44-2.png)

各种单元的原生速度如上图所示。

那它的可靠性如何？固态硬盘与机械硬盘不同，它是纯电子的，因此故障要少很多。

首要问题是`磨损wear out`，在擦除和写入的过程中，单元会逐渐积累额外的电荷；积累到一定程度，就无法区分0/1了，此时这个单元就不可用了。
典型的寿命暂时没有完全清楚。MLC一般是10K次擦写，SLC一般是100K次擦写。而且最近的研究表明，实际寿命比理论估计的更长。

另一个问题是`干扰disturbance`，当访问特定的page的时候，可能会有个别bit在相邻的page上翻转，这种问题会发生在读和写的过程中。

## 44.5 把闪存组装成固态硬盘

为了遵循标准接口，固态硬盘也要提供512bytes的区块尺寸操作接口。

在固态硬盘的内部，有闪存芯片群，还有一些内存（比如SRAM，用于缓存等目的），还有一些逻辑控制模块。

逻辑控制模块的功能就是满足客户端的读写需求，我们称其为`闪存翻译层flash translation layer (FTL)`.TFL接受（客户端发来的）逻辑区块请求，并将其转化为对底层的物理block/page的操作。

![Figure 44.3](https://raw.githubusercontent.com/Saodd/Saodd.github.io.backup-Jun2020/master/static/blog/2019-09-05-Fig-44-3.png)

为了达到极高的性能，首先要做的就是`并行parallel`，事实上现代的固态硬盘都有多个芯片并行操作。

另一个目标就是减少`写入放大write amplification`，即避免额外的擦除。还要尽可能地将擦写平摊到所有的单元上，使得所有单元能在大致相当的时间内耗尽寿命，我们称为`磨损平衡wear leveling`。

还有一个目标是减少干扰。做法就是只在擦除过的block上，按顺序地写入page。

## 44.6 FTL组织：坏的方案

最简单的办法就是`直接映射direct mapped`，即直接将逻辑地址映射到物理地址上。

这种方案，性能低下不说，最大的麻烦是会导致快速的局部磨损。

## 44.7 日志结构的FTL

还记得上一章介绍的LFS（日志结构文件系统）吗？主要思路是从不在已有数据块上更新，而是写在空闲的区域中。这种思路不仅可以用在文件系统中，也非常适用于固态硬盘的逻辑控制模块。

那么问题来了，如何保存节点地图？简单的办事是保存在一个`带外out-of-band (OOB)`区域，然后在设备每次启动时，扫描整个硬盘来将所有的节点地图加载到内存中。当然还有一些更高端的方法，使用了更加复杂的日志和关卡技术。

## 44.8 垃圾回收

FTL的一个问题就是垃圾回收。

在固态硬盘中使用完全一致的思路：先将范围定位在某些block上，扫描其中的死亡区块（这是指文件系统中的区块概念，可能对应于page，而不是对应于block），然后把存活的区块重新以日志的形式写到别处去，接下来就把整个block擦除，也就是释放掉了。

为了减少垃圾回收对于性能的影响，一些固态硬盘选择增大内存容量，以此减少频率并允许后台执行垃圾回收。

## 44.9 节点地图的尺寸

如果像之前章节介绍的那样，对每个page都保留一个指针，比如每个指针4byte指向每个page-4KB，那么1TB的硬盘就需要1GB的空间来储存这些指针。

### 基于block的映射

但是这种方法对于小文件的写入很不友好，而小文件正是我们文件系统中的主要成分。

### 混合映射

### page映射加上缓存

## 44.10 磨损平衡

LFS日志文件系统就能够提供良好的平衡性。

有一个小问题是，对于一些长期不变的数据块，固态硬盘也要时不时地给它们移动一下位置。但是这也引入了额外的工作量。目前有多种算法在试图优化这个过程。

## 44.11 性能与成本的考量

我们拿SSD与传统的机械硬盘HDD进行对比。

### 性能

SSD最大的不同就是没有机械部件，因此没有定位时间。下图显示了三种SSD与一种高端HDD的性能对比：

```text
                              Random              Sequential
                            Reads   Writes      Reads Writes
Device                      (MB/s)  (MB/s)      (MB/s) (MB/s)
Samsung 840 Pro SSD         103     287         421     384
Seagate 600 SSD             84      252         424     374
Intel SSD 335 SSD           39      222         344     354
Seagate Savvio 15K.3 HDD    2       2           223     223
```

要注意的是，以上所示的性能差别中，有一部分是硬件特性导致的，有一部分也是跟使用的读写算法有关的（比如LFS日志文件系统能大幅提升随机写入速度）

### 成本

可以看到SSD全方位秒杀HDD，那么为什么没有淘汰HDD？就是成本问题。

目前SSD的成本是60美分/GB，而HDD的成本是5美分/GB。

所以如果关心速度，就上SSD；如果需要巨大容量，就选HDD。或者选择混合模式，将常用的数据（热数据）放在SSD中，将不常用的放在HDD中。

> 译者注：比如生活中常用的例子就是，在SSD上装系统，在HDD上下载电影。

## 44.12 小结

这里只是简单介绍了SSD，仅仅只是一个入门。不要只看学术论文，也可以阅读流行媒体的最新进展。
