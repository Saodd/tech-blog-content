```json lw-blog-meta
{"title":"网络学习笔记8：网络安全","date":"2019-11-08","brev":"作为后端应用程序员，从上到下学到IP层就足够了。常用的SSL/TLS加密层是位于HTTP/TCP之间的，而且对于任何互联网应用来说都非常重要，因此是必须要掌握的部分。","tags":["网络"],"path":"blog/2019/191108-网络学习笔记8.md"}
```



# 第八章 Security in Computer Networks

我们遵循从上到下的思路，先讲TCP安全，然后网络层，然后无线LAN。

## 8.1 什么是网络安全

要注意的是，因特网是个开放的网络，根据前面学习的IP协议，理论上任何人都可以拦截或者监听你发出的报文段。

安全通信有如下目标：

- 保密性。只有发送方和意向接收方才能理解消息内容。因此消息需要『加密`encrypted`』。
- 完整性。保证消息不被意外或者恶意地篡改。通过校验和实现。
- 身份认证。确认对方是对的人。
- 运行安全。保护内部终端不受外部的攻击。使用防火墙。

加密是最重要的，但是必须要伴随身份认证一起使用。

## 8.2 加密的原则

虽然密码学已经有悠久的历史，但是在因特网中使用的现代密码学是最近几十年才发展的。

原始数据称为『明文`plaintext`（`cleartext`）』，发送方将明文加密后得到了『密文`ciphertext`』。有趣的是，现在的加密技术本身都是公开的、标准化的。因此加密的关键在于『秘钥`key`』。

将秘钥作为加密算法的参数，将明文转化文密文；另一方也提供一个秘钥，作为『解密算法`decryption algorithm`』的输入。

在『对称秘钥系统`symmetric key systems`』中，两个秘钥是相同的；而在『非对称秘钥系统`public key systems`』中，一个秘钥是完全公开的，而另一个秘钥是只有一方才知道的。

### 8.2.1 对称秘钥

先看一个最古老的加密法：凯撒密码。方法很简单，将字母在字母表中的顺序增加一个值，得到一个新的字符串。改进一下，可以用任意一个字母来替代某个字母（而不是固定顺延几个号）。

在破译密码时，可能有两种情况，一种是纯密文攻击`Ciphertext-only attack`，这种是最坏情况，需要最暴力的破解方法；另一种是已知明文攻击`Known-plaintext attack`即已知明文中的一些内容（比如知道用户的名字在明文中），基于这些内容进行破译，会让难度下降很多。

再改进一下，有『多字元加密法`polyalphabetic encryption`』，即根据字母在字符串中的位置，选择不同的字母（选择不同的密码表）去替代它。

#### 分组密码

对称加密有两大类，『序列密码`stream ciphers`』和『分组密码`block ciphers`』。序列密码用于无线网络加密，分组密码在当今应用于PGP（邮件加密）、SSL（TCP加密）和IPsec（IP层加密）。

分组加密时，将明文按照一定的长度k分组，每一组分别加密为k长度的密文。我们将这种将一组明文翻译为一组密文的规则（密码表）称为一个秘钥。

这种加密方式非常强大，破译的难度是以指数级别上升的。但相应地，密码表可能也会很大。如何减小密码表？答案是使用函数，而不是简单的储存配个密码配对。比如以64bit为一组，储存8个8bit的秘钥，分别加密之后进行扰乱，然后得到输出。

![2019-11-08-block-cipher.png](/static/blog/2019-11-08-block-cipher.png)

现在流行的分组加密算法包括DES、3DES、AES等。可以认为秘钥的长度k就是加密算法的强度，暴力破解的话需要`2^k`次尝试才能成功，以当今计算机性能来说128bit的秘钥就已经牢不可破了。（译者注：最近有量子计算机的消息，也许现在的密码也快要不够强了）

#### 密码块链

在网络应用程序中，我们往往需要给一个长消息（一长串数据）加密。如果只是使用上面说的分组密码，会有漏洞，因为会有一些固定的内容是已知明文的（比如`HTTP/1.1`这个单词）。

解决办法就是给密文添加一些随机性，使得同样的明文会产生不同的密文。（译者注：具体不展开了，主要使用了『异或运算符`XOR`』）

添加随机性意味着要发送双倍数量的数据（因为随机因子也要发过去），解决思路是在发送第一个消息时只发送一个随机值，然后让发送方和接收方使用计算出的编码块来代替后续的随机数。第一次发送的随机因子称为『初始向量`Initialization Vector` (IV)』，它以明文形式发送。这种方法称为『密码块链`Cipher Block Chaining` (CBC)』。

### 8.2.2 公开秘钥

细心的读者可能发现了，对称秘钥有个致命的问题：由于双方必须认准同一个秘钥，而这个认准的过程也需要通信；如果在交换秘钥通信期间被监听了，那么秘钥也就没有意义了。

一个伟大的发明就是公开秘钥。同时存在两个秘钥，『公钥`public key`』是完全公开的，而『私钥`private key`』只有其中一方知道。只有同时使用公钥和私钥才能进行解密，即，定义公钥为`Ku`私钥为`Ki`明文为`m`，有`Ku(Ki(m))==Ki(Ku(m))==m`。

#### RSA算法

（算法细节略过，主要是指数计算和取余计算）

#### 会话秘钥

RSA的推荐强度是1024bit，它的加密/解密速度非常慢，比其他常用的比如DES慢100-10000倍。

因此一个聪明的办法是，用RSA算法交换一个『会话秘钥`Session Keys`』，会话秘钥是对称秘钥，选择DES或者AES算法，速度快。后续通信都使用会话秘钥进行，大大提高速度。

## 8.3 消息完整性与数字签名

数据完整性包括两个方面：数据是否来源于那个人、数据是否被篡改。

### 8.3.1 加密哈希函数

功能是将不定长的输入，转化为固定长度的输出。典型例子比如校验和。

哈希函数要保证，攻击者很难**找到**另一个能够得到相同输出的输入（很难人为找到，但是可以存在）。这样攻击者的任何篡改都会使得输出错误，从而暴露。

前面学的校验和，是一种强度很低的哈希函数。`MD5`是常用的算法，长度是128bit。它主要有四个步骤：按位补充长度（在后面补0使得长度符合一定条件）、拓展长度（在最后附加原始数据的长度，64bit）、初始化缓存器、循环处理数据段。

还有一种常用算法是`SHA1`（及其系列），它比MD5更长、更强、也更慢。

### 8.3.2 消息认证代码

最简单的想法是，发送方将消息与哈希值一起发给接收方。但是问题也很明显，入侵者只要同时篡改二者，接收方就发现不了了。

解决办法还是老的思路，即在元数据`m`后面添加一些额外的字符串`s`，然后对整体求哈希值`H(m+s)`，然后将数据`(m, H(m+s))`发给接收方；接收方是已知`s`的，然后计算`H(m+s)`是否等于收到的哈希值。这个额外的字符串称为『消息认证代码`message authentication code` (MAC)』。

现在流行的是`HMAC`协议。

但是还有点问题，那就是如何发布MAC呢？

### 8.3.3 数字签名

顾名思义，数字签名就是以数字化的形式表明所有人。这意味着两点要求：第一，可证明性，能够证明签名的确是某个人签的；第二，不可拓展性，只有自己能生成自己的签名。

在这里使用公钥就很棒。比如某人要给某个文件“签名”，那么他可以用自己的私钥给文件加密，然后任何人都可以使用他的公钥来进行解密。

注意，给整个文件加密代价是非常高的。解决办法是，给文件计算哈希值，然后对哈希值进行签名。

#### 公钥证书

数字签名的重要应用就是『公钥证书`public key certification`』，用来证明某个公钥的确是属于某个实体的。

1. 有专门的证书组织负责颁发证书。人们必须选择相信还是不相信某个证书组织。
2. 证书包含一个公钥、和公钥所有者的唯一辨识信息（比如IP地址）。

举个例子。比如B发送了一个加密的披萨订单给A，订单后附带了B的证书；A查看订单，并通过证书中提供的公钥进行解密，以此确认订单的确是来自于B的。

## 8.4 终端认证

假设Alice要向Bob证明自己。

#### 认证协议1.0

最简单的办法就是，Alice说我是Alice。但是任何人都可以自称是Alice。

#### 认证协议2.0

如果Alice有常用的IP地址，Bob就可以查看IP源地址是否正确。但这只能挡住计算机菜鸟，高手可以修改内核IP协议，在IP头部中放置任意源地址。

#### 认证协议3.0

典型的认证模型是使用密码。但是如果密码通过明文传输，被窃听（抓包）之后就完蛋了。

#### 认证协议3.1

那就把密码加密！把整个通信文本都加密！这样密码就不会泄露了。

但是！入侵者可以将Alice的通信数据包全部录制下来，等明天原样发给Bob，这样Bob就会认为入侵者是Alice了。

#### 认证协议4.0

解决录制的问题，就是给密码加点盐。加什么盐呢？类似于TCP协议的确认号SYN，每次认证会话用一个唯一的『随机数`nonce`』。

1. Alice说：我是Alice。
2. Bob发回一个随机数R。
3. Alice将随机数R加密，然后发回给Bob。
4. Bob检查加密随机数是否正确。

这样就解决了上述问题。

## 8.5 安全电邮

我们前面讲了很多加密理论，现在看看如何运用在互联网中。

安全服务可以实现在网络架构中的任意一层。从上到下，可以实现在应用层（比如安全电邮）、传输层（SSL）、网络层（IPsec）以及连接层（无线网络安全）。

你可能会奇怪，其实只要在一层（比如IP协议上）实现安全服务就足够了吧？为什么要有这么多安全协议？首先，基于IP的安全服务无法提供用户级别的安全认证（比如同一个IP上不同用户发来的订单如何区别？）另外，在上层实现安全服务更容易，在下层实现可能需要等待全网的升级换代。

### 8.5.1 安全电邮

还是假设Alice给Bob发邮件。

首先是机密性。Alice可以用Bob的公钥，将邮件加密；Bob收到后用自己的私钥解密。但是公钥加密算法（非对称加密算法）性能很差。我们引入会话秘钥（临时秘钥）。Alice先生成一个会话秘钥（对称加密算法），然后将邮件内容用会话秘钥加密，然后将会话秘钥用Bob的公钥加密（非对称加密算法），然后将加密后的会话秘钥+加密后的邮件内容发给Bob。

然后是完整性。简单说就是计算哈希值。Alice先选择一个哈希算法（比如MD5），将邮件内容计算出哈希值，然后用自己的私钥对哈希值签名，然后把邮件内容+签名后的哈希值发给Bob。

两个功能合并也很简单。将后者的（邮件内容+签名后的哈希值）当做原始邮件内容，使用临时秘钥加密后用公钥加密blabla。

### 8.5.2 PGP

是『`Pretty Good Privacy`』的缩写，是电子邮件加密方案，已成为事实上的标准。它的逻辑就是上面说的那样。它的消息格式大概长这样（分别是签名版、加密版）：

```text
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA1
Bob:
Can I see you tonight?
Passionately yours, Alice
-----BEGIN PGP SIGNATURE-----
Version: PGP for Personal Privacy 5.0
Charset: noconv
yhHJRHhGJGhgg/12EpJ+lo8gE4vB3mqJhFEvZP9t6n7G6m5Gw2
-----END PGP SIGNATURE-----
```

```text
-----BEGIN PGP MESSAGE-----
Version: PGP for Personal Privacy 5.0
u2R4d+/jKmn8Bc5+hgDsqAewsDfrGdszX68liKm5F6Gc4sDfcXyt
RfdS10juHgbcfDssWe7/K=lKhnMikLo0+1/BvcX4t==Ujk9PbcD4
Thdf2awQfgHbnmKlok8iy6gThlp
-----END PGP MESSAGE
```

## 8.6 安全TCP连接：SSL

全称是『安全套接字层`Secure Sockets Layer` (SSL)』，还有一个在SSL3基础上的轻微改进版『安全传输层协议`Transport Layer Security` (TLS)』。

SSL被广泛使用，并被所有浏览器和服务器支持。它最常见的场景是用于强化HTTP，但实际上任何基于TCP的应用都可以使用SSL。SSL提供了与TCP类似的套接字api。如下图所示，虽然SSL被划分在应用层中，不过从开发人员的角度来看它更像是一个传输层协议。

![2019-11-08-SSL-layer.png](/static/blog/2019-11-08-SSL-layer.png)

### 8.6.1 整体情况

我们先看一个简化版本的SSL，我们这里就叫他ASSL吧。ASSL有三个阶段：握手、导出秘钥、数据传输。假设Alice是服务端而Bob是客户端。

#### 握手

在这个阶段，客户端要做三件事情：一，建立TCP连接；二，验证服务端；三，生成一个会话秘钥并发送给服务端。

![2019-11-08-SSL-handshake.png](/static/blog/2019-11-08-SSL-handshake.png)

在这个过程中，服务器发送的证书，包含了公钥并且能让客户端相信客户端是真实的。客户端生成一个会话秘钥，使用公钥加密，发回给服务端。

#### 导出秘钥

非对称秘钥（公钥）只是用于交换对称秘钥（会话秘钥）的，交换之后，双方通过对称秘钥进行通信。这个会话秘钥，在这里称为『主秘密`master secret` (MS)』。使用MS生成四个秘钥：

- `Eb`：从客户端到服务端的，数据传输会话秘钥；
- `Mb`：从客户端到服务端的，数据验证（MAC）会话秘钥；
- `Ea`：从服务端到客户端的，数据传输会话秘钥；
- `Ma`：从服务端到客户端的，数据验证（MAC）会话秘钥；

强调一次，四个秘钥都是通过MS生成的（比如，将MS切成四份）

#### 数据传输

由于TCP是字节流协议，因此上层的SSL要将应用层数据加密并传给TCP层。那么在哪里进行完整性校验呢？（译者注，假设传输了100Mb的字节流，难道要等全部传输完了再校验吗？）

SSL的办法是把数据流切割成一段一段，每一段称为『记录`record`』。然后对每一段进行完整性校验（即生成MAC）。

这里还有一点小问题，即虽然现在每个record内的完整性保证了，但是record的顺序还不能保证，因为现在还是依赖TCP的顺序号来保证顺序的。于是在SSL层中也实现一个顺序号，但是不直接附带顺序号，而是把顺序号纳入MAC的计算中；即，现在的MAC的哈希函数的输入是（元数据+MAC秘钥+顺序号）

#### SSL-record格式

```text
--------------------------------------------------------------
| Type | Version | Length |         Data             |  MAC  |
--------------------------------------------------------------
                          |<--     Encrypted with Eb      -->|
```

### 8.6.2 SSL细节

#### 握手

SSL并没有强制规定密码算法的选择，实际上双方只要在SSL会话开始阶段达成一致即可。详细的握手步骤：

1. 客户端发送其支持的所有加密算法的列表，以及一个客户端nonce（随机数，会话编号的意思，前面介绍过）
2. 服务端从列表中选择算法（一个对称算法例如AES、一个公钥算法例如RSA、一个MAC算法），告诉客户端，同时发回证书和一个服务端nonce；
3. 客户端验证证书；然后生成一个『预定主密`Pre-Master Secret` (PMS)』，将PMS使用公钥加密后发回服务端；
4. 双方根据（PMS和两个nonce）生成MS，然后用MS生成四个会话秘钥；之后都用会话秘钥进行加密；
5. 客户端将前面这些握手阶段的消息计算一个MAC，并发送；
6. 服务端将前面这些握手阶段的消息计算一个MAC，并发送；

最后两个步骤有些奇怪，是因为第一步发送算法列表时，是以明文发送的，有些算法很强有些算法相对较弱，入侵者可以删掉强的算法以迫使服务端选择最弱的算法。因此在正式开始传输数据之前，将前面的消息重新校验一遍，如果有异常就断开这次连接。

#### 连接关闭

简单的思路是直接关闭下面的TCP连接，即发送一个TCP-FIN报文段。如果是这样的话，入侵者可以伪造FIN报文段（因为它没有加密，只是一种TCP的特殊报文），导致服务端认为客户端的数据已经发完了，造成不可预料的后果。

因此要通过SSL层面的特殊record来通知对方关闭连接。

## 8.7 网络层安全：IPsec和VPN

使用IPsec来构建VPN（全称『虚拟专用网络`virtual private network`』）

在网络层（IP层）上实现安全服务的好处很明显，上面所有的数据报文段都可以享受安全服务，即实现了全覆盖。

### 8.7.1 IPsec与VPN

对于一个在多个地区有分部的机构来说，为了安全地通信，最粗暴的办法可以自己搭物理网线将各分支机构连接起来。但是更经济也更实际的方法是搭建虚拟网络VPN，示意图如下：

![2019-11-08-VPN.png](/static/blog/2019-11-08-VPN.png)

需要注意的是，由于IPsec是在IP层上实现的，因此路由器可以参与加密/解密的过程，如上图所示。

### 8.7.2 AH和ESP协议

IPsec非常复杂，它由几十个RFC规范定义。其中有两个主要的协议：『认证头`Authentication Header` (AH)』和『封装安全载荷`Encapsulation Security Payload` (ESP)』。

AH提供源地址认证、数据完整性校验，但是不支持加密；ESP支持全部。因此ESP更加重要。

### 8.7.3 安全联结

发送IPsec报文段之前，要建立从源地址到目的地的『安全联结`Security Associations` (SA)』。注意SA是单向的，如果需要双向通信要建立两个SA。

![2019-11-08-SA.png](/static/blog/2019-11-08-SA.png)

SA的发送端要维护状态信息，包含：

- 32bit标识符，称为『安全参数索引`Security Parameter Index` (SPI)』；
- 发送端接口地址和目的地接口地址（在上面的例子中是 200.168.1.100 和 193.68.2.23 ）
- 加密算法
- 加密秘钥
- 完整性校验算法
- 认证秘钥

一个IPsec实体（路由器或者终端）往往维护着多个SA信息，放在称为『安全联结数据库`Security Association Database` (SAD)』的地方。

### 8.7.4 IPsec报文段

IPsec有两种数据封装方式，『隧道模式`tunnel mode`』和『传输模式`transport mode`』。VPN常用隧道模式。

在隧道模式下，将普通IP报文段转化为IPsec的过程：

- 在原报文段后面加上一个“ESP尾巴”
- 用SA定义的算法和秘钥进行加密
- 在前面加一个“ESP”头部；此时，整体称为`enchilada`
- 对`enchilada`计算MAC，并放到后面；此时，整体称为`payload`
- 创建一个新的IP头，其中协议号是50代表着这是IPsec报文段

> 译者注，VPN不涉及互联网应用开发，因此只做简单翻译。

### 8.7.5 IKE：IPsec的秘钥管理

如果是很大很复杂的VPN网络，需要一个自动化管理SA的工具，它是『因特网秘钥交换协议`Internet Key Exchange` (IKE)』。

IKE与SSL的握手阶段很像，每个IPsec实体都有自己的证书（包含公钥）。

## 8.8 无线网络安全

（略过）

## 8.9 运维安全：防火墙与入侵检测系统

### 8.9.1 防火墙

防火墙包括硬件部分和软件部分。主要逻辑是将某个组织的内部网络与外部因特网隔离开来，只允许特定条件的数据包通过。

- 所有内-外或者外-内数据流量都必须通过防火墙。
- 只有符合安全策略的流量才可以通过。
- 防火墙自身安全可靠，不惧攻击。

防火墙大致分为几类：传统的数据包过滤、有状态的过滤器、应用网关`application gateways`。

#### 传统数据包过滤器

一般来说，一个机构往往会有一个网关路由器连向ISP。因此可以在这个路由器上执行数据包过滤。

数据包过滤器独立地检查每个报文段，并确定它是否符合安全策略。主要检查：IP源地址或者目标地址、协议类型、TCP/UDP端口号、TCP-flag等等。

#### 有状态的过滤器

传统数据包过滤器对每个数据包独立检测，而有状态的过滤器可以追踪TCP连接，并根据连接来过滤。这是可行的，因为防火墙能看到所有TCP连接的所有生命周期（包括握手）。

典型的应用是，控制TCP连接最大时间60秒。

#### 应用网关

还有些需求是前面两种防火墙做不到的，比如基于用户身份的权限控制。这需要应用层协议的数据，仅靠IP层是做不到的。

比如，只允许内部的部分用户使用Telnet到外部，禁止所有外部Telnet到内部。

### 8.9.2 入侵检测系统

就是要深入到应用层数据体内部，检查其中的数据是否像是常见的攻击。如果是，可以丢包或者报警。

## 8.10 总结

网络安全的核心目标就是：保密性、终端认证、完整性。

先讲了加密算法，有两大类：对称算法和非对称算法。特别要注意的是，客户端/服务端在一开始交换秘钥时，如何保证安全，答案是用证书（公钥）。用公钥加密的内容，只有私钥可以解开。

然后是完整性，从校验和讲到MAC，实质上就是一个哈希函数，不过要额外加点盐。

然后讲TCP安全（SSL）、IP安全（IPsec）。到这里，通信已经可以说是很安全了。

最后是防火墙，提供一些管理控制的功能。
