```json lw-blog-meta
{"title":"OS学习笔记07：CPU虚拟化的上层实现-基础调度器模型","date":"2019-08-12","brev":"讲了底层硬件的机制，接下来讲上层的软件政策。","tags":["OS"],"path":"blog/2019/190812-OS学习笔记-07.md"}
```



# 第七章 <CPU调度：简介>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched.pdf)

其实`调度`这个概念在人类社会早就有了，计算机出现后应用到了计算机系统上。

关键问题：我们如何构思一个调度政策的框架？关键假设有哪些？需要哪些指标？

## 7.1 工作负载假设 Workload Assumptions

先将系统中所有的进程都简化为`负载workload`。

我们对所有进程（有时也叫`任务jobs`）做出以下假设：

1. 每个任务的执行时间相同；
2. 所有任务同时到达；
3. 从启动开始，所有任务一直运行到结束；
4. 所有任务只使用CPU资源（比如，不用IO）
5. 每个任务的执行时间已知。

## 7.2 调度指标 Scheduling Metrics

一个`指标metric`是我们用于测量某样东西的东西。评价一个调度政策可能会有几百个指标，
但我们这里简化为一个：`周转时间turnaround time`，即任务完成的时间-任务到达的时间。
因为我们假设所有任务同时到达，所以周转时间就是完成时间。

注意，这是一个`性能performence`指标，性能是我们关注的重点。与之相对的是`公平fairness`，难以两全。

## 7.3 先进先出 FIFO

有时也叫First come, First Served(FCFS)。

假设ABC三个任务同时依次到达，每个任务需要10秒。那么依次执行A、B、C，
总`周转时间`为（10+20+30）/3=20秒。

![Figure 7.1](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-1.png)

如果我们把`假设1：每个任务的执行时间相同`去掉，那会发生什么？

![Figure 7.2](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-2.png)

总`周转时间`现在是110秒。这就是`车队效应convoy effect`，有些小任务被大型任务堵住了，只能排队。

## 7.4 小任务优先  Shortest Job First (SJF)

大型任务放到后面就ok了！此时总`周转时间`为50秒。

但是如果移除`假设2：所有任务同时到达`，那么就没办法判断最小任务了，比如B、C在第10秒时到达：

![Figure 7.3](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-3.png)

## 7.5 最快完成的任务优先 Shortest Time-to-Completion First (STCF)

我们继续解封`假设3：所有任务一直运行到结束`，然后加上我们之前讨论的`中断`和`上下文切换`机制，
调度器可以在小任务B、C到达时，调度器可以做出选择了（比如暂停A，稍后再继续A）。

之前说的`小任务优先SJF`是一种`非抢占式non-preemptive`的调度器。我们在其中加入`优先权preemption`，
就得到了所谓的`最快完成的任务优先STCF`（或者叫`特权最短任务优先PSJF`）。

每当一个新任务到达时，STCF调度器会计算哪个任务剩余时间最短，然后调度这项任务去执行。

![Figure 7.5](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-5.png)

## 7.6 新的指标：响应时间 Response Time

在知道任务长度、任务只用CPU、指标只考虑周转时间的话，STCF已经是完美的了。

但是人们要求越来越高，提出了新的要求：`响应时间`。即`首次执行时间-任务到达时间`。

对于`图7.5`中所示的情况，平均`响应时间`为3.33秒，事实上`STCF`并不利于响应时间。

## 7.7 循环 Round Robin

我们引入一个新的`循环Round Robin`调度器。主要思路是，不把任务执行完，而是每个任务只占用一个
`时间片time slice`（或者叫`调度单位scheduling quantum`），然后切换到队列中的下一个任务。
所以`RR`也叫做`时间分片time-slicing`。

注意，时间片的长度必须是`计时中断timer-interrupt`周期的整数倍。

![Figure 7.7](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-7.png)

可以看到，时间片越短，响应时间越快，但是同时，上下文切换的消耗就增加了。
所以时间片的长度只能折衷，既要尽可能`摊销amortize`切换成本，又要尽可能压缩响应时间。

要注意，上下文切换的时间并不仅仅是OS存取寄存器数据的开销，同时包括了`缓存cache`，`TLB`，
`分支预测branch predictors`以及其他的芯片上的数据。这些会导致很明显的性能损耗。

`RR`利于响应时间，但是不利于周转时间。

## 7.8 引入IO

我们接下来释放`假设4：所有任务只使用CPU资源`。

很显然，当进程调用IO时，进程被`阻塞blocked`了并且不会使用任何CPU，所以调度器必须决定是否切换进程。

当IO完成时，调度器也必须要做出响应。当这类事件发生时，会产生一个打断，此时OS就可以把调用IO的进程设为
`Ready`状态，甚至直接运行这个任务。

假设我们有任务A、B，各需要50ms的CPU时间，但是A在10ms后需要调用IO（10ms），而B只需要CPU。

![Figure 7.9](https://saodd.github.io/tech-blog-pic/2019/2019-08-12-Fig-7-9.png)

## 7.9 小结

移除最后一个`假设5：每个任务的执行时间已知`，我们还如何实现前面介绍的调度器？
我们在下面一章讲解`多级反馈队列multi-level feedback queue`来解决这些问题。
