```lw-blog-meta
{"title": "OS学习笔记48：分布式：远程过程调用RPC", "date": "2019-09-09", "tags": ["OS"], "brev": "分布式系统与远程过程调用RPC。"}
```

# 第四七章 <A Dialogue on Distribution>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/dialogue-distribution.pdf)

构建一个分布式系统非常复杂。消息可能丢失，机器可能崩溃，硬盘可能故障，这些小问题汇总起来能够让你怀疑人生。

但是像Google这样的大公司做到了，它们构建一个巨型的分布式系统，来保证即使有一部分机器发生故障了，整个系统依然能够正常运行。

主要的技术有：`主从复制replication`，`重试retry`等等用于侦测和恢复故障的技术手段。

# 第四八章 <Distributed Systems>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/dist-intro.pdf)

分布式系统的概念可以非常广泛。当你用浏览器访问一个网站，你的电脑与服务器电脑就可以视作是一个最简单的分布式系统，这称为为`C/S模型 client/server`。当你访问Google这样的网站，在网站背后是无数台机器，每台机器只负责网站的一个（或几个）服务。

**关键问题：如何构建一个能够应对故障的分布式系统？**

记住，某几台机器崩溃了不要紧，我们的目标是提高整个分布式系统的可用性。

另一方面，我们经常会考虑系统的性能。详细说，就是减少消息的转发数量，提高消息的传递效率。

还要考虑一下安全因素。

总之，我们讲一些最基本的概念：`传输communication`。

## 48.1 传输基础

在计算机的世界中，要记住：传输是根本不可靠的。不管在广域网还是局域网。

丢包的原因有很多。比如，在传输时可能有个别bit会受到电子辐射的干扰而变化；或者有时在软件层面也可能有bug；或者交换设备的缓冲区不足（此时会被`丢掉drop`）

## 48.2 不可靠传输层

一个简单的办法就是：不解决它。

因为有时上层应用知道如何处理丢包情况，因此提供一个不可靠的传输层有时也是非常有用的。

典型例子就是UDP/IP协议。进程使用`套接字socket`接口来创建一个`传输终端comminication endpoint`，（另一台机器上的）另一个进程通过`报文datagrams`来向这个进程发送数据（一个报文是有固定最大尺寸的）。

UDP的特性就是不可靠。即发送方根本不知道报文是否正确送达接收方。不过这也不意味着UDP完全不可靠，它也提供`校验和checksum`等方法来侦测一部分故障。

## 48.3 可靠传输层

那么发送方如何确认接收方正确接收了？办法就是`确认acknowledgment`（或者缩写`ack`）。理念很简单，接收方收到数据包以后，发回一个简短的消息来说明自己已经接收了。

如果发送方没有收到确认怎么办？我们用`超时timeout`机制。如果超时没有收到确认，那就`重发retry`。这意味着在收到确认之前，发送方要一直保留一个数据包的副本。

重发会有个问题，会导致重复发送。在接收方看来，是收到了两个包！如何保证只收一次？很简单，发送方要给每个包设置一个唯一的身份标识，这样就可以排除重复了。

那么如何设置身份标识？使用唯一的ID号太耗费资源了。一个简单的办法是，双方约定一个`顺序计数器sequence counter`，双方在收发时各自递增。

这种机制的典型就是TCP/IP协议。

> 谨慎设置timeout。设置太短，可能会让发送方多次重发；设置太长，可能让接收方等待太久。事实上，在分布式系统中，丢包率是衡量一台机器是否过载的重要指标。所以一般可能会用翻倍延长timeout的方法来优化。

## 48.4 传输层抽象

假如选定了一个传输层协议，我们如何将其抽象，并在此基础上构建一个分布式系统？

## 48.5 远程过程调用PRC

在分布式系统上抽象一个OS是很低效的，但是在应用程序语言层面的抽象是可以实现的。我们称其为`远程过程调用 remote procedure call`。

RPC的思想很简单：把在远程机器上执行代码，变得像在本地调用函数一样的感觉。对客户端来说，调用一个RPC稍后获得了结果（返回值）。

RPC有两个重要组成部分：`根生成器stub generator`（或者叫`代理编译器protocol compiler`），和一个`运行时库runtime library`。

### stub generator

根生成器的任务很简单：帮你将参数和返回值进行序列与反序列化处理。可以理解为是一个代码生成工具，帮你完成一些重复的并且易错的代码。

你应该给它输入类似下面这样的接口，然后它会生成一些代码。

```text
interface {
    int func1(int arg1);
    int func2(int arg1, int arg2);
};
```

在`客户端client`生成的根生成器，表面上依然是通过`gunc1(x)`这样的形式调用，但是在内部它要实现：

- 创建一个消息缓存。
- 将所需的信息`序列化serialization`（或者称`marshaling`），并放入缓存。
- 把消息发送给目标RPC服务器。
- 等待返回。（一般是`同步synchronous`调用）
- 将返回的消息`反序列化deserialization`。
- 返回调用者。

在服务端也要生成一个根，它在执行时也有相对应的步骤：

- 将客户端发来的消息反序列化。
- 调用真正的目标函数。
- 将结果序列化，并发回客户端。

要注意的一个细节是如何序列化。比如遇到指针，大型数据体，文件描述符等这样的数据，如何处理？

另一个要注意的是，服务器如何处理并发问题？常用的办法是线程池。

### Run-Time Library

第一个问题是如何定位服务器，这个问题称为`命名naming`，是分布式系统中常见的问题。最简单的办法就是利用现有的命名方式，即通过host+port，详情请去了解一下DNS相关知识。

另一个问题是选择何种传输协议，具体来说就是TCP还是UDP。初步思考应该选用可靠传输协议TCP，但是，TCP的检查重复机制会让服务器的返回值被过滤掉。因此实际应用中，一般选用UDP，并在应用层做好超时重发的检测机制。

### 其他问题

如果远程调用函数需要很长时间完成怎么办？一种办法是显式指定timeout时间。另一种办法是实现轮询。

有时参数（或返回值）可能很大，大于一个数据包的最大尺寸。有的底层网络协议提供`分裂fragmentation`与`重组reassembly`的功能；如果没有，那么RPC框架就要自己实现。

还有一个问题是`字节序byte ordering`，有的机器以`高位优先big endian`而有的机器是`little endian`（译者注：65534作为一个int型可能会是0xfffe0000,或者0x0000feff），在转化时需要妥善处理。

最后一个问题是是否提供异步支持。典型的RPC函数应该是同步的，即客户端等待调用返回后才返回。如果执行时间的确太长了，可以考虑异步调用。

## 48.6 小结

分布式系统的关键问题就是，如何解决`故障failure`问题。（或者说所有涉及IO的软硬件都必须首先考虑这个问题）。

现代流行的分布式系统有Google的`gRPC`和Apache的`Thrift`。

## 译者注

其实RPC是一个很大的概念，RPC又是分布式系统的基础。我们最简单的网页请求，即C/S模型其实就是一种RPC，故而也可以理解为某种形式的分布式系统。

再推广一些，基于直接基于传输层（UDP/TCP）的一般性能较高，我们可以用在服务器集群中。基于Http的适应性更广，也就是我们常见的REST，SOAP之类的东西。
