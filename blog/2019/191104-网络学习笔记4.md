```yaml lw-blog-meta
title: 网络学习笔记4：网络层
date: "2019-11-04"
brev: 第三层，网络层。主要是IP协议。
tags: [网络]
```


# 第四章 Network Layer

网络层在每个终端和路由器中都在运行着，因此它是最复杂也是最有趣的一层。

在这一章里，我们首先要区分『转发`forwarding`』和『路由`routing`』：转发是在单个路由器中从输入端移到输出端的过程，而路由指的是所有路由器工作的集合。在现实中『转发』和『路由』经常被混淆使用，在本章中会精确地区分。
 
为了深入理解转发，我们会看看路由器的内部构造。然后学习IP、NAT、IPv4、ICMP、IPv6等概念。为了理解路由，我们会学习路由算法。

## 4.1 介绍

### 4.1.1 转发和路由

每个路由器都有『转发表`forwarding table`』。从输入包中读取头部某个字段，然后在表中查找知道从哪个口输出。表大概长这样：

|  header value  |  output link  |
| :---: | :---:|
| 0100 | 3 |
| 0101 | 2 |
| 0111 | 2 |
| 1001 | 1 |

还有一些术语要说明一下。我们接下来说『包交换`packet switch`』指的是一种通用的、根据包头字段从输入端转发到输出端的交换设备。有连接层交换机和路由器这两种。

除了转发和路由之外，网络层还有一个重要功能是『连接准备`connection setup`』，就像TCP的三次握手一样，有些网络层架构要求提前准备好连接状态。

### 4.1.2 网络服务模型

提供的服务其实跟TCP当时分析的差不多，就是那些。因特网架构提供的服务模型是『尽力Best Effort』，不保证带宽、丢包、顺序、延迟、拥塞控制。还有一种架构称为`ATM`，可能提供可靠传输服务。

## 4.2 虚拟电路和数据报网络

网络层与传输层类似的，也分为面向连接的和无连接的服务两种。看起来是重复了，但是我们注意一些关键不同：

- 网络层提供的是主机到主机的服务，而传输层是进程到进程的；
- 有连接的称为『虚拟电路网络`virtual-circuit(VC) network`』，无连接的称为『报文段网络`datagram networks`』。
- 面向连接服务的实现完全不同。传输层是在终端上进行控制，而网络层是在网络核心（路由器）上实现的。

### 4.2.1 虚拟电路网络

一个VC包含：①一条从始发地到目的地的『路径`path`』，由沿途的link和routers组成；②『VC号码』，沿着路径上每个link都有一个号码；③存在路径上的路由器中的转发表中的记录。

每个数据包都会在header中包含一个VC号码，而由于每个link可能是不同的号码，因此每次转发时都要更换header中的VC号码。

转发表大概长这样：

|  Incoming Interface  |  Incoming VC #  |  Outgoing Interface  |  Outgoing VC #  |
| :---: | :---:| :---: | :---:|
| 1 | 12 | 2 | 22 |
| 2 | 63 | 1 | 18 |
| 3 | 97 | 2 | 17 |
| 1 | 7 | 3 | 87 |

为什么每次转发都要更换号码？第一减少头部的号码字段长度，第二每个路由器可以随意独立地选择号码而无需跟其他路由器确认。

VC的生命周期有三个阶段：

- VC设置：终端网络层负责决定路径，在这个过程中会在路径上每个路由器设置VC号码。
- 数据传输
- VC关闭：反向操作，即通知路径上的路由释放掉相关的号码。

记住，传输层只是在两个终端上建立连接变量；而网络层是在整个沿途的所有路由上建立。

### 4.2.2 报文段网络

在报文段网络中，每个数据包上都会写入目标地址。每个路由器都会检查目标地址，然后发往对应的link；路由器维护的转发表中，键就是目标地址。

想象一下转发表长什么样子。我们知道IP地址是32位，意味着有40亿条记录，因此路由器不可能为每个IP都单独设置规则。

更加现实一点，路由器可以根据地址的范围来决定转发规则。或者，根据地址的前缀（前n位）来决定。其中有个小细节注意一下，某个地址有可能匹配了多个前缀，此时按照『最长前缀匹配原则』来决定。

虽然报文段网络中的路由器无需维护连接，但是必须要维护转发表。但由于转发表的更新频率相对来说很低，大概1-5分钟更新一次。

由于报文段网络中的路由器的转发表随时可能更新，因此某个终端发往另一个终端的一系列数据包可能会经过完全不同的路径，因此会造成乱序等问题，这也是上层TCP解决的问题之一。

### 4.2.3 起源

虚拟电路网络的思想是源自于电话系统的，电话系统是建立在真实电路网络上，因此虚拟电路更加复杂。

而报文段网络的代表，因特网，设计目标是将所有的电脑连接在一起。考虑到终端越来越强大，网络层被设计得尽可能简单。即网络层不提供任何保证，所以自然地要求也被降到了最低，所以很容易与不同的连接层协议进行兼容。

## 4.3 路由器的内部结构

- 输入端口：首先负责从物理层处理，然后是连接层处理，最后在转发表中进行查询并决定数据包发往哪个输出端口。注意这里的端口是指物理意义上的端口，而不是软件上的。
- 交换矩阵（`Switching fabric`）：连接输入端口和输出端口。
- 输出端口：从交换矩阵中获得数据包，并将其转化为连接层、物理层数据包然后发出去。要注意的是如果连接是双工的，那么输入端和输出端在电路上是放在一起的。
- 路由处理器：处理『路由协议`router protocols`』，维护路由表、转发表，还负责路由管理功能。

输入端、交换矩阵、输出端共同组成『路由转发板`router forwarding plane`』，几乎所有的转发功能都通过硬件来实现，因为在巨大流量压力下，每个报文段的处理时间可能只有几纳秒，只有硬件才能实现这种速度。相对的，路由处理器放在『路由控制板』上，运行在毫秒级的性能尺度上。

### 4.3.1 输入处理

路由处理器计算出转发表之后，会将其分别复制到每个输入端的本地内存中，以优化性能。内存也很有讲究，（注意所有实现要通过硬件而不是软件）必须要求查询的时间复杂度是常数级，因此内存是基于高速缓存设计的，只要根据IP去查询就能得到输出端口号（实质上已经可以理解为是一个翻译器而不是内存了）。

当数据包的输出端口被决定以后，就可以发往交换矩阵了。在有些设计中，如果线路被占用了那就可能会稍微阻塞一会儿。

### 4.3.2 交换

交换矩阵是路由器的核心部分，有几种实现：

#### 通过内存交换

早期的也是最简单的模式。处理器将输入输入端口视作传统的IO设备。数据包到来时，通过『中断』来通知处理器，处理器将其拷贝到内存中，然后查询转发表，然后拷贝到输出端。

现代的路由器大多是通过内存。不过，查询和拷贝的操作是由每个输入端线上芯片独立处理的，看起来非常像是共享内存的多处理器。

#### 通过总线交换

这种模式下，输入端通过一个共享的总线，直接将数据包传到输出端，不经过处理器。输入端会给数据包打上标签，所有的输出端都会收到数据包，但是只有标签指向的那个输出端才会处理这个包。

总的网速受限于总线的速度，不过在小型局域网中还是不错的。

#### 通过交互连接（Crossbar）

![2019-11-05-Crossbar.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-Crossbar.png)

每个输入端和每个输出端都有自己的总线，总线之间互相连接，交点是开关。『交换矩阵处理器』负责控制交点的开闭。这样允许不同的线路上进行并行传输。

### 4.3.3 输出处理

### 4.3.4 队列

输出端也有缓冲区，当传入输出端的速度太快，缓冲区会被填满，然后发生丢包。（输入端和输出端同样原理）多大的缓冲区合适？理论推荐值是平均来回时间与连接速度的乘积，比如`10Mbps*250ms=2.5Mb`。

既然有排队，那就有调度算法。最简单的是『先到先得FCFS』，高级一点的有『权重公平队列WFQ』。

丢包也有算法。可以选择拒绝接受新来的包、或者丢掉队列中的包腾出空间，在某些情况下，在缓冲区未满的时候就丢包可以起到给发送端提醒拥塞控制的作用。最流行的算法是『随机早期检测`Random Early Detection`』，即设置一个下限和上限，当平均队列长度小于下限时，完全接受；当平均队列长度高于上限时，完全丢弃；介于中间时，计算概率随机丢弃。

特别注意的是，前面讨论的是『输出端的传入队列』，但是在『输入端的传出队列』同样会阻塞，会严重影响网络的效率，这个现象称为HOL。

### 4.3.5 路由控制板

我们已经了解到路由器中是有多个模块的，模块之间独立工作，通过互相发送控制消息来交互。

## 4.4 IP协议：转发与定位

前面讲的都是一些理论模型，现在讲点实际的，IP协议。它目前有两个版本，IPv4和IPv6。

其实，网络层不仅仅包含IP协议。还包括路由协议和控制消息协议。

![2019-11-05-network-layer-inside.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-network-layer-inside.png)

### 4.4.1 报文段格式

网络层数据包称为『报文段`datagram`』，我们先看看IPv4的结构：

![2019-11-05-ipv4-format.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-ipv4-format.png)

几个重要字段解释一下：

- `Version number`。表明了IP协议的版本号，这决定了剩下的数据应该如何读取。上图展示的是IPv4的格式。
- `Header length`。因为IP协议头部长度可变（即包含了可选字段），因此需要这个字段来说明从哪里开始是Body。大多数报文段都不包含可选，因此典型长度就是20bytes。
- `Type of service`（TOS）。用于表明这个报文段对于网络的需求（比如要求低延迟、或高通量、或可靠性）。我们在第七章研究。
- `Datagram length`。整个报文段的长度。字段长度16bit即最大支持65535bytes的报文段长度，不过很少超过1500bytes。
- `Identifier`, `flags`, `fragmentation offset`。这些字段用于支持『分裂`IP fragmentation`』，有趣的是IPv6不支持。
- `Time-to-live`。用来防止报文段在网络中无限循环。每次转发时减一，归零时被强制丢弃。
- `Protocol`。当报文段到达目的终端时使用，用来决定这个报文段发往上层的哪个协议，很类似传输层协议中的端口号。比如6表示TCP而17表示UDP。
- `Header checksum`与TCP的校验是一样的，如果有错误就丢弃报文段。但是要注意的是每次转发都要重新计算，因为TTL字段改变了。为什么两个层都要校验和？第一，IP层的校验范围是IP层报文段；第二，IP和TCP/UDP并不一定要同时使用，可以选择其他协议。
- `Source and destination IP addresses`
- `Options`。支持IP报文段头部的拓展功能，不过很少使用，而且这会给路由器带来性能负担。在IPv6中舍弃了。
- `Data (payload)`。包含TCP、UDP或者ICMP数据包。

值得提醒的是，IP头是20bytes，TCP头也是20bytes。

#### IP报文段分裂

由于下面的连接层千差万别，每种协议的『最大传输单元（MTU）』都是不同的，因此一个IP报文段可能会被拆分，形成『碎片`fragment`』。

由于碎片的重组会给IP协议增加复杂度，并且影响路由器的性能，IPv4的设计者将这个任务交给终端来做。

路由器还是要负责拆解碎片（因为发送端不知道路途中最小的MTU是多少）。每个碎片都会打上相同的来源地址、目标地址、标识码。

报文段的分裂和重组，会增加设计复杂度和性能负担；同时还增加了系统的弱点（有针对这里的DoS攻击方式）。Ipv6有了很大的改进。

### 4.4.2 IPv4定位

先讲个细节。每台终端/路由器与物理线路之间的界面，称为『接口`interface`』，终端一般有一个而路由器一般有多个。由于每个接口是具备收发能力的，因此在技术上看IP地址是与接口关联起来的，而不是终端/路由器。

IP地址长度32bits（或者4bytes），一般我们用『点分十进制记法`dotted-decimal notation`』来表示，比如`193.32.216.9`表示`11000001 00100000 11011000 00001001`。

IP地址不是随意决定的，而是要根据所在的『子网`subnet`』来决定。

![2019-11-05-Interface-addresses-and-subnets.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-Interface-addresses-and-subnets.png)

在下图红色方框里的三个接口组成一个子网，子网中没有路由器，中间的可能是一个『以太网`Ethernet`』或者『无线网`Wireless`』。这个子网有它自己的IP地址，例如左边的子网是`223.1.1.0/24`，其中`/24`是『子网掩码`subnet mask`』表示前24位定义这个子网的地址。子网中所有的IP地址必须以子网地址开头，例如`223.1.1.1`。

因特网的地址分配策略是『无类域间路由`Classless Interdomain Routing`（CIDR）』，用`/24`这样的形式将IP地址分为两个部分。前面的部分称为『前缀`prefix`』，每个组织（或ISP）获得一段IP地址后，因特网中所有匹配该前缀的报文段都会发往这个组织的路由器中。

在CIDR之前，IP地址是按小数点划分的，即8位、16位和24位。8位太小而16位太大，因此发展出CIDR能更加灵活。

有一个特殊的IP地址要提一下，即『广播地址』`255.255.255.255`，如果向这个地址发送报文段，同一个子网下的所有终端都会收到。

#### 获取一段地址集

就是向上级ISP请求分配。上级ISP必须有一个更大的地址集，例如`200.23.16.0/20`然后可以分配出`200.23.16.0/23`。

在最顶端，由『Internet Corporation for Assigned Names and Numbers (ICANN)』负责分配顶级IP。同时它也管理着顶级DNS根服务器，以及顶级域名的分配。

#### 获取一个IP地址

IP地址一般是手动注册到路由器中的，终端地址也可以手动，不过一般通过『Dynamic Host Configuration Protocol (DHCP)』来自动获取。我们称其为『即插即用式`plug-and-play protocol`』，它也是Client/Server模型的。

当一个新的客户端加入时，DHCP有四个步骤：

- DHCP服务器发现。客户端先发送一个UDP数据包，称为『`DHCP discover message`』，发往`255.255.255.255:67`广播地址并将源地址标为`0.0.0.0`。
- DHCP服务器提供。收到搜索消息后，服务器发回一个『`DHCP offer message`』，也通过`255.255.255.255:68`广播出去。为什么是广播呢？因为子网中可能有多个DHCP，客户端可以选择一个offer。每个offer包含会话ID、IP地址和有效时间，有效时间一般是几个小时或者几天。
- DHCP请求。客户端选择一个（或多个），发送`DHCP request message`
- DHCP确认。

#### 网络地址翻译 NAT

（译者简述）公网IP是很宝贵的，因此可以以路由器为单位共享一个IP。通过『网络地址翻译`network address translation` (NAT) 』机制，将局域网IP+port与公网IP+port进行转换，达到共享公网IP的目的。储存这个对应关系的数据结构称为『`NAT translation table`』。要注意的是，端口最多是65536个，最多只支持这么多个连接共用一个IP。

![2019-11-05-NAT.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-NAT.png)

NAT被广泛使用，但是在业内也有很多反对的声音：第一，端口号应该用作区分进程，而不应该用作区分终端；第二，路由器应该最多支持到第三层网络层（读取端口号是第四层的工作）；第三，终端之间应该直接对话，而不能被中间人篡改地址；第四，应该使用IPv6来规避这些设计上的缺陷，而不是使用NAT这种临时解决方案。

另一个严重的问题是，NAT让P2P程序无法定位。回顾一下，P2P应用需要客户端之间互相建立连接，如果某个位于NAT后面的终端A，发送了局域网地址给一个外部的终端B，那么外部的终端B无法使用这个局域网地址与终端A建立连接。

#### UPnP

全称是『通用即插即用`Universal Plug and Play`』。主要内容是，子网内的终端可以向NAT请求`(公网IP,公网port)`到`(私网IP,私网port)`的映射关系（自己弄清楚自己的公网地址），这样就可以支持P2P了。

### 4.4.3 网络控制消息协议 ICMP

回顾一下网络层有三个成分：IP协议，路由协议（4.6章节说），和ICMP。

ICMP是用来传递网络层信息的。比如，当你向另一个终端请求连接，而路由器无法解析这个地址时，路由器会给你发一个“Destination network unreachable”的错误消息。

ICMP经常被认为是IP的一部分，但从架构上来说它是在IP层以上的，因为ICMP消息是装在IP报文段中的。从接收方来看，也是通过多路复用分解来进行解析。

ICMP消息包含一个`type`字段和`code`字段，以及引发这个消息的IP报文段的头部。

|  ICMP Type  |  Code  |  Description  |
| :---: | :---:| :---: |
| 0 | 0 | echo reply (to ping) |
| 3 | 0 | destination network unreachable |
| 3 | 1 | destination host unreachable |
| 3 | 2 | destination protocol unreachable |
| 3 | 3 | destination port unreachable |
| 3 | 6 | destination network unknown |
| 3 | 7 | destination host unknown |
| 4 | 0 | source quench (congestion control) |
| 8 | 0 | echo request |
| 9 | 0 | router advertisement |
| 10 | 0 | router discovery |
| 11 | 0 | TTL expired |
| 12 | 0 | IP header bad |

大家都知道的`ping`程序，就是发送type-8-code-0的ICMP消息。基本上TCP/IP都在操作系统层面实现了ping服务端（即能够做出回复），而不是一个单独的进程。

之前还介绍过一个路径追踪程序，即查看本机到某个终端的途径节点。实现起来很简单，发送UDP包时分别设置TTL为1,2,3...当TTL耗尽时，该节点路由会发回一个ICMP警告信息。由此就可以得到途径的所有路由节点。

### 4.4.4 IPv6

从1990年代开始就在研究新一代IP协议，主要原因是32bit的地址区间开始枯竭了，顺便也解决一下其他的问题。

一个有趣的问题是，IPv5去哪里了？当时有个ST-2协议可能成为IPv5，不过它被废弃了。

#### IPv6报文段格式

```text
            <- 32bits ->
|-------------------------------------------------------------|
|Version(4)| Traffic class(8) |         Flow label (20)       |
|-------------------------------------------------------------|
|        Payload length        |  Next hdr    |  Hop limit    |
|-------------------------------------------------------------|
|                 Source address  (128 bits)                  |
|-------------------------------------------------------------|
|              Destination address  (128 bits)                |
|-------------------------------------------------------------|
|                           Data                              |
|-------------------------------------------------------------|
```

与前代相比，主要的不同是：

- 拓展了地址容量。从32bit拓展到128bit，意味着地球上每颗沙子都可以有独立的IP地址（笑）。除了单一地址和广播地址，还增加了『任意地址`anycast address`』，这允许发送到一个组里的某个任意终端（比如发送一个HTTP-GET请求到一个服务集群上）。
- 头部总长度为40bytes。丢弃了一部分可选参数。这可以让IP报文段的处理速度更快。
- 支持传输流标记与优先级。通过`flow`和`traffic class`字段来控制。
- 移除了碎片/重组。如果报文段太长，路由器会丢包并且返回一个ICMP告知发送端。
- 移除了校验和。因为上面传输层和下面连接层都有校验，不需要太多重复了。

字段说明：

- `Version`，数字6。
- `Traffic class`，8bit。`Flow label`，20bit。
- `Payload length`，头部后面的数据载荷的长度。
- `Next header`，上层协议是什么（TCP？UDP？）
- `Hop limit`，寿命，每经过一次路由转发减一。

相应地，ICMP也推出了新的ICMPv6协议，这次还将『网络组管理协议IGMP』的功能合并了。

#### v4到v6的过渡

一个简单的思路是设计一个『Flag day』，在那一天所有的终端和路由都重启并且升级到v6。上一次类似的操作是三十年前NCP过渡TCP，当时网络还很小，就已经很难操作了。

可能更现实的办法是引入『双栈节点`dual-stack nodes`』，同时支持v4/v6。并辅以DNS的帮助。

但这有一个问题，如果两个终端之间的路由路径上，存在一个v4节点，那么v6头部的信息就会被丢失。解决办法是『隧道`tunneling`』技术，即将要经过v4节点时，把v6报文段整个装进一个v4报文段中。

### 4.4.5 了解IP的安全机制

`IPsec`协议提供数据加密传输。它是面向连接的协议。传输层将数据发给IPsec，IPsec将其加密并添加一些额外字段，然后打包为一个普通的IP报文段。

- 加密协议。双方认同算法和秘钥。
- 载荷加密。
- 数据完整性。
- 数据源认证。

## 4.5 路由算法

一般情况下一个终端只连接到一个路由器，我们称其为『默认路由器』（或者第一跳路由器）。然后，发送端的默认路由器就称为『源路由`source router`』，接收方的默认路由称为『目标路由`destination router`』。端到端的问题就简化为源路由到目标路由的问题。

路由算法的问题也简单：给定一个路由网络，寻找两个路由之间的“好”路径。我们用一个**图**（数据结构）来表示这个模型，其中，节点是路由器、边是路由器之间的物理连接。每条边上有一个值代表连接的成本，假设这个成本是已知的。

![2019-11-05-graph-model.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-graph-model.png)

任意两个节点之间会有多条路径，其中会有『最小成本路径`least-cost path`』。至于算法，有两种：

- 『全局路由算法`global routing algorithm`』掌握了网络中所有连接的状态来进行计算，这也称为『连接状态算法`link-state algorithms`』。
- 『分布式路由算法`decentralized routing algorithm`』，就是从邻居开始递归地计算最低成本路径。

算法也可以分为静态算法/动态算法，也可以分为带宽敏感/带宽不敏感算法。

### 4.5.1 连接状态路由算法 LS算法

要获得每个节点的连接状态，需要每个路由器都将它所有的连接状态进行广播。结果是，每个节点都知道整个网络的状态，并且能独立进行计算。

下表结合上面的图来查看。核心思想就是，遍历每个节点，然后保存出发点到每个节点的最短路径长度，然后不断寻找最小的那个。

![2019-11-05-LS-algo.png](https://saodd.github.io/tech-blog-pic/2019/2019-11-05-LS-algo.png)

（译者注：下面还有一些算法上的讲解，不展开了）

### 4.5.2 距离向量算法 DV算法

这是我们现在实际中使用的算法，具有迭代、异步、分布式的特性。它的异步体现在，它从邻居那里获取一部分数据进行计算，然后将结果发回给所有邻居。它的迭代性体现在，如果邻居那里没有新的数据了它就阻塞了（停下了）。它的异步性体现在，它不需要停下任何操作，可以一边计算一边服务。

（译者注：算法细节跳过，感觉应该工作中用不到）

#### LS和DV算法的比较

DV算法中，节点只跟相邻的节点通信，并提供自己到已知所有节点的最低成本路径估计。在LS算法中，每个节点通过广播获取所有节点的信息，但是信息只包含自己的连接的成本。

- 消息复杂度。每次连接成本改变，LS要通知所有节点，DV只通知邻近节点（并逐步扩散，译者注）。
- 收敛速度。LS是平方级算法并需要`节点数*连接数`个消息数。DV收敛得更慢，也存在无穷计算问题。
- 可靠性。LS每个节点都是自己计算的，因此就算某个节点故障了，其他节点的计算不受影响。DV相对容易被攻击。

#### 其他路由算法

（略）

### 4.5.3 多级路由

在现实中往往有一些额外的需求：

- 拓展性。世界上有几十亿台终端，如果要把他们都当做节点来计算路径的话，代价无法承受。
- 自动管理。企业或者网络提供商需要按照意愿来方便地管理。

因此有了『自治系统`autonomous systems` (ASs)』，每个系统由一组路由器组成，通常处于相同的管理控制下。同一组内的路由器运行相同的算法并且知道彼此，这个协议称为『自治系统路由协议`intraautonomous system routing protocol`』。当然，一组里有个别路由器要承担与外部通信的工作，我们称其为『网关路由器`dateway routers`』。

在组与组之间，通过『跨组路由协议`inter-AS routing protocol`』来交换数据，因特网中的是`BGP4`。

（译者注：这部分也离开发者太远了，略过）

## 4.6 因特网中的路由

（跳过）

## 4.7 广播和多路传送

『广播`broadcast`』是将数据包发给网络中的所有节点，『多路传送`multicast`』是将数据包发到另一个网络中的一些节点中。

（跳过）

## 4.8 小结

我们知道了，网络层协议是涉及到每个终端和路由的，因此它非常的复杂。

路由器负担很大，因此设计网络层时尽可能地将路由器的工作简化。减负思路主要有，用报文段比虚拟电路好；用固定长度头部（IPv6）更好；抛弃碎片和重组的功能（IPV6）；只提供尽力服务等。

然后学了路由算法。（译者注，这部分没有详细看）算法的核心目标就是计算最小成本路径。算法主要分为中心化算法和分布式算法，现实中使用的是分布式算法。为了优化计算成本，推出了AS的概念来给路由器进行分组。

接下来要学习连接层，它的任务只是在设备内部进行搬运的操作，看起来没有网络层协议那么重要。不过它依然有很多重要并且迷人的问题等待我们发掘。
