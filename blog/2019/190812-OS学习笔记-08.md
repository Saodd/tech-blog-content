```json lw-blog-meta
{"title":"OS学习笔记08：CPU虚拟化的上层实现-多级反馈队列","date":"2019-08-12","brev":"上一章介绍了几个理想状况下的调度器算法，现在说一下在现实复杂情况下的调度器算法。","tags":["OS"],"path":"blog/2019/190812-OS学习笔记-08.md"}
```



# 第八章 <CPU调度：多级反馈队列>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf)

这个设计的作者Corbato因此获得图灵奖。

`多级反馈队列MLFQ`试图解决两个问题：

1. 优化`周转时间`。但是前面一章分析了，OS并不知道每个任务的运行时间。
2. 优化用户交互，优化响应时间。前面一张分析了`RR`调度器会严重增加周转时间。

关键问题：如何在对任务一无所知的情况下进行调度？

> MLFQ调度器是经典的**从经验预测未来**的例子，（还有硬件层面的分支预测器和缓存算法都是类似）。当任务有一些特征的时候就可以进行预测，当然，这种算法也有可能会做出错误的决定。

## 8.1 基本规则 Basic Rules

MLFQ有很多实现，但是基本的算法是相似的。

MLFQ有一些不同的`队列queue`，分别被安排了不同的`优先级priority level`，每个任务只会存在于其中一个队列中。每次MLFQ会选择更高优先级的任务来运行；对于同一优先级的任务，使用RR算法来调度。

于是问题的关键就在于如何设置优先级。MLFQ根据任务表现出来的行为来调整其优先级。（比如某个进程频繁让出CPU并等待用户输入，就会被设为较高优先级；相反的，如果某个进程大量地使用CPU，就会被设为较低优先级。）

- 规则1：如果A优先级高于B，则运行A，不运行B
- 规则2：如果A优先级等于B，则用RR模式运行A和B

![Figure 8.1](/static/blog/2019-08-12-Fig-8-1.png)

## 8.2 尝试#1 如何改变优先级

- 规则3：当一个任务来到系统中时，被放在最高优先级
- 规则4a：如果一个任务用完了整个时间片，优先级降低
- 规则5a：如果一个任务没有用完时间片，优先级保持

### 例子1：单个长时间运行的任务

![Figure 8.2](/static/blog/2019-08-12-Fig-8-2.png)

### 例子2：中途来了个短任务

![Figure 8.3](/static/blog/2019-08-12-Fig-8-3.png)

### 例子3：IO型任务

![Figure 8.4](/static/blog/2019-08-12-Fig-8-4.png)

### 问题

现在我们已经有了一个基本的MLFQ调度器，但它还有一些问题。比如如果有太多的IO任务在上层队列，那么底层的任务可能永远无法拿到时间片（我们称它被`饿死starve`了）。
此外，用户可能会写一些特殊的代码来欺骗调度器，以长时间霸占时间片。
第三，在程序运行过程中，行为可能发生改变。比如CPU限定的任务可能在某个阶段突然就开始用户交互了。

## 8.3 尝试#2 提升优先级

一个简单的改进：

- 规则5：每经过一段时间S，把所有的任务都`推Boost`到最高优先级队列中。

那么，S为多长才合适？有人称其为`voo-doo constants`，因为需要一些黑魔法才能正确设置它。

## 8.4 尝试#3 更好的账单

如何应对欺诈调度器的罪行？对MLFQ中每一级中的任务所消耗的时间片，都`记录accounting`下来。

- 规则4：只要有任何一个进程消耗完了（当前级别对应的）时间片配额，那就要降级。

![Figure 8.6](/static/blog/2019-08-12-Fig-8-6.png)

## 8.5 调谐MLFQ

最大的问题就是上述提到的这些参数的取舍，包括：队列该有几级？每级应该有多少时间片配额？多长周期把所有任务提到最顶层？这需要经验来给出一个令人满意的平衡。

> 一般在OS中会有一些默认参数，如果你需要的话，也可以自定义。默认的参数可能是60级队列，最低级20ms到最高级几包毫秒，然后每1秒钟Boost(提升)一次。

可能有些调度器会有一些额外的特性。比如有的会给系统操作保留最高优先级；有的允许用户`自定义advice`（比如通过`nice`命令，还有类似的内存管理命令`madvise`和文件系统（预读和缓存））。

## 8.6 总结

总之，MLFQ是根据任务的行为来定义优先级的。目前主流的操作系统都是使用这个调度器模型。
