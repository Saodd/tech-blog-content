```yaml lw-blog-meta
title: OS学习笔记40：持久化：文件系统实现
date: "2019-09-03"
brev: 通过讲解一个简化版本的文件系统，来介绍文件系统到底是如何工作的。
tags: [OS]
```


# 第四十章 <文件系统实现>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf)

我们介绍一个简化版本的文件系统，这里我们称其为`vsfs`（即非常简单的文件系统）。

与CPU和内存虚拟化不同，我们并不需要硬件上的支持，我们通过纯软件来实现文件系统。但是我们也要关心硬盘的特性来优化性能。

**关键问题：如何实现一个简单的文件系统？需要怎样的数据结构、如何追踪、如何访问？**

## 40.1 思考方式

在学习文件系统的时候我们要考虑两个概念：

第一个是`数据结构data structure`，或者说，硬盘上用怎样的数据结构来组织文件数据与元数据？简单的形式就是数组（由硬盘区块组成的数组），精巧一些的有使用树的。

另一个概念是`访问方法access method`，如何将进程的访问（比如open，read等）映射到文件系统自己的数据结构上？执行调用的时候需要读取哪些数据结构？性能如何？

## 40.2 整体结构

我们限制来思考一下vsfs的数据结构组织方式。

首先我们要把硬盘分块，我们使用4KB的块大小。假设我们的硬盘只有512KB，即总共64个区块。

那么我们要把什么东西放在区块中呢？最重要的部分当然是`用户数据user data`，我们把储存用户数据的区域叫做`数据区data region`。为了简便起见，我们保留一个固定大小的区域作为数据区：

![Figure 40.1.1](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-1-1.png)

除了用户数据，文件系统要给每个文件都维护一些元数据。文件系统将这些数据保存在`索引节点inode`中。我们也保留一块区域来储存它，并把这部分硬盘区域叫做`索引节点表inode table`。

注意索引节点一般不大，假设每个节点需要256字节，那么一个4KB的区块就可以存放16个节点。在我们这个例子中，意味着最大能够持有大约80个节点。

![Figure 40.1.2](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-1-2.png)

我们还需要一个数据结构，来表示一个区块被占用了还是空闲着，我们称其为`分配结构体allocation structures`。有很多方法来保存分配信息，比如使用一个`空闲列表free-list`。这里我们简化起见，使用`位图bitmap`来表示，一个位图代表数据区，一个位图代表节点索引表。

位图用法非常简单，每一位代表一个区块的状态。你可能注意到用一整个区块来存放位图太浪费了，但是我们依然要使用一个完整的区块。

还剩最后一块，作为`超级区块superblock`，它保存着一些整体的信息，比如数据区有几块、索引表有几块、索引表从第几块开始等等。

![Figure 40.1.3](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-1-3.png)

因此，当挂载文件系统的时候，OS会先读取超级区块，初始化一些参数，然后将其加入目录树中。

## 40.3 文件结构：索引节点

`inode`是`index node`的缩写，是由于历史上节点都以数组的形式储存因此叫索引节点。

每个节点可以通过一个数字来访问（叫做`i-number`），这个数字就是文件的`底层名称low-level name`。通过这个数字我们可以很容易地计算出这个节点的数据体（在本例中是256bytes）在硬盘的什么位置：

![Figure 40.1.4](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-1-4.png)

计算的时候要注意，硬盘并不是按位存取的，硬盘的最小单位是`扇区sector`，扇区一般是512bytes。扇区与区块的计算公式像这样：

```text
blk = (inumber * sizeof(inode_t)) / blockSize;
sector = ((blk * blockSize) + inodeStartAddr) / sectorSize;
```

在节点内部，储存着关于文件的所有信息，包括：类型、大小、占用区块数、保护信息等等：

![Figure 40.1](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-1.png)

节点信息中如何表示数据区块的地址，是很重要的。一个简单的办法就是使用多个`直接指针direct pointers`来指向相应的硬盘地址。但是这种办法对大文件不行。

### 多级索引

为了指出大文件的硬盘地址，引入`间接指针indirect pointer`，它不直接指向用户数据区，而是指向一个含有多个指针的区块，以此扩大容量。因此，一个节点可能含有一些直接指针（比如12个）和一个间接指针。

举个例子，假如每个区块4KB，每个硬盘地址4bytes，那么一个间接指针可以指向4MB的空间。

如果不够，就在节点中设置2级指针，支持4GB文件，如果还不够，就3级指针，支持4TB！但是要注意，这种方式所产生的指针占用的空间也不少了。

很多文件系统都用这种索引方式，包括常用的Linux`ext2`和`ext3`等。

你可能会问，为什么不用其他的数据结构？长久以来，人们发现一个事实：绝大多数文件都是小文件，因此针对小文件进行优化是说得通的。比如前面说保留12个直接指针，就可以指向48KB的空间。

![Figure 40.2](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-2.png)

> 另一种节点设计方式是，将每个数据区块链接起来，即每个文件只记录首末两个区块的地址，中间由区块本身进行连接。这种方式能够节省一定的索引空间，但是会让随机访问变得困难。  
> 所以有的文件系统为了优化，不让数据区块本身保存下一个区块的地址，而是用一个单独的表来记录这些信息。这个表称为`文件分配表file allocation table`，这就是windows以前的文件系统FAT。

## 40.4 目录结构

前面说了目录其实也是一种文件，其中保存着文件名-索引节点编号的对应关系。索引节点号就是一个整数，而文件名是一个变长字符串：

```text
inum | reclen | strlen | name
  5     12       2        .
  2     12       3        ..
  12    12       4        foo
  13    12       4        bar
  24    36       28       foobar_is_a_pretty_longname
```

在删除文件时，会在目录文件中间产生一个空白区域（比如将节点号设为0）。那么此时reclen（记录长度）就有用了，可以让新的记录放在老的记录的空间上。

目录其实也被当作是一种『文件』，它在节点表中有位置，也有自己的数据区块。

## 40.5 空闲空间管理

当我们创建文件的时候，我们首先要申请一个节点。因此OS先要在节点位图中搜索一个空位，然后分配给这个新文件。然后在数据位图中搜索空位，分配给这个文件用来存放数据。

在这个过程中有一些优化。比如在ext2或者ext3中，创建文件时会给它分配8个连续的区块，这样可以保证文件有一大块是连续的，以此提升性能。

## 40.6 访问路径 Access Paths

### 读取文件

我们访问一个文件时，要从根目录出发，逐个目录寻找到目标文件。因此路径上的每个目录的节点数据都要被访问。但是找到目标文件之后，我们就可以直接对该文件进行读写，不需要经过上级目录了。

比如我们访问`/foo/bar`这个文件：

![Figure 40.3](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-3.png)

> 在绝大多数UNIX系统中，root的节点编号是2

找到目标文件后，文件系统会最后确认一下用户对于该文件的访问权限。然后把该文件的节点编号载入内存中，然后在进程的open-file-table中分配文件描述符，最后返回给用户。

open之后，每次read时，（可能会更新最后访问时间一类的东西，因此在上图中有对于节点数据的写入）就从硬盘中读取数据，然后更新进程中的打开文件表中的偏离值，以便于下一次read。

close很简单，只要释放掉文件描述符就好了，没有IO请求。

要注意的是，如果我们的路径越长（中间目录越多），那么open请求时就要访问越多的数据区块；但是如果把全部文件都放在一个目录里，那么每次在这个目录中搜寻可能也需要访问多个区块。

人生并不圆满，但是你会发现写入时的情况更糟。

### 写入文件

写入与读取基本相同，不过要多一个分配区块空间的步骤。

![Figure 40.4](https://saodd.github.io/tech-blog-pic/2019/2019-09-03-Fig-40-4.png)

**关键问题：可以看到每一个操作都伴随着复数个IO请求，如何减少请求的数量？**

## 40.7 缓存 Caching and Buffering

因此文件系统需要使用内存来缓存一些重要的硬盘区块。

早期的文件系统引入一个`固定大小缓存fixed-size cache`来保存常用的区块。之前介绍内存虚拟化时讲到有些政策可以帮助维持缓存（比如LRU）。

但是固定大小缓存会很浪费，因此现代系统使用`动态缓存dynamic partitioning`，并且与虚拟内存一起整合为`标准页面缓存unified page cache`。通过这种方式，物理内存可以很灵活地分配给虚拟内存或者硬盘缓存。

缓存对于写入也有很大的好处。首先可以`积累batch`一些写入请求一起发出；然后可以`规划schedule`写入请求的顺序；最后可以`避免avoid`一些无用的操作。

因此现代系统一般都有5-30秒的写入延迟来提升性能表现。缺点就是害怕系统崩溃！这是持久性与性能之间的妥协。

前面也介绍过了，如果某些应用要求立即写入，OS也提供相应的接口。

## 40.8 小结

我们介绍了构建一个文件系统的基础机制。

首先每个文件有一些额外的信息，称为元数据，储存在节点中。目录是一种特殊的文件，储存着文件名与底层文件编号的映射。

我们接下来还要学习一些政策层面的知识。
