```lw-blog-meta
{"title": "记一次面试的感悟", "date": "2019-07-22", "tags": ["Python", "杂谈"], "brev": "一次python岗位面试笔记"}
```

## 笔试题

笔试有12题左右，全英文（我也是用英文作答）。给的时间很充裕，不过到后面我虽然还有时间，却没有精力了。

前1/3是python的基础，后面是算法和底层实现的相关问题。

### Python基础

#### 1. 生成器

> 写一个简单的生成器，实现每次调用都会返回递增的Int。例：

```python
for i in your_answer(100000000000000000000000000):
    print(i)

# should print 100000000000000000000000000, 100000000000000000000000001 , ...
```

很简单的一题，唯一担心的是100000000000000000000000000这个Int会不会超过32位的限制，
因为我记得python3中的Int就是Int32。

不过再一想，我好像做过类似的实验，python对于特别大的数字并不需要另外处理（比如math包？之类的），
python应该会把它的底层全部封装好，编程人员并不需要考虑这种问题。

```python
def my_answer(n):
    while True:
        yield n
        n += 1
```

#### 2. 运算符

> 写出以下表达式的结果，并解释为什么：

```python
arr = [[None]*2]*3
print(arr)
```

也是特别特别特别简单的一题，不过小心有坑。

一开始我认为这只是考察**数组的运算符**嘛，没什么大不了的，于是写下了答案：

```
[None, None, None, None, None, None]
```

然后在写解释的时候反应过来，不对啊，内层和外层的乘号效果不同的，如下：

```
The 'None' is also an object, so '[None]' is a list with one element.
Thus [None]*2  ==> [None, None];
[[None, None]]*3  ==> [[None, None], [None, None], [None, None]].
```

对于简单的题目，要特别小心。

#### 3. 装饰器

> 使用装饰器，使得运行以下函数时，会打印出精确的执行时间：

```python

def run(a, b):
    ...
    return c

c = run(100,200)
```

装饰器在python的语法中算是进阶级的了，不过理解了它的原理之后，其实也是很简单的东西。

不过我尴尬了，因为我不记得`timeit`怎么用了，特别是参数的传递方式（我平时都是偷懒用`time`来计算运行时间）……

用`time`也就算了，关键还忘记了time到底是用那个方法来实例化……

于是我这样作答：

```python
import time

def dec(func):
    def _inner(*args, **kwargs):
        start_time = time.now()   # 应该是time.time()
        func(*args, **kwargs)
        duration = time.now() - start_time
        print(duration)
    return _inner

@dec
def run(a, b):
```

弱小，可怜，又无助。

事后查看文档，才知道`timeit()`函数是传入一个字符串……

```python
import timeit

def dec(func):
    def _inner(*args, **kwargs):
        g = {"func":func, "args":args, "kwargs":kwargs}
        duration = timeit.timeit("func(*args, **kwargs)", globals=g)
        print(duration)
    return _inner
```

可是输出的结果为什么是`0.11297069999999998`？这是什么单位？s？ms？ns？

查看文档发现

> then returns the time it takes to execute the main statement a number of times, 
> as a float measured in **seconds**.

居然是秒，我只写了一个简单的加法在里面，为什么需要0.1秒？然后我想起还有另一个参数`number`：

```python
def timeit(self, number=default_number)
```

```python
default_number = 1000000
```

Emmmmmm....好吧，那我们要继续改进一下：

```python
def dec(func):
    def _inner(*args, **kwargs):
        g = {"func":func, "args":args, "kwargs":kwargs}
        duration = timeit.timeit("func(*args, **kwargs)", globals=g, number=10000)/10000
        print(duration)
    return _inner
```

输出结果`1.094700000000004e-07`，还算是比较正常。

#### 4. 不知道考什么的一题

> 补全代码，使得会打印出数组中第3大的元素。

```python
arr = [random.random() for i in range(10000)]
```

一开始觉得，这是考察算法吗？快速排序？然后跟前后的题目对比一下，不对啊，
这题应该还是在考察python常用功能的熟悉度吧。

然后就写下了答案：

```python
arr.sort(asending=True)    # 关键字参数应该是reverse=True
print(arr[2])
```

我可真是个小机灵鬼 @_< 

不过这样作答我估计是过不了关的，但是因为没有时间（其实时间还有，不过没有精力了），
所以还是这样草草作答了。

其实写的时候还是考虑过性能的问题。如果我调用python内置的`sort()`方法，默认我估计应该是快排算法。
那么时间复杂度应该是`O(nlogn)`；

但实际上我可以使用三个变量保存最大的三个值，从头到尾遍历一遍，只需要`O(n)`的复杂度：

```python
def my_answer(arr:list):
    a, b, c = 0, 0, 0  # 储存第1，2，3大的数字
    for i in arr:
        if i >a:
            a, b, c = i, a, b
        elif i >b :
            b, c = i, b
        elif i >c:
            c = i
    print(c)
```

但是以上算法，还可以继续优化。因为它每次都跟老大比、跟老二比、再跟老三比，
虽然是`O(n)`但是线性系数会比较大`T(n) ~= 3n`。

所以我们可以让每个数字先跟最小的c去比，这样可以节省很多比较的次数：

```python
def my_answer2(arr:list):
    a, b, c = 0, 0,0
    for i in arr:
        if i > c:
            if i >b :
                if i >a :
                    a, b, c = i, a, b
                else:
                    b, c = i, b
            else:
                c = i
    print(c)
```

我们用前面写的timeit装饰器来对比一下性能：

```text
0.0006659739999999997   # 第一种算法
0.00019604999999999983  # 第二种算法
```

大概是3倍的性能差距，说明我的时间复杂度分析应该没错。

### 计算机基础

#### 5.6. 字典与哈希

> Python的字典是如何实现的？如果不知道，请你自己实现一个，用你所知的最好的哈希算法。

> 分析上一题中的算法的时间复杂度，考虑最优/最差/平均三种情况。

这两题凉凉，因为我对`哈希算法`只是知道一个原理，至于实现所需的最关键的`哈希函数`，
我脑子里只有关于它的问题，并没有关于它的答案。

特别是python的`Key`是任意对象的，这我想破脑袋也猜不出他是怎么计算的啊。

TODO: 以后找个时间专门钻研一下，另写一帖。

#### 7.8.9.10. 快速排序

> 快排的原理是：先找一个值作为参照`pivot`，然后把小于它的放在一边，大于它的放在另一边；递归求解。
> 那么，请你用画图的形式，逐步展现这个算法的执行过程。（选取`pivot`参照值的方法随便你）

> 写出代码，实现你在上一题所描述的快排算法。不用考虑性能，也不需考虑边界值问题。（使用python或者任意你熟悉的语言）

> 假设你所选取的`pivot`参照值，每次都能对半分开。分析你在上一题所写的代码的时间复杂度，仅考虑平均情况下。

> 假设你使用一台32位的电脑，操作系统限制你的`stacksize`为64kb，请分析你的代码是否会产生`StackOverflowError`异常。

这四题连锁……好吓人……

我记得快排的空间复杂度是`O(n)`，因为要申请一个相同大小的辅助数组，然后在递归中互相交换主辅地位，
是最佳解法。

> 去看了一眼快排算法回来，发现根本不是这样的……（泪奔

但是一方面我之前学快排的时候是用golang实现的，另一方面也的确记不太清它们是如何交换位置的了。

但是快排算法的原理我还是记得的，所以就写了一个**浪费空间版本的快排**，也就是每次递归都申请新的辅助数组。

然后在后面的分析中，直接承认我的代码实现的确有问题，然后描述应该如何如何改进。

至于python的内存堆栈模型，这个我之前看过一些帖子，但是没有很深入的了解。所以也只能胡乱答了一通。

TODO: 改天找时间，专门写一篇帖子研究一下。

#### 11. 巨大数组的排序

> 有一个文件储存了100GB的随机数字，你要对所有数字进行排序。而你只有一台4GB内存+1TB硬盘的老旧电脑。
> 请用伪代码或者直接用python代码描述你会如何做。

我的思路是利用文件系统储存嘛。

1. 把一个数字范围（比如最开始是minInt~maxInt）分割成100个取值范围；
2. 然后每次读取4GB大小的数字，把它们分配到这100个取值范围中去，
3. 把这100个取值范围中的数字**按一定命名规则**储存到硬盘中；循环2-3，直到读取完整个巨大的文件。
4. 检查所有生成的子文件中是否有大于4GB的，如果有，那么把它放入循环2-3中，继续分解；
5. 对每个子文件分别排序，这样它们**组合起来也是有序的**。

这个处理思路比较直接简单，感觉并不优雅。但是也没有接触过类似的案例，所以也不知道该如何评价。

不过至少是可以实现的吧！时间复杂度也不会太夸张，理想情况下（即数字均匀分布在数轴上）时间复杂度是`O(n)`，如果有局部的密集情况，可能会适当上升（即重新遍历大于4GB的子文件），但也不会太夸张。如果极端密集的话，那就必须要换一种算法了，不过我们现实中应该不会遇到这种实际情况比预期相差太远的情况。

### 笔试小结

#### 技术方面

**其实还是觉得没有发挥好**。

因为我昨天参加的笔试，回家后并没有搜索答案或者学习新的知识，
今天重新盘点一遍，感觉思路清晰了好多。

如果让我重来一遍，虽然还是有些题答不出，但我一定可以把我会的题答得更好。

此外，**这次笔试的经历也让我开阔了眼界**。

因为现在所在的公司，没有任何对于性能、并发数、稳定性的要求，故而没人会去关注算法和底层的实现；而我又很努力在自学，当我明显超过了同事们的水平之后，我就发现好像没什么要学的了，甚至产生了“python不过如此，我已经精通了”的想法。

经过这一次，我知道了在底层还有很多很多东西要学，如果是真想要当一个靠谱的后端，操作系统、内存模型这些东西是一定要知道的。所以也是让我重新找到了进步的方向。

> 不过我还是想吐槽一下，很多功能（比如异步高并发），我们用python实现并不理智。诚然，能在语言的限制下依然做出出色功能，是一个程序员强大的表现；但是我觉得避其锋芒，换一个趁手的工具（比如golang）是更加实际的选择吧。

#### 精神方面

其实在去的路上就感觉状态很差，有点昏昏的，可能还是因为平时生活压力有点大，导致我在个人精力管理方面还是不足的。

虽然这不是技能硬实力，但是也是很重要的软技能啊。在这方面还要多休息，调养。

## 面试

此前HR联系我时，只说了笔试，并没有说后面有面试。

虽然我多了个心眼，稍微准备了一些面试的东西，不过还是有些措手不及的感觉。

### 第一轮

来了一个小姐姐，很亲切。

看了我的简历，（果然）觉得很惊奇，然后围绕着展开了一系列家常：

 - “你以前是公务员啊？这么好，为什么不想干了？”
 - “因为兴趣？那你父母会不会伤心呀？”
 - “女朋友在这城市？是你来这城市的原因吗？”
 - “女朋友是做什么行业的啊？……奥，那也挺辛苦的哦，经常要出差？”
 - “为什么选择了python？”
 - “你喜欢跟机器打交道？你以前做‘综合文秘’需要很多与人打交道吗？”

之类的……

也问到一些技术上的问题，比如上一份工作主要做什么，团队情况如何之类的。

虽然还是有些紧张，不过还是有惊无险的结束了。

### 第二轮

来了一个小哥哥，气质比较沉稳，也是典型的程序员气质。
聊了一会知道，应该是teamleader之类的角色，应该是这次应聘职位的上司。

看了我的简历，（果然）也是从为什么转行聊起。然后转入技术问答，可能是照顾我资历较浅，也可能是考虑到这个职位本身也是初级职位，并没有问到很深。

 - “之前的工作主要做什么？有没有遇到什么印象深刻的难题？”
   - 我说没有遇到难题，遇到的都通过查文档看博客自己解决了。
 - “你说你重构了一个项目，写的比你前任好，那举例说下好在哪里？”
   - 这个问题真把我难倒了，倒不是我在吹牛，（我真的觉得写的比我前任好多了，总代码量减少一大半，调用链剪到最短，稳定性和可追溯性都大大提升）而是我真的没有在细节上对比总结过，我的代码到底好在哪。
 - “从数据库取数据并不慢才对……哦，你的意思是缓存？”
   - 我举个例子说之前的代码每次都从数据库里`select *`，然后我把它改成了在内存里copy。
 - “异步了解吗？socket了解吗？……那说说socket有几种异步模型”
   - 我了解一些（的确是了解了一些asyncio，aiohttp库，但是没有亲手练过），但是对于**异步**这个概念的定义一直没有去挖掘和总结，所以解释不清楚。
   - 所以就转移话题，说异步一般用在IO密集型的并发操作上，比如爬虫。
 - “那多线程了解吗？多线程用哪个库？怎么实现爬虫？”
   - treading库还是很熟悉的，说了下Thread，Pool
 - “用队列传递任务？嗯，这是线程间通信。”

技术上主要就是这些问答，越问越没有信心了，好在多线程，爬虫我是很熟悉的，找回了一些自信。

然后聊了下这个职位相关的：

 - “最近要根据需求，写一些前端的代码”
   - 我：前端，毛问题啊，我会
 - “比如用c#，VB实现”
   - 我（内心os：哭）：VB我学过，之前用它写过游戏外挂；c#没有接触过。
 - “你现在这个水平，不是打击你，只是个初级水平”
   - 我（点头）：是的，我是初级水平。
 - “我们更看重学习能力，你至少比那些不愿学新东西的老油条好多了”
   - 我（拼命点头）：学习能力我是有自信的，我平时是如何如何学习的。
 - “那你期望的薪资是什么水平？”
   - 我：这个，我还需要了解其他的福利情况……那我的预期是XX左右
 - “还有什么问题吗？关于我，或者同事，或者公司，别紧张，我们是平等的”
   - 我（内心os：我真的没有问题啊，我随遇而安的……）：公司所有人都在这里吗？主要有什么业务？后端主要的技能栈是怎样的？您是什么样的经历背景呢？

然后就回家等消息了。

## 总结

这家公司总体还是挺好的，小客厅里两台对开门冰箱，还有三国杀，电视，生活气息很足。最邪恶的是居然还养了两只猫，让我顿时就感觉猫瘾要犯了。

唯一美中不足的是技术栈是`java+python`，而我理想的是`go+python`，对我来说可能就没有在项目中学习golang的机会了。

最大的收获还是让我明确了下一步学习的方向。

明确方向后，最大的感触就是让我第一次有“终于追上这个行业的边缘”的感觉，而不再是以前那样总感觉徘徊在行业大门之外的心态了。

努力终会有回报，继续加油~
