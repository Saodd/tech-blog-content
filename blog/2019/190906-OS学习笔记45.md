```yaml lw-blog-meta
title: OS学习笔记45：持久化：数据完整性与保护
date: "2019-09-06"
brev: 校验和的实现与应用。
tags: [OS]
```


# 第四五章 <Data Integrity and Protection>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/file-integrity.pdf)

文件系统如何在设备并不完全可靠的情况下，确保数据的安全性？

**关键问题：如何确保数据完整？如何保证写入的数据是受到保护的？需要怎样的技术、技术的代价如何？**

## 45.1 硬盘错误模型

在学习RAID的时候，把硬盘看作一个整体，要么整个硬盘都正常工作，要么整个都坏了。这种`fail-stop`模型非常简单。

但是还有一些另外的硬盘故障。比如硬盘可能绝大多数区域都正常，但是个别区块故障。详细的说，就是`潜在扇区错误latent-sector errors (LSEs)`和`区块腐败block corruption`。

LSE一般发生在某个扇区被破坏的情况下。比如磁头撞击磁盘，比如宇宙射线的破坏。我们可以通过硬盘内部的`错误修复代码 (ECC)`来识别并修复它们。

但是还有另一种情况，区块腐败了，这种情况是硬盘设备本身不能识别的。比如固件中有个bug，把区块写到了错误的扇区中；或者客户端传输数据时使用了错误的通道，从而写入了错误的数据。

有人将这种状况称为`部分故障fail-partial`模型。这种情况一般很罕见，根据一项（3年，150万块硬盘的）调查显示，买个好点的硬盘可以降低故障概率~

```text
            Cheap   Costly
LSEs        9.40%   1.40%
Corruption  0.50%   0.05%
```

这项调查还有一些结论：

- 有LSE故障的硬盘，继续发生LSE故障的可能性同样很高。
- 在第二年发生故障的概率最高；
- LSE故障的数量与容量成正比。
- LSE故障的数量一般不超过50个。

+ 使用不同的驱动，会显著影响腐败发生的概率。
+ 年龄效应在不同的硬件模型上是不同的。
+ 工作负荷或容量，对腐败几乎没有关联。
+ 腐败一般数量极少。
+ 腐败并不是独立存在的。
+ 腐败与LSE几乎没有关联。

## 45.2 处理LSE

LSE很容易处理，因为它很容易被侦测（根据定义）。当文件系统访问区块而硬盘返回错误时，文件系统就使用任何所拥有的冗余手段去应对就可以了（比如RAID）。

但是有个问题：如果整块硬盘故障与部分硬盘故障（LSE）同时发生会怎样？比如，当RAID中某块硬盘完全故障了，此时要进行`重建reconstruct`；重建过程中可能会发现LSE问题，那么重建就会失败。（这是可能的，因为LSE其实是要侦测才会被发现的，因此平时可能隐藏在健康的硬盘中）

一种办法就是再加一层冗余！

## 45.3 侦测腐败：checksum

腐败的恢复机制也是同样的：你必须要有一个副本！

我们看一下如何侦测。称为`校验和checksum`，它其实就是一个函数，输入一个区块的数据（比如4KB），输出一个小的校验和（4或8字节）。

有很多函数可以用来计算校验和，它们在长度和速度上有所区别。一般需要这样的权衡：保护地越好，保护地越慢。

一种简单的函数是基于`排他exclusive`（或者`异或XOR`）的，即将所有的数据进行异或计算，得到一个结果。举个例子，我们将16字节的数据输入，得到一个4字节的校验和：

```text
// 源数据
365e c4cd ba14 8a92 ecef 2c3a 40be f666
// 源数据的二进制
0011 0110 0101 1110 1100 0100 1100 1101
1011 1010 0001 0100 1000 1010 1001 0010
1110 1100 1110 1111 0010 1100 0011 1010
0100 0000 1011 1110 1111 0110 0110 0110

// 校验和
0010 0000 0001 1011 1001 0100 0000 0011
```

这种算法很简单，但是也有明显缺陷：如果同一个位置上的两个bit同时错了，那么校验和依然是正确的样子。

还有基于加法的校验和函数。还有`Fletcher checksum`，基本思想是用两个加法来计算，`s1=(s1+Di)%255`和`s2=(s2+s1)%255`（其中`Di`是数据块中的每个字节，循环相加），这种算法很快，并且强度非常高。

最常用的是`循环冗余校验cyclic redundancy check (CRC)`，基本思想是将给定的数据区块视作一个巨大的数字（其实就是二进制位的组合），用这个巨大的数字除以一个约定俗成的数字k（当然不能直接除，要实现一个巨大数字的除法算法），得到的结果就是CRC校验和。这种算法很快，在网络应用中很流行。

当然，不会有完美的校验和算法。两个完全不相同的区块，却拥有相同的校验和，这种事情是存在的，称为`冲突collision`。选择一个良好的算法，尽可能减少冲突就行了，特别是针对在常见的故障情况可用就行了。

### 校验和布局

那么我们把校验和放在那里？

记住，我们的校验和是针对区块的，区块一般是4KB而校验和一般是8bytes。一种基本的思路是将其放在每个区块的前面：

![Figure 45.1.1](https://saodd.github.io/tech-blog-pic/2019/2019-09-06-Fig-45-1-1.png)

但是！校验和是由软件层面计算的（文件系统），而硬件上的最小操作单位是扇区（一般是512byte）。所以我们汇集一下，把n个区块的的校验和写在一个扇区中（区块是4KB，扇区是512B），一个校验和扇区后面跟着n个区块即可。

![Figure 45.1.2](https://saodd.github.io/tech-blog-pic/2019/2019-09-06-Fig-45-1-2.png)

但是这种方式效率比较低，因为更新某个数据区块的同时，又要同时更新另一个校验和扇区。

## 45.4 使用校验和

使用很简单，读取某个区块的时候，同时也读取相应的校验和扇区，校验一下就好了。

那么如何恢复呢？如果有冗余的话，一切好办；如果没有，那就没有办法了。

## 45.5 新问题：写错地方

上面的解决方案，对于这个问题毫无办法：写错地方。即正确地写入了数据，但是写错了地方！

解决办法就是，给每个校验和增加一点额外地信息。称为`物理ID`（physical identifier）。

这带来了冗余，但是并不奇怪，因为冗余才是解决故障的唯一办法。

## 45.6 新问题：没写入

即，硬盘设备通知上层文件系统，写入已经完成了！但是实际上并没有写入。

一个办法就是，`写入验证write verify`或者叫`写后读read-after-write`，但是这样会增加IO负担。

## 45.7 Scrubbing

什么时候校验和会用来校验？

首先在被应用程序访问的时候会校验。但是多数文件可能很少被访问，因此很少被校验。
因此使用`磁盘清理disk scrubbing`工具来全盘扫描一遍。

## 45.8 校验和的性能损耗

空间负担比较小。一种是在硬盘上的，用于存放校验和，大约0.19%；另一种是文件系统所使用的内存，因为校验之后马上丢弃，因此也可以忽略不计。

时间损耗比较明显，因为CPU必须要计算校验和。现代系统一般将复制和校验两个过程结合在一起，以此稍微减低一点点损耗。

出了CPU时间，其实还有额外的IO时间。可以通过设计来减少（比如缓存整个磁道的数据）。

## 45.9 小结

主要讲的是校验和的实现和应用。这与硬件的发展是密不可分的，新的硬件会有新的问题，但也许会解决旧的问题。
