```lw-blog-meta
{
"title": "LeetCode[60]: 第k个排列",
"date":  "2019-12-13",
"brev":  "标签：数学。中等难度。",
"tags":  ["算法与数据结构"]
}
```

## 读题

```text
给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。

示例 1:

输入: n = 3, k = 3
输出: "213"

示例 2:

输入: n = 4, k = 9
输出: "2314"

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutation-sequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 分析

粗暴的想法就是枚举法，之前有做过`LeetCode[46/47]: 全排列 I/II`，我们只要逐个遍历地去找到那个排列就可以了。但是这样做的话，时间复杂度就太可怕了。

思考一下全排列的数学特性。假如`n=4`，我们有`[1,2,3,4]`四个元素。先选出1号位，假如是`1`那么2-4号位有`3!`种排列；然后1号位换成`2`，那么2-4号位有`3!`中排列；因此一共有`4*3!`种排列，也就是`4!`。

那么，给出一个任意的`k`，它会落在`4*3!`的哪个区间段内？——答案是第`k/(3!)`段内。我们举一个例子，假如`k=6`，那么`k/(3!) == 1`，意思就是落在了第二段，把`2`放在一号位的那一个区间里。

搞清楚了这个，接下来只要逐位递归就好了。

## 实现

```go
func getPermutation(n int, k int) string {
    // 先把所有元素生成
    var nums = make([]byte, n)
    for i := byte(0); i < byte(n); i++ {
        nums[i] = i + '1'
    }
    // 因为n, k 都是从1开始计算，因此把他们都减掉1
    n--
    k--
    // 逐位做除法，找出k落在哪一段
    var fac = Factorial(n-1)
    for i:=0; i<n; i++{
        upInsertBytes(i, i+k/fac, nums)
        k = k%fac
        fac /= (n-i)
    }
    return string(nums)
}

// upInsertBytes 把ori位置的元素前移到tar位置，中间的元素相应后移一位。
func upInsertBytes(tar, ori int, bs []byte)  {
    temp := bs[ori]
    for i:= ori; i>tar; i--{
        bs[i] = bs[i-1]
    }
    bs[tar]=temp
}

// Factorial 负责计算n的阶乘
func Factorial(n int) int {
    if n < 1 {
        return 1
    }
    var result int = 1
    for ; n > 1; n-- {
        result *= n
    }
    return result
}
```

时间复杂度只与`n`相关，因此性能是很高的。但是在元素前移时会提高复杂度，最坏情况`n^2`（即每次要后面所有元素移动一遍），最好情况`n`（每次都不用移动）。

提交成绩：

```text
执行用时 :0 ms, 在所有 golang 提交中击败了100.00%的用户
内存消耗 :2 MB, 在所有 golang 提交中击败了78.38%的用户
```

测试用例略。

## 其他思路

本算法的性能瓶颈是对数组做插入操作。

一个思路是使用链表。即，把元素排列数组`[1,2,3,4,5]`改成链表`1->2->3->4->5`。但是并不能解决问题，因为链表要找到第n个元素是要从前向后遍历的，在循环中使用依然会带来`n^2`的复杂度。

还看到别的解题思路，用回溯法。的确，其实拿到题目的第一个想法就是回溯，但是感觉性能并不高、表达效果可能也一般，就没有选择这个算法。
