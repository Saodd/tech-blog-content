```lw-blog-meta
{"title": "记十一月面试的感悟", "date": "2019-11-02", "tags": ["杂谈"], "brev": "整个10月写的博客很少，因为这段时间为公司项目操心了很多，但更重要的是又接近了一个瓶颈区，需要一些新鲜的刺激才能让自己保持最高的前进速度。"}
```

## 面试概况

两家职位都是Web/App后端，一家偏重golang另一家偏重python。

我目前是一年Python工作经验，但是在业余时间学习了很多很多。面试发挥表现总体来说还算正常，都发挥出了八成左右的水平。

## 问题归纳

还记得几个月前的上次面试，对方很看重生成器/协程、异步、并发相关知识，我补习几个月之后感觉良好，但是这次面试又问到了另外的领域，有一点点措手不及的感觉。

心里可以抱怨一下『在项目中没有遇到类似场景』，不过说到底也只能怪自己还不够『精』，因为『精==深+广』啊。

### 1.Python协程是什么

回答问题一定要先审题，不要想太多。当我被问到这个问题的时候，直接就想到协程用于异步调用的场景，想多了。

其实，协程的本质只是一个用户态内的执行单元，由程序（员）来控制上下文和调度。

或者拓展一下，可以认为协程是一种『闭包』，闭包的概念就是将函数中的变量的生存周期独立于函数以外，协程的实质就是将上下文保存了下来独立于函数的生命周期。

不过话说回来，问到协程的时候也可以认为就是在问协程在异步的应用。不过多一步递进的话，可以让自己的思维逻辑更顺滑，减少一些回答的压力。

### 2.Python与Golang的协程区别

实质上是在问异步模型的区别。

Python的异步模型是基于『事件循环`eventloop`』的，其本质是异步阻塞（或称多路复用），每个协程都要主动交出控制权，回到eventloop才能继续执行。表现在代码中，就是每个地方都要`async/await`，而且具有传染性，任何一处的同步调用都会破坏异步模型；这意味着很多流行的同步调用的库都不能用在异步的环境下。

Golang的异步模型是基于调度的，当一个Go程阻塞时（比如调用了阻塞的systemcall），『运行时`run-time`』会自动将同一个线程下的其他Go程移到其他可用的未阻塞线程上。表现在代码中，就是我们在用同步的方式写异步代码。

> Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently executing functions—coroutines—onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they won't be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: they have little overhead beyond the memory for the stack, which is just a few kilobytes.  
> To make the stacks small, Go's run-time uses resizable, bounded stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isn't, the run-time grows (and shrinks) the memory for storing the stack automatically, allowing many goroutines to live in a modest amount of memory. The CPU overhead averages about three cheap instructions per function call. It is practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.  
> 来自官方[FAQ](https://golang.org/doc/faq#goroutines)

关于异步并发模型，我还是那个观点，如果服务端应用很在乎并发量的话，真的应该考虑用golang去重构python代码。一方面python的异步调用写法还是相对复杂的，没有很高的熟练度很难写出完美的异步调用链；另一方面，现在都流行微服务，将并发量很高的服务独立出来也是顺应发展趋势的，配上docker进行扩容那才是犀利。

### 3.Mysql与Mongo的区别

持久化数据库的选择，对于互联网企业来说，肯定是Mysql和Mongo之间去选择了。前者是传统的关系型数据库，表现为我们最熟悉的二维表格模型；后者是非关系型数据库（NoSQL）之一，表现为每一行都是一个类JSON字符串（BSON）。

在使用上的区别，Mysql需要提前建库建表，更改字段要用alter命令并且会对整张表生效；而Mongo可以任意地修改字段。

Mongo索引是`B-树`，是平衡查找树的变种（针对硬盘IO的优化），即在一个节点上储存多个键-值对（回忆一下2-3树就是储存1个或者2个键，B树就是储存更多键），因此整个树变得更矮胖，因此减少了检索的节点个数（即IO次数）。

Mysql的索引是`B+树`，是在B-树的基础上进一步发展，非叶子节点只存放键，而值只放在叶子节点中并且以链表形式连接起来。这样方便建立更多索引，最重要的是有利于批量查询（比如查询`id between 1 and 1000`）。

非关系型数据库因为舍弃了关系型数据库的ACID约束，比喻来说就是“轻装上阵”，在性能上有不少的提升。（关于ACID具体实现我不太清楚，这个课题也很大，另外找时间研究。）另一方面Mongo设计时就考虑分布式拓展（在ObjectID中就包含了机器信息），更容易拓展也意味着更高的并发性能。

### 4.Mysql的优化

优化首先考虑索引问题了，不再重复了。

还有Mysql的引擎，我知道主要是两个引擎——`MyISAM`有利于查询，`InnoDB`支持事务。其实可以多说一句，主从分离时主库用InnoDB，从库用MyISAM。（关于两个引擎更细节的差别，另开一篇文章研究）

还问到如何分析SQL语句的性能？我说用`explain`语句，然后关注`row`那一列，即主要关注是否命中索引。其实explain输出的内容很多，还有很多可以挖掘的内容。

### 5.Python面向对象编程

一直知道有所谓面向对象、面向过程编程，在研究Pandas库的时候也见识到了很多的面向对象设计思路，也听说过（甚至还学过一些）所谓设计模式。但是在我的概念里似乎一直认为这只是一种**思想**，并没有太多具体实现的地方。

另一方面，我全盘接受了Golang的设计哲学，接受了那一套面向过程编程的思想，在写Python的时候习惯在类里写静态方法、用`def get_client()`这种形式来实例化对象。

当我被问到：修改子类成员变量是否影响父类成员变量？实现一个单例模式？这类问题时，才意识到这是我很大的一块知识盲区。或者说，意识到我对Python的掌握程度还是不够全面，还是存在短板的。不过这也是我这次面试收获最大的地方——被难倒的地方就是收获最大的地方，面试的意义就在于开拓视野。

有关Python类与对象的内容，也是一个很大的课题，另开一篇文章研究。

### 6.Python引用传递方式

问题很简单，Python是传值还是传引用？

我知道Python一切变量都是对象，但是还欠缺一些深入；甚至我还记得一些“小对象”是“传值”的，而“大对象”是“传引用”的。甚至可能因为Golang学太多了，跟Python的概念有些混淆了。现在重新梳理一下。

其实问题的核心在于：对象是『可变对象』还是『不可变对象`immutable`』。我印象中的“小对象”其实就是不可变对象，当对不可变对象重新赋值时，其实是让这个**变量**重新指向了**新值的对象**，因此表现为『传值』。而“大对象”，比如数组，它是可变对象，因此对其修改时，会对底层对象直接生效，因此表现为『传引用』。

其实是一个并不难的概念，只是没记清楚细节、只记得表现，所以在面试的时候给出错误的答案，还是挺糟心的。

这也是为什么我更喜欢Golang（静态类型语言）的原因，指针就是指针、值就是值，非常的清晰。

### 7.操作系统

我在学习OS的时候写了很多**篇**翻译笔记，因此OS的内容特别显眼；面试官也有针对性地提问了：讲讲硬链接和软连接的区别？

这个部分因为平时很少涉及到，所以说实话，学完就忘了，要我作答的话还是需要再复习一下。之前面试准备时也没想到会问硬盘啊，而且在我的印象里，硬盘无非就是那些IO延迟的特征，所以的确没有花时间去复习。没能答上来。

现在复习一下：硬链接相当于是**给一个对象设置了另一个引用**，相应地，在删除文件时内核中并没有`remove`方法而只有`unlink`方法，当引用计数归0时就自然成为了垃圾数据（根据硬盘区块索引的特性，没有指向数据区块的指针的话，那么该区块就会被当做可用区块，相当于被回收了）设置硬链接时，会在目录元数据中写入指针信息（索引节点号）。

而软连接只是一个肤浅的快捷方式，只记录着目的地的路径字符串，注意是路径字符串而非底层的硬盘区块编号，没有任何的约束，因此当目标文件删除或移动时，该软连接也就无效了。

然后问：选择你熟悉的部分简单讲讲操作系统？

这个问题实在太宽泛了，CPU、内存、并发、硬盘太多内容了，纠结了好一会儿没能理清头绪，那就从最开始的CPU虚拟化部分讲讲吧。就讲了一下进程、线程、协程的区别。

这个提问也是给我敲响了警钟，对于学过的内容，还是要多加复习，因为面试中『忘记了』与『没学过』没有任何区别。同时也要注意**总结**，将学过的知识要建立体系。

### 8.网络

本以为网络就是HTTP/TCP/IP三个主要协议嘛，要不就问问HTTP的结构，要不就问问TCP和UDP的区别，TCP那么多可以问的呢，可靠传输、拥塞控制、长连接短连接，我都能答，为啥不问呢~

万万没想到：HTTP与HTTPS的区别？

虽然我的网站是申请了证书，并通过Nginx转化为HTTPS协议与外界通信，但是我知道的也就只有『将HTTP消息加密后发送』这点了哈哈哈。这部分内容是最近正在看的网络教材的后部分章节，暂时还没有学到。

现在学完了再答一下。HTTP是应用层协议，HTTPS是在它的下面加了一层SSL层（SSL下面是TCP）。客户端建立连接后，服务端会将证书发给客户端，其中包含服务端的公钥。客户端与服务端通过公钥加密通信，随机生成一个会话秘钥，会话秘钥一般是对称加密算法（AES或者DES），之后的数据传输都通过会话秘钥进行加密。

从底层向上看，SSL层被划分在应用层，因为SSL是装在TCP报文段内部的（也就是说，是TCP的上层）。从上层向下看，SSL更像是传输层协议，因为SSL提供与TCP相似的套接字接口。总之是介于二者之间的安全服务层。

### 9.前端

因为职位是后端工程师，所以前端只被问到一点点。比如js是单线程吗，你用js能做些什么之类的基本问题。不过其实我能做的都在网站上反映出来了，F12看一看就知道我的水平。

### 10.Docker

Docker也只是简单问了一些，比如k8s有没有了解？我说了解过，但是实在没有应用场景，所以没有实践过，我只用Docker-swarm。然后问Docker-compose用过吗？我说用过，就是单机版的，使用体验不如swarm。

如果是真的用k8s进行大规模部署的，肯定会有专职的运维岗来负责这些。作为后端工程师，在这个角度上其实是位于前端和运维之间的位置，所以我的观念就是了解、会用即可。

当然，Docker涉及很多系统底层的东西，要做性能优化的工作去学学Docker的源代码一定会受益匪浅的，在我的规划中，过几个月我会开始读Docker源码。

### 11.代码规范

令我有点意外的是两家公司都问了我代码规范的问题。

Golang当然没有问题，因为多数工作都被`go fmt`强制执行了，而且Golang的语言哲学就是『一个功能只用一种语法来实现』，所以只有少数问题直接参照官方文档就好了，不需要特意强调。

最麻烦的当然是Python，我说我主要（在团队中推广）遵循PEP8，但不完全遵循，留有一定的余地。（比如单行最大宽度80字节就太小了，现在都流行120吧）比如最重要的是命名规范，然后是注释规范。

其实我个人观点是，选择一个好的IDE（强烈安利Jetbrains全家桶），每一行代码都尽量按照IDE的提示去做，自然而然就能养成良好的代码习惯了。要靠自己一点一点去学习规范的话，太低效了。

### 12.架构

简单描述一下架构，说说为什么这样做。

### 13.Redis

Redis的数据类型？五种。

什么时候用Redis？存放热点数据。

Redis的持久化？只知道可以持久化，可以设置频率，并且是异步的；不清楚还有区别。（查了一下，一种是定时保存，另一种是逐条保存）

### 14.Linux

列举你常用的Linux命令？

平时用的太多了，只能是想到一个写一个，大概列出了十来个才停手。什么ls cd mkdir简单的就不说了，相对高级一点的有top service ifconfig netstat telnet crontab export，当时大概写了这些吧。

现在再想想还有mount sudo-u bash-c apt/yum find grep/sed/awk tar who whereis uname df/du ssh/sftp vim vi free kill/nohup/fg/bg/jobs chmod/chown man echo/cat/tail/less wget 哇塞太多了，全都用过，只不过一下子想不起来。如果问题是问某个功能用什么命令的话，我一定可以全部列举出来。

不过再冷静想一下，其实自己也可以有逻辑性地、按照功能分组来列举。比如可以分类为状态与服务、文件目录相关、搜索、字符串处理、权限、网络等，这样作答应该就比较完美了。

### 15.算法

本来预期算法最多就让手撸个快排算法呗，没想到问了个链表的问题。没想出最佳解法，就说了个暴力法。

这也让我发现一个问题，我对高级数据结构（链表、树、图）还是有些生疏，看来在Leetcode上做题不能按顺序做，前面的题大多是关于数组的，花哨有余实用不足，完全可以跳过。

## 总结

总结一下，这次面试中发现的问题有：

- [x] Python面向对象相关
- [x] 继续学习网络
- [ ] Mysql引擎与优化
- [ ] 关系型数据库ACID的细节
- [ ] 高级数据结构的算法，各10题吧
- [ ] 架构理论知识

2019-11-22更新，又面试了几次：

- 进程间通信？fork()到底复制了什么？
- Python的栈里包含什么内容？
- Django怎么用异步IO？
- Python计算性能瓶颈的优化？Python哪些解释器没有GIL？
- k8s真的要找机会了解一下了
- 算法解题常用策略，要总结一下

2019-12-02更新：

- Golang常见的并发模型？（不熟悉并发模型这个概念）
- Golang会内存泄露吗？用什么工具来检查？
- Golang的Channel的实现原理，详细？
- （代码题）Golang数组与切片的区别？
- （代码题）给定一个Python字典，其中保存着某只股票的时间-价格数据。写一个函数，求一买一卖的最大收益。

## 后记

秋意渐凉，我又掏出了长袖衬衫。看着衣橱里随我征战多年的衬衫，感慨万千。

每次面试，一定免不了的话题就是——你为什么要转行？

是啊，为什么要转行？

刚毕业那会儿真是意气风发，年纪轻轻以最优成绩考入厅级单位核心部门，每天伺候着厅级领导，处级干部就是直接上司，隔三差五就出差调研，以世俗眼光看来真是前途无限。

偏偏我却不走这金光大道，鼓起勇气裸辞回家，为这儿时起的兴趣投入刀山火海。有简单的前端测试我不做，拿起了厚厚的Python教程要钻进行业中最难的后端岗位，其中多少辛酸，只有自己知道吧。

那个陪着领导一晚上喝一斤多去厕所催吐好几次的体制内青年、那个扛着割草机带着图纸上山下乡的地主家傻儿子、那个大冬天带着热水袋去找自习室然后盯着前排小学妹感慨青春的社会人，如今再次以另一种形态努力着证明自己。

人生无常，唯有进步不能停止。
