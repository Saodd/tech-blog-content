```yaml lw-blog-meta
title: 'LeetCode[46]: 全排列'
date: "2019-08-25"
brev: 中等难度。但是觉得有点难。
tags: [算法与数据结构]
```


## 读题

```text
给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/permutations
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
```

## 实现

一下就觉得眼熟，看了下，是[第31题](https://www.lewinblog.com/dj/blog/page/LeetCode%5B31%5D:%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/)
的拓展版本。

31题是求『下一个排列』，这题是求『全排列』，那么我循环调用31题的解答就可以得到答案了：

```go
func permute(nums []int) [][]int {
    if len(nums) == 0 {
        return [][]int{}
    }

    var le int = len(nums)
    var total int = 1
    for i := 2; i <= le; i++ {
        total *= i
    }
    var result [][]int = make([][]int, total)
    for i := 0; i < total; i++ {
        result[i] = make([]int, le)
    }

    sort.Ints(nums)
    copy(result[0], nums)
    for i := 1; i < total; i++ {
        p003x.NextPermutation(nums)  // 调用
        copy(result[i], nums)
    }

    return result
}
```

这种算法其实应该叫做『字典序法』，即从1234逐个递增到4321，小数优先于大数。

提交成绩：

```text
执行用时 :8 ms, 在所有 Go 提交中击败了81.11%的用户
内存消耗 :6.8 MB, 在所有 Go 提交中击败了56.86%的用户
```

让我有点意外的是，这个成绩还挺好的。我估计问题应该是在于，这题的空间复杂度太大了`O(n!)`，我们很难写一个超级大的测试用例。

因此再想想，现实中肯定不可能真的要『求全排列』，就像斐波那契数列一样，应该是使用类似生成器的政策，每次生成『下一个排列』就可以了。

所以这一题**只有学术价值，没有应用价值**。

## 优化

在求全排列的实现中，第一步是找到『顶点』，即从末尾开始向前找到顶点。

现在我们是主动生成全排列的情况，可以考虑在循环中记录这个顶点的位置，可以省去这一步的开销。

## 其他思路

另一个办法：每次选出一个数字，放在一个位置，然后选出另一个数放在另一个位置，直到数字用尽。

借用[一张图](https://leetcode-cn.com/problems/permutations/solution/hui-su-di-gui-suan-fa-by-user8125r/)来表示：

![pic](https://saodd.github.io/tech-blog-pic/2019/2019-08-25-LeetCode-46.png)

那么问题来了，如果是真的从数组中删除元素的话，性能如何保证？我们可以想到一个办法：将要删除的元素与最后一个元素交换，然后返回减一的数组长度，以此实现删除的效果但是又并不涉及数组内存空间的重新分配问题。

那么再拓展优化一下，不删除元素，而是**每次选出一个元素放在某个位置**，这实际上就是官方题解中的**回溯算法**。

大概思路就是，每次选出一个元素放在一个位置，然后选下一个元素放置在第二个位置，直到尽头（所有元素用完）；然后回溯，即把上一个元素恢复回去，然后选出另一个元素放在那个位置。

我个人觉得这种方法迭代太深，性能未必会优到哪里去。而且也没有实用价值，就不写了。
