```json lw-blog-meta
{"title":"OS学习笔记13：内存虚拟化-地址空间","date":"2019-08-13","brev":"虚拟化除了CPU，还有内存，内存虚拟化更加复杂，其主要目的是为了提供一个易用和隔离的内存环境。用户使用的所有的内存地址都是虚拟地址，通过硬件的辅助翻译为真实物理地址。","tags":["OS"],"path":"blog/2019/190813-OS学习笔记-13.md"}
```



# 第十三章 <抽象：地址空间 Address Spaces>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-intro.pdf)

## 13.1 古代的操作系统

在古代，计算机并没有向用户提供太多内存虚拟化。物理内存大概看起来像这样：

![Figure 13.1](https://saodd.github.io/tech-blog-pic/2019/2019-08-13-Fig-13-1.png)

OS其实就是一系列的`例行程序routines`，它们坐在内存中（比如例子中的前64K）；然后有一个应用程序，（本例中）坐在内存64K以后的位置上，并使用余下的所有内存空间。非常简单。

## 13.2 多道程序设计和分时共享

因为早期设备很贵，所以必须共享计算机，所以`多道程序设计multiprogramming`出现了，于是就需要调度（前面所学的）以提升`利用率utilization`。然后由于`交互性interactivity`的需求，`分时共享Time Sharing`也诞生了。

分时共享的一个思路是，运行一个进程，给与其全部内存访问权限，然后停止这个进程，把所有的数据写入硬盘，然后执行下一个进程。

这太慢了！所以只需要保存寄存器信息就够了！数据分别放在内存中就好了。

![Figure 13.2](https://saodd.github.io/tech-blog-pic/2019/2019-08-13-Fig-13-2.png)

## 13.3 地址空间

所以OS要把物理内存抽象成虚拟的，以隔离进程间的影响。

一个进程的`地址空间`包含了其中的程序所用到的所有的内存。比如，程序代码必须放在其中；其次，使用`栈stack`来保存函数调用链，本地变量，参数和返回值；还使用`堆heap`来管理用户动态分配的内存（比如`malloc()`或者`new`产生的）。当然还有有别的，不过目前我们只考虑三个：代码、栈、堆。

![Figure 13.3](https://saodd.github.io/tech-blog-pic/2019/2019-08-13-Fig-13-3.png)

代码是不变的，所以我们放在头部就好了。栈/堆是会增大缩小的。所以分别放在两端，向中间拓展。当然，你也可以随便摆，不过效率不会更高。

当然，我们在此讨论的地址空间，都是OS为进程提供的抽象的内存地址，它们在物理内存中的地址可能是任意的。

**关键问题：OS如何在一个物理内存上，给多个进程分别提供私有的、巨大的地址空间？**

## 13.4 目标 Goals

我们需要定义一些目标来评价虚拟化。

首先是`透明度transparency`，OS提供的虚拟内存必须让进程不可感知。

另一个目标是`效率efficiency`，OS必须尽可能提升虚拟内存的效率（时间效率和空间效率）。为了满足时间效率的目标，OS会需要硬件的帮助，我们称其为`TLB`。

还有`保护性protection`，也就是提供了`绝缘性isolation`。

在下面的章节，我们会学习一些`基础机制basic mechanisms`，包含硬件提供的和OS提供的。
同时也会研究一些相关的`政策policies`，包括如何管理空间内存或者内存不足时剔除哪些部分。

## 13.5 小结

略
