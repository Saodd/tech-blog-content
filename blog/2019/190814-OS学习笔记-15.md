```lw-blog-meta
{"title": "OS学习笔记15：内存虚拟化-底层机制-地址翻译", "date": "2019-08-14", "tags": ["OS"], "brev": "与CPU虚拟化一样，内存虚拟化也需要硬件的支持来达到理想的效率。"}
```

# 第十五章 <机制：地址翻译 Address Translation>

[PDF链接](http://pages.cs.wisc.edu/~remzi/OSTEP/vm-mechanism.pdf)

**关键问题：如何提供灵活又高效的虚拟内存？如何提供灵活性、如何控制、如何高效？**

内存虚拟化也需要硬件的支持，从最初的几个寄存器，到后来非常复杂的`TLB`,`页表page-table`等。硬件的支持就是所谓的`硬件地址翻译hardware-based address translation`，通过这个机制把虚拟地址转换为物理地址。

但是光靠硬件是无法虚拟化内存的，OS必须负责`管理内存manage memory`。

记住，虚拟化的终极目标是创建一个完美的幻象：每个进程都拥有自己独占的内存空间。我们依然是在遵循`有限直接执行limited direct execution`的方式。

## 15.1 假设 Assumptions

- 用户地址空间在物理内存上是连续的；
- 地址空间的尺寸并不大（小于物理内存）；
- 每个地址空间大小相同。

## 15.2 例子

想象一下我们在内存中有这样一个进程：

![Figure 15.1](/static/blog/2019-08-14-Fig-15-1.png)

这个进程中有这样一段代码，即向内存中读取一个数字，+3，然后存回去：

```c
x = x + 3; // line of code we are interested in
```

通过`objdump -S mian`或者`gcc -S mian.c`命令，你可以看到其汇编代码，类似这样的：

```x86asm
128: movl 0x0(%ebx), %eax       ;load 0+ebx into eax
132: addl $0x03, %eax           ;add 3 to eax register
135: movl %eax, 0x0(%ebx)       ;store eax back to mem
```

上面的代码很简单，即假设x的地址已经放在ebx中了，然后把x的值取到eax中，然后给eax做个加3，然后把eax的值放回ebx所指向的地址中。

在上面的图中，假设变量x的地址是在15KB处，那么这段程序访问内存的过程为：

- 从地址128读取一条指令
- 执行这条指令（从地址15KB读取数据）
- 从地址132读取一条指令
- 执行这条指令（没有内存操作，仅在寄存器中）
- 从地址135读取一条指令
- 执行这条指令（将数据写入地址15KB）

在这个进程看来，它所有的地址空间是从0-16KB的；但是OS实际上是取了任意一段内存虚拟化出的这个地址空间。

![Figure 15.2](/static/blog/2019-08-14-Fig-15-2.png)

## 15.3 硬件提供的动态地址翻译 Dynamic Relocation

我们讲一个早年地实现版本，这项技术也被称为`基础和边界base and bounds`。

特别地，它需要两个寄存器`基底base`和`上界bounds`（或者`上限limit`），这一对寄存器中保存的值就是进程可以访问的地址空间了。地址翻译只需要一个简单的公式：

```text
physical address = virtual address + base
```

bounds的作用是保护。处理器会先检查`相对地址memory reference`是否在限制以内，否则就会引起异常，然后OS杀死进程。

这一对寄存器是在每个CPU内部的，所以有时称为`内存管理单元memory management unit(MMU)`.每当我们内存管理方式进步时，我们就往MMU里面添加电路。

## 15.4 硬件支持小结

我们已经知道，CPU有两种模式（用户态和内核态）。我们只需要一个简单的`位bit`（比如在一个`处理器状态码processor status word`之中）就可以定义这两种状态。

然后CPU还要为内存管理单元提供两个寄存器，然后指令集中必须要定义特殊的指令来让OS修改这两个寄存器，这些指令必须是`有权限的privileged`。

最后，CPU还要有能力产生`异常exceptions`来应对非法操作，OS要能够注册相应的`异常处理程序exception handler`来做出应对。

![Figure 15.3](/static/blog/2019-08-14-Fig-15-3.png)

## 15.5 OS的实现

有了硬件的支持，OS接下来还需要处理一些问题。

首先，当进程创建的时候，要分配地址空间。基于前面的三点假设，OS只需要把内存分成`小片的集合array of slots`，然后以`空闲列表free list`的数据结构来储存使用信息；那么每次只需要拿出一片来分给进程就好了。

然后，当进程`终结terminated`的时候，要回收所有内存。只要把这一片内存放回空闲列表中就好了。

第三，当上下文切换的时候。要把MMU两个寄存器的数据放回内存里，然后把下一个进程的数据放回寄存器里。之前提到过，进程会拥有自己的数据结构体`process control block(PCB)`。

注意一种情况，如果需要移动进程的地址空间，那么就要让进程暂停一下。

第四，OS必须提供异常处理程序。之前提到过，在系统`启动boot`的时候就会向硬件中注册异常处理程序的地址。

![Figure 15.6](/static/blog/2019-08-14-Fig-15-6.png)

## 15.6 小结

基于硬件的支持，让内存虚拟化很高效。但是也存在一些问题，比如在进程的堆和栈中间的部分就是浪费，即所谓的`内部碎片`；而且，我们还设定了三项假设条件呢。因此我们需要更精巧的内存管理机制，即所谓`碎片segmentation`。
