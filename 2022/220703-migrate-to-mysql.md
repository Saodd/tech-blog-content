```yaml lw-blog-meta
title: "从Mongo迁移到MySQL"
date: "2022-07-04"
brev: "钱难赚，屎难吃"
tags: ["中间件"]
```

## 背景

虽然现在Mongo用得好好的，但毕竟就业市场上普遍对于后端的要求还是免不了MySQL的。

因此虽然麻烦，我也还是得亲自折腾折腾MySQL。于是开始改造我的个人网站后端服务……

## 吐槽：没有数组类型

数据库第一范式就告诉我们：字段的类型应该不可再分。

因此，不管以前在Mongo里用数组用得多爽，现在在MySQL中是别想有数组类型了。

为了表达一个简单的“标签”功能——用术语来说是“多对多关系”——我需要创建3张表来表达这种关系，哭笑不得。看来MySQL这类关系型数据库比NoSQL的性能更差确实是非常有道理的。

还好我“早有先见之明”，哪怕以前在用Mongo的时候，为了提高索引效率，我也没在这个数组字段上建立索引，而是在其他组件上做了更专业的索引，因此这次迁移到MySQL中可以偷个懒，直接用字符串拼接数组进行保存即可。

## 吐槽：重复的绑定参数

绑定参数就是一种在SQL语句中用特殊符号来代替变量，然后交给框架去做字符串转义的工作，主要用途是防止SQL注入。示例代码如下：

```go
func main() {
    var name = "xxx"
    res, err := db.ExecContext(ctx, "INSERT INTO table1 (name) values (?)", name)
}
```

我这里必须吐槽一下，在我的认知中，这就是一个非常常见的的功能，是不管何种语言何种框架都应该具备的基本能力。但是我却很难在互联网上查找到相关的资料。而且每当搜索“mysql”相关的资料的时候，出现最多的是“php”相关的问答，这个“世界上最好的语言”，真是看得我烦不胜烦。

参考这篇文章：[Using Prepared Statements](http://go-database-sql.org/prepared.html)，我发现go的MySQL的驱动对于绑定参数是没有索引号的，因此如果我需要使用`ON DUPLICATE KEY UPDATE`这种语句的时候，需要把参数传入两次，而且写了几个问号还要仔细地一个一个地数。这个代码真是写得我崩溃。

作为对比，之前用的是Mongo，它直接通过bson格式来解析结构体，我只需要往数据库操作函数中丢一个结构体进去就行了，还能天然保证进出的格式都保持一致；更别说还有原生的`upsert=True`能力，开发起来确实很爽。

## 吐槽：反引号

如果接触过`PostgreSQL`的同学可能知道，“严谨”的SQL语法风格应该是要求你能加引号的地方都要加引号的，大概像这样（如果我没记错的话）：

```sql
SELECT `path`,`title` from `MyDatabase`.`blog` where `title` like "CSS%";
```

因此这种“严谨”的习惯也被我带到了MySQL中来，而偏偏，反引号在Go语言中又算一个小麻烦：如果要用反引号的话，那字符串外层就只能用双引号了；如果语句里要用双引号的话，那字符串外层就只能用反引号了，即反引号和双引号同时只能存在一个。

这个小麻烦真的让我哭笑不得，Go什么时候能支持这个特性呢？……像Python那样用“三对反引号”来表示字符串呢我觉得就挺不错的……

不过现在也有临时解决方案。虽然在反引号表示的字符串中不能转义反引号，但是在双引号表示的字符串中可以转义双引号。所以用双引号来写SQL语句就凑合可以用，多打几个转义斜杠就好了。

## 启动镜像

`MySQL`这个镜像稍微有一些特殊，它不能直接运行`mysqld`这个程序来启动，而是需要做一些额外的配置脚本，虽然脚本已经在镜像中封装好了，但是我们在k8s中配置deploy的`command`的时候要显示地指定它：

```yaml
containers:
  - image: mysql:8.0.29
    name: mysql
    command:
      - "docker-entrypoint.sh"
      - "--character-set-server=utf8mb4"
      - "--collation-server=utf8mb4_unicode_ci"
    env:
      - name: "MYSQL_RANDOM_ROOT_PASSWORD"
        value: "yes"
```

如上所示，同样别忘记了root账户安全相关的措施。我这里用的是随机初始密码，凭这个密码，后续登录mysql容器中进行手动配置。

持久卷相关等其他的配置我就省略了，基本操作。

## 数据导出与恢复

### 同步用户与库表

先处理一下用户的事情，root用户，还有业务用的用户，赋予适当的访问权限。

考虑对用户增加host限制：对于k8s环境来说，内网ip网段可能是`192.168.*.*`（看你创建k8s时的配置），因此可以给MySQL用户限制从`192.168.%`登录，增加一些安全性。（可以用`show full processlist;`命令来查询当前的连接）

然后去测试环境把库表的DDL复制出来，到线上去执行即可。

如果是从dump恢复，那会自动把表结构也一并恢复，不需要手动创建。不过对于那些你没有备份的库，例如`mysql`这个库，就还是得自己手动维护了。

### dump工具

在镜像中默认携带了`mysqldump`工具可以用于导出，在docker中的执行代码示例：

```shell
docker exec -i mysql-container mysqldump -u root -p --databases XXXX > ./mysql.dump
```

> 有时候会希望导出数据之后生成一个新的binlog文件，只需要给mysqldump加上-F参数即可。  
> 在上面的代码中，给docker指定了`-i`参数，因此你可以在接下来的输入引导中键入密码。

然后恢复步骤，直接使用`mysql`客户端，代码示例：

```shell
docker exec -i mysql-container mysql -uroot -proot  < ./mysql.dump
```

### binlog工具

工具是`mysqlbinlog`。

数据文件位置一般与mysql数据目录一致，在docker中默认是`/var/lib/mysql`，目录中有多个`binlong.0000x`文件和一个`binlog.index`文件，顾名思义，前者是数据，后者是索引。可以用时间或者位置参数来选择恢复的起止范围，然后通过index文件快速选出我们所需要的文件。

我们执行`mysqldump -F`的时候会同时得到一份全量的dump文件，并且将当前的binlog切断一份。将dump文件拷贝到其他储存空间，这个是最稳妥的全量恢复点。

然后在两次全量备份之间的增量数据靠binlog来实现。对于binlog，由于其体积较大，对它的备份策略可能要见仁见智。我目前认为，生产级的MySQL一般至少配备主、从至少两台机器，从服务器本身就是对binlog的实时备份了，一主一从的可用性应当已经足够高了。如果数据很重要，还可以考虑配置半同步模式。

对了，dump文件是文本格式，可以借助`gzip`等工具来进行压缩。经过默认参数的gzip压缩后体积减小为1/3左右。binlog同样也可以压缩到1/3左右。

（等我有朝一日有实战经验了，再来补充。）

## 小结

这次我并没有把我个人网站的全部后端业务迁移到MySQL上去，只是作为试水，先把博客模块的数据迁移过去了。虽然折腾了不少东西，但总体来说还算顺利。

有一说一，MySQL的开发体验/运维体验确实比Mongo差一些。不过我仍然愿意相信，如果把时间线看长远一些，从项目的总体可维护性来说，MySQL这种有固定库表结构的数据库是更有利的。稳固or便捷，二者总是不可兼得。

同时这次运维经验也让我收获不少，认识了新的理念，开拓了新的思路。付出还是有回报啊。
