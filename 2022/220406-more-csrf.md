```yaml lw-blog-meta
title: "再解CSRF"
date: "2022-04-06"
brev: "用最简单的语言归纳一下"
tags: ["安全"]
```

## 干货

`CSRF`的意思是「跨域请求攻击」或者针对这种攻击的防御措施。

我们日常中的许多应用都会涉及跨域，跨域资源请求叫做`CORS`，在这个过程中需要做一些保护措施，就是`CSRF`。

既然是跨域请求攻击，那么场景也就是跨域请求咯。

假如有一个正规网站A，然后有一个钓鱼网站X。用户在浏览钓鱼网站X的时候，黑客试图跨域攻击A网站。

分为两种情况：

### 情况一：fetch主动请求

黑客在X网站的js代码里主动请求A网站的资源，工具无非就是`fetch`或者`xhr`。

这种攻击的优势是，如果攻击成功，黑客（的程序）可以获取所有返回值，可以支持后续更多的攻击行为。

应对方法，关键点在于，**在发起跨域请求的时候，浏览器会强制给请求头的`Origin`字段添加当前域名**。因此在本例中，A网站后端程序可以识别出哪些请求是来自于X网站的，并且拒绝这些请求。

- 细节一：注意区分`Origin`和`Referer`
- 细节二：对于`POST`这种相对更加危险的请求，在发送请求之前，浏览器还会额外执行一次飞行检查（`pre-flight`，特征是`OPTIONS`方法）

### 情况二：form被动请求

黑客在X网站植入了一个原生的`form`标签并诱导用户点击触发。

这种攻击的优势是，触发form之后是一次独立的**浏览器导航**，相当于用户直接在地址栏输入url跳转，可以不带Origin。

应对方法是`csrf-token`。核心原理就是：攻击者利用漏洞只能同时用一个漏洞，那么我们**同时使用两种安全手段**互相照应，就可以确保安全。

在以前流行后端模板渲染的年代，会将这个token直接植入html的form中。这个token与用户认证的`session`是不同的，前者在form请求体内，而后者在cookie里。

在现代的SPA应用中，没有form了全是fetch/xhr了，（特别说明，这里说的是A里没有form了，但是攻击者X依然可以构造form来进行攻击，我们这里讨论的是在保证A的fetch请求正常工作的情况下防御X的form攻击）因此需要另一种手段来在fetch请求里添加这个token，其核心原理是：**form请求不能添加自定义头而fetch可以**，因此我们通过API来获取`csrf-token`然后在fetch请求中添加这个token作为头，就能排除掉无法携带自定义头的X网站的攻击请求了。

- 方案一：再仔细看看，关键点是**能不能携带自定义头**，而不是自定义头里携带的内容是什么。因此一种简化方式，可以传一个固定的值，直接写死在前端代码里，这样就不需要后端动态支持了。
- 方案二：最经典的方案，在任意请求中通过set-cookie传递token，然后前端发起请求时，js从cookie里读出来然后塞进请求头里。（这一句话里很多细节值得推敲，能想清楚的话那就可以说真的理解了CSRF）
- 实践：我观察字节跳动某个页面，他们是会有一个专门的API负责发csrf-token

> 再提一句，不仅仅是form，其实img标签也可以起到类似效果，这个属于黑科技了是：） 然后说到Origin的话，其实又可以提一下盗链问题。这么说来是不是还挺有意思的？

### 总结

在浏览器中发起（跨域）请求只有两种方式：

- fetch强制携带Origin
- form不能携带自定义头

针对它们的特性去做防御就行了：

后端检查Origin和自定义头。

## 背景

这次特地把背景放在后面说，把干货放在前面。是因为我发现我有时确实有点话痨，说太多不相关的事情，会降低技术文章的质量，耽误读者时间。

这次的灵感来自于 [这个帖子](https://www.v2ex.com/t/845056) ，其中问答双方都非常专业，让我收获很大。

CSRF可以说是前端经典八股文了。之前我其实已经写过一篇文章 [详解CORS](../2021/210922-Dig-CORS.md) ，但那篇文章其实是站在偏后端的角色来说的，语言上也比较混沌。而今天这篇文章是以前端的角色来说的，重点在解释浏览器的行为，而且忽略了一些基础细节，力争用最简单的语言进行归纳。

希望能给屏幕前的你带来一些收获。
