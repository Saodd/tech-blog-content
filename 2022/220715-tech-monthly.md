```yaml lw-blog-meta
title: "技术月刊：2022年7月"
date: "2022-07-15"
brev: "聊聊项目、工程、未来"
tags: ["前端"]
```

## 后端程序员如何学习前端？

在我经常潜水的论坛里，这个问题算是一个月经贴了。最近感觉有些有感而发，稍微总结一下。

### js篇

我最开始也曾经用过jQuery，那时还是用的后端渲染框架Django，整个开发体验，怎么说呢，如果写点简单的展示页面还行，一旦要加入交互逻辑了，地狱就开始了。

然后我决定学习“现代前端框架”。我找了几个前端同学咨询了经验，得到的回答基本上就是React或者Vue；然后我亲自动手把三大框架 React，Vue，Angular 都写了个Demo体验了一下，或许是我受后端研发经验影响，最后反而是Angular的框架设计给我感觉最好，于是我选择Angular重构了我的个人网站。

现在回头去反思我这段学习Angular的经历，依然觉得很奇妙。它作为一个全家桶，把该有的常见的功能都包含了，我只需要简单配置即可开箱即用。而且各个配置项都是超前考虑的，其中很多细节，让后来转战React的我学习、品味了好久，学到了很多很多东西。

那我为什么放弃了Angular呢？大概就是“成也全家桶，败也全家桶”。当我前端水平不断提升，对定制化能力的需求越来越多的时候，我发现我要对这样的全家桶去修改配置，所需要的学习成本是非常高的，而这样积累的经验只与这个框架深度绑定，甚至它一次大版本更新都能让我的经验失效。所以就像Django转向Flask那样，我从重量级的Angular转入了轻量的React 。

React也确实很简陋，它本身只是一个UI（和渲染调度）框架，所以在学习的初期，我是照着我之前用Angular搭建的应用去一个一个功能点逐个复刻的。过程很漫长，但当我全部复刻完毕之后，我对整个前端工程化技术有了比较深刻的认识。

至于后来接触到的 React Hooks ，那更是封神，到现在为止我已经离不开它了，不用函数组件的话我可能一行代码都写不出了。

其实还有很多人推荐Vue，但就我目前观察来看，推荐Vue的基本上是“纯前端”的同学，推荐理由无非也就是简单、好上手、容易写。而一般研发经历比较丰富、技能栈比较全、要求比较高的同学，推荐React会更多。

啊咧？我上面这句话是不是隐含了对前端的鄙视？严肃讲，我没有故意，我只是在表达我身边的观察现象。

### css篇

前、后端的代码在js的逻辑部分还有一定的共同性，但是到了css这个领域，正常来讲，对于后端程序员来说都是非常陌生的。我相信大部人都跟我一样，初学前端的时候对css非常恐惧。

css的“难”，其实难在：它的运行逻辑是类似DOM树的一颗CSSDOM树，因此上游节点会对下级节点造成影响。因此，如果一个后端程序员只是在一个庞大的（甚至有沉重历史包袱的）前端项目中偶尔写一点前端组件，没有对整个页面结构有清晰的认识的话，那么他会发现，css属性似乎都是玄学——有的时候改这个有用，有的时候改这个却改崩了，这样根本无法积累有效经验。

我的学习过程还是比较顺利的：先要经过一定的系统性学习作为基础，然后真刀实枪地从零开始撸一个大中型项目，对整个CSS的层级关系、以及常用属性用法有了一定了解之后，很快就能有拨云见日的感觉。

## PC客户端技术选型

先谈谈我对业界主流技术的认知。目前我们日常使用的软件中：

- 有一部分是`Java`写的，典型的如Jetbrains系列，还有早年很多的大型工具类软件（还记得那个开屏咖啡画面吗？）
- 然后最近比较主流的技术应该是web相关的技术栈，
  + 最典型的是`Electron`技术，典型代表如VSCode、飞书/飞鸽等；
  + 此外还有`CEF`也是一种套壳浏览器技术，CEF本身指的是一种协议，各个主流语言都有对应的操作框架；
- 有一些平台专用的框架，`WinForm`，以及最近出的`UWP`（特别表扬网易云的UWP版本做得非常清爽）
- 一些更原始的工具，如`Qt`

参考阅读：

- [像飞书、微信、skype、钉钉这类PC端桌面程序前后端都是用什么写的？](https://segmentfault.com/q/1010000022428587)
- [我擦！迅雷的代码结构竟然被扒了精光~](https://jishuin.proginn.com/p/763bfbd32cb9)

然后是我们项目的选型的心路历程。

研发目标是主要针对windows平台，既然是windows，那么我的第一直觉是c#。然后为了结合目前的团队情况（只有web前端工程师），那么技术选型就肯定是套壳浏览器，看了一圈之后我发现了`cefsharp`。

再一看，原来`CEF`有纯js版本，可以不需要c#介入。

再再一看，直接选`Electron`更现代化、更友好。我简单写了个Demo验证了一些关键能力，过程中除了构建环节有些痛点之外，开发体验还不错，所以这个应该就是我们的最终决定了。

等项目上线稳定运行后另行记录。

## useEffect 与 reaction

有时候我会写一些特殊的组件，仅仅利用它们来控制副作用，而不用它们渲染UI。大概像这样：

```tsx
const DataManager = () => {
  useEffect(() => {
    const t = setInterval(someBusinessFunction, interval * 1000);
    return () => clearInterval(t);
  }, [interval]);
  return null;
};
```

为什么非要借助`useEffect`？它的最大优势是它会自动执行返回值函数，返回值常见的也就是“清理动作”；同时这个组件的挂载位置也直接决定了它的运行范围，从各方面看都非常清爽。而如果我们要自己维护这个清理动作就会比较恶心。

但是借助了React框架的话，难免会涉及到VDOM树上上下下的重复render，因此为了性能考虑，有的时候也会用更加直接的状态管理工具来做。例如在`mobx`语境下，我们会用`autorun()`或者`reaction()`，后者可以提供更加细粒度的控制。

## webpack splitChunk

在webpack配置了多个`entry`的情况下，可能会遇到这个问题。

简单概括，就是多个入口重复引用了同一部分代码，这部分可以抽离出来作为公共文件存在，减少编译产物的总体积。

在[文档](https://webpack.js.org/plugins/split-chunks-plugin/#defaults) 上写得很清楚，如果我们不配置的话它是有默认值的。而随着项目的发展、代码量增多，可能某天突然就突破了这个默认值的限制，然后出现一些奇怪的问题。解决方法就是主动配置即可。

## Git分支策略

三大流派：`git flow`, `gitlab flow`, `github flow`

我之前有简单介绍过[GitLab配置CI环境](../2019/190821-GitLab部署CI持续集成.md)，其中也算是简单介绍了`gitlab flow`的思想。

之后经过三年的实践，我目前对于git工作流的态度，有些类似对REST标准的态度：取长补短就好，不要过于刻板。

目前我们项目的实践要点：

1. 在一个仓库内工作，不fork
2. 为feature建立分支，但不限于一个分支，每个人在每个阶段都可以任意建立分支，通过rebase组合其他分支，包括rebase主分支
3. 直接部署feature分支提测（此时这个feature分支相当于是临时的dev分支）
4. 测试通过后merge到主分支，删除分支，发布上线

如果套进所谓的三大流派里，那目前最像的是`github flow`，核心点在于除了master分支之外其他功能分支都是临时存在的。

如果以后项目和团队规模进一步扩大，“多个功能分支同时提测”的场景经常出现的话，我想我会吸收`git flow`的一些思路，增设一个（或多个）临时（或永久）测试专用分支，将所有待提测分支merge到测试分支，通过之后再merge到master上发布。

如果规模再进一步扩大，连测试也要并行的时候，我想我会需要`gitlab flow`的思路，在`pre-production`分支上做整体测试再发布。

## 程序员的未来

是技术？还是业务？

是专精？还是全栈？

最近我感觉思考了蛮多的。程序员这一行，或者说互联网这一行，红利期的终点大概在2020-2021年——疫情影响还不算大、以字节为代表的大厂依然在疯狂扩张的时候。2022年，随着各厂大量裁员，这个行业正式进入“衰退期”。

其实说“衰退”我是不认可的，我认为，这只是之前扩张太快、然后骤然减速给人带来的错觉罢了。现在只是进入了“正常速度的发展期”。在我们以前不太关注的、看起来没那么赚钱的地区和产业里，其实依然有大量的信息化改造需求。虽然他们给不起互联网行业那么夸张的、能让人提升阶级的薪酬，但是一份相对可观的收入是绝对没问题的，我甚至很有信心能维持这种相对可观的水平干一辈子。

但这一切都建立在“不掉队”的基础上。

但维持“不掉队”可能也没想象的那么可怕。虽然我们口头上说程序开发这个行业，技术日新月异，旧的东西很快就会被淘汰；但是如果我们仔细观察一下周围的现实，会发现这个行业远远没有我们想象中那么“先进”。以后端为例，多少人一手 Java Spring 技术吃个十几年，到现在用着Java8还毫无心理负担；甚至还有多少人还沉浸在php的世界里不愿意出来，却依然通过大量的垃圾站点赚得钵满盆满。再说前端，说前端的技术迭代就像娱乐圈，但实际上，进入 React Hooks + Redux/Mobx + webpack 框架体系之后，我感觉前端研发中的痛点已经非常少了，已经很难再有实质上的大型技术迭代了，例如React18推出的并发模式我看了之后连连摇头只觉得它是负担。

你硬要说接下来的大型技术迭代方向，无非就是『低代码/无代码』，或者『web3.0』。但与其说他们是“技术革新”，倒不如说他们只是“结合了部分业务场景的进一步抽象”，他们的适用面会越来越窄。

我的判断是，在红利消失、经济下行的未来很长一段时间内，我们能够依靠“纯技术”带来的收益会越来越少，以后我们可能不得不去“下沉”，去绑定业务、绑定行业、甚至绑定资源来做更精细化的定制。

其实我一直认为我们的行业的从业人员素质依然是良莠不齐的，在这个精细化的过程中，有一些人员流出恐怕是难以避免的，对于那些人来说也许是不幸的，但是对于整个行业来说，我觉得可以稍微乐观一些去看待。

对于留下来的人，我认为，在这个精细化的过程中，我们也最好跟随项目一起去“下沉”、去积累一些更加能产生实际价值的经验。毕竟我们互联网本身并不（或者比较少）产生价值，你看大厂营收大头的电商、广告都是依托于实体经济的，社交更是要转化为电商和广告才能创收；最后娱乐可能是互联网产生的唯一价值，却又不是人类生存必须的价值。

简而言之，适当地与产业结合，应当是一条“比较稳妥的路线”。如果在结合过程中能够发挥局部的技术力优势（和产品力优势），在细分赛道上领先，应该就能活得比较滋润了。

至于技术的选择方面，我认为在这种更业务导向的环境中，特别是在当前各种框架和云服务都很成熟的基建条件下，深入精通一门技术可能会相对比较吃亏，但吃亏是吃亏，精通对于团队的竞争力来说又是不可或缺的。而如果过于宽泛，像我一样在多个领域同样精通，则又陷入另一种吃亏的极端。所以比较理想的应该还是所谓的“T”型人才，成为这样的人的“投产比”会是最大的。

当然以上这些都是我的个人见解，也受限于本人的小厂视角，并不适用所有人。

是对是错，咱们三年之后再来评价。
