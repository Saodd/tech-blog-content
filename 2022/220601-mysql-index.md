```yaml lw-blog-meta
title: "MySQL基本用法——索引篇"
date: "2022-06-01"
brev: "引擎、索引、范式"
tags: ["中间件"]
```

## 范式

关于关系型数据库的范式，参考阅读：[如何理解关系型数据库的常见设计范式？](https://www.zhihu.com/question/24696366) 第一个回答比较详细地从理论上推导了一遍，后面几个回答比较通俗易懂。

简而言之，范式是一个多级的标准，从低到高逐步加大要求：1NF，2NF，3NF，BCNF，4NF，5NF 。对各级的通俗解释：

- 1NF：（原子性约束）列不可再分
- 2NF：（唯一性约束）一张表只描述一类对象（即主键），其他列完全依赖主键
- 3NF：消除非主键的冗余，拆开
- BCNF：再消除主键里的冗余，拆开
- 4NF：消除多对多

具体做到什么程度不能太刻板，要结合业务实际来选择。一般做到 3NF/BCNF 这一级就足够了。

其实范式这种东西呢，其实在日常中也有实践，范式也确实符合我在实践过程中得到的经验。但经验要经过总结形成理论，才是真正的知识。所以学了一遍下来我感觉挺好的。

### 反范式

参考阅读：[数据库:三范式与反范式](https://zhuanlan.zhihu.com/p/83919684)

反范式 就是主动降低范式级别，增加冗余（降低一致性）以提升运行效率。

一种合理的实践是，设计概念的时候遵守3NF，但是具体到实现的时候根据情况降低要求。

## OLAP与OLTP

参考阅读：[OLTP与OLAP的区别](https://blog.csdn.net/bitcarmanlee/article/details/51011515)

- OLTP（事务处理，数据库）：我们平时用的 MySQL Mongo 等
- OLAP（分析处理，数据仓）：大数据组件 Spark Hadoop elasticsearch 等

很显然，OLTP是线上业务用的数据库，通过一定的方式转移到OLAP中进行（离线）分析，这个转移过程就叫做 ETL 

> 身边的案例：  
> 现在的公司在电商行业，数据分析的场景最典型的就是订单相关业务了。  
> 据我所知，我们订单项目组一开始选择MySQL作为储存，这个技术选型应当是不太合理的，不知道是否有其他的妥协，实际运行中也确实是经常搞出监控事件来。后来用上了elasticsearch才似乎好多了。

## 引擎

### Innodb与MyISAM的区别？

简而言之：MyISAM更适合重读取的应用。

- InnoDB 支持事务（MVVC），支持外键，支持行级锁（必须使用主键）。
- MyISAM 支持全文索引，保存了总行数，只有表级锁。

MyISAM 理论上来说性能优秀一些；但由于**表级锁**，读写互相干扰，因此在读多写多的场景下表现比较差。

InnoDB 的**行级锁**可以减少这种冲突的情况，并且支持很重要的事务特性。

v5.1之前默认引擎MyISAM，之后的默认引擎是InnoDB，一定程度上说明后者更符合常见业务需求。

## 索引

### 索引结构

**聚簇性：**

- MyISAM 的索引是 非聚簇索引，索引与数据分离，因此可以缓存更多的索引内容，查询性能更好。
- InnoDB 的索引是 聚簇索引，主键与数据结合；其他索引都是**辅助索引**因此查询时多一级跳转。

参考阅读：[MySQL聚簇索引和非聚簇索引的理解](https://segmentfault.com/a/1190000041290817)

**索引的数据结构：**

- B树（多叉平衡树）
- HASH（拉链法）
- FULLTEXT（全文索引）
- RTEEE（很少见）

关于**B树**，其实有[两种结构](https://segmentfault.com/a/1190000020416577) ：

- B-树：每个节点都储存键和值
- B+树：是只在叶子节点保存值，中间节点只有键。

[MySQL](https://dba.stackexchange.com/questions/204561/does-mysql-use-b-tree-btree-or-both) 和 [Mongo](https://stackoverflow.com/a/65733242/12159549) 都是B+树索引，不是B-树。

- B-树的好处是，可能在中途节点就查找到数据，可以立即返回。
- B+树的查询则一定要到达树的底部才能完成。但是将数据集中在叶子节点有巨大好处，因为MySQL是关系型数据库，可能经常需要范围查询，MySQL的B+树是将叶子节点串联起来做成了链表；同时，磁盘、缓存等硬件也对连续读取有更好的性能。因此B+树有优秀的连续查询效率。

> 特别强调！数据库默认索引都是B+树！我们在某些文档中见到的『B-Tree』中间的减号并不是『B-』的意思，而是一个连字符，即『B-Tree === B树 === B+树』

**B树与HASH索引的区别：** [参考](https://blog.csdn.net/oChangWen/article/details/54024063)

- HASH不支持任何范围相关的操作（包括比较、排序、模糊匹配等）
- 联合HASH索引不能使用左方的部分索引（因为多个键组合之后进行哈希运算）
- 在HASH冲突比较多的时候性能降低

然而，常见的InnoDB和MyISAM都不支持HASH索引，因此某种意义上来说可以不管这种类型。（参考：[Table 13.1](https://dev.mysql.com/doc/refman/8.0/en/create-index.html) ）

使用HASH索引的场景一般是简单的单个查询，应该不需要事务的支持，因此直接用Redis或者其他的NoSQL数据库才是正确的选择。

### 建立索引的原则

由于索引要占用存储空间（包括硬盘、内存、缓存），同时在更新数据的时候也要同步更新所有的索引，这都会降低性能表现。因此索引并不是越多越好的，我们需要在保证功能的基础上尽可能地建立最少的索引。

网上已有很多文章了，随便贴一个：[参考](https://segmentfault.com/a/1190000022754138) 主要内容：

- 尽量选择唯一、数据量小、经常使用的字段
- 需要排序、分组、去重等操作的字段
- `=`和`in`可以乱序，它会帮你优化顺序
- 联合索引，记住最左匹配原则，并且记住遇到范围查询会停止匹配
