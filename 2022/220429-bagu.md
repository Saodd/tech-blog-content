```yaml lw-blog-meta
title: "八股复习记录&面经"
date: "2022-04-29"
brev: "其实偶尔了解一下，还挺有意思的"
tags: ["杂谈"]
```

## 前端

### 1. js的宏任务与微任务

我们都知道js是单线程、基于事件循环的调度机制。但它的『事件』是分两种的：

一个叫『micro-task』，微任务，主要指的是`Promise`。

一个叫『macro-task』，宏任务，可以简化记为除了`Promise`其他都是宏任务，典型的有：setImmediate/setTimeout/setInterval, IO, postMessage等。

执行顺序：在两个宏任务之间会完成所有已就绪的微任务。（简化理解就是Promise有更高的优先级）（注意，这个规则并不是js所规范的，这个规则仅在web环境生效，而在node.js中则不同）

### 2. 用css画一个梯形

核心是借助`border`来实现。

相邻的两条border之间是以一条直线分割的，把其中一条设为`transparent`就相当于切掉了一个角，得到的矩形实际上是一条border，示例代码：

```css
.box{
    height: 200px;
    width: 200px;
    border-top: 200px solid black;
    border-right: 40px solid transparent;
    box-sizing: border-box;
}
```

### 3. border-box作用

`box-sizing`属性的默认值是`content-box`，意思是height, width属性只针对content区域，不包含border。

我们一般项目中都会设置`* {box-sizing: border-box}`，意思是宽、高是包含边框在内计算的，而content区域的尺寸会被相应地减去。这样的好处是我们从外层容器的角度来看，子元素的尺寸更好计算。

极端情况下（例如上面画梯形的例子），例如border大于等于容器的宽高，那么border会把容器强行撑开（宽高属性失效），同时content的尺寸会被减到0，注意虽然content为0，但是里面的子元素依然有机会在超出content范围内显示，这个行为通过`overflow`属性控制。

### 4.script标签defer和async区别

参考： https://segmentfault.com/q/1010000000640869

简而言之：defer和async都会异步加载脚本，区别是async是下载完毕后立即执行（不保证顺序），而defer会等到`DOMContentLoaded`事件触发之后再有序执行。

所以对我们现代SPA应用来说，大多数依赖都应该试用`defer`。少数像 Google Analytics 这种没有其他依赖的可以用`async`。

> 顺便再提一句，script标签都应该写在body前面，也就是head里。

### 5. 手写assign

实质上就是考怎么做浅拷贝，细节有：

1. `for in` 遍历对象（不是`for of`），再加`hasOwnProperty`判断自有属性
2. 当`Symbol`作为key时不会被遍历到，要用`getOwnPropertySymbols`去取
3. 多个`arguments`怎么取出来。[参考](https://blog.csdn.net/qq_51315315/article/details/121334161)

如果要求做深拷贝，那需要考虑的东西更多，[参考](https://sunchang612.github.io/blog/javascript/basics/copy.html#%E6%B5%85%E6%8B%B7%E8%B4%9D)

### 6. WeakMap

[参考](https://zhuanlan.zhihu.com/p/84862214) ，它的关键特性：

1. key只能是object，而且是引用（指针）
2. 保存的是弱引用，可能会被GC干掉

## 网络HTTP

### 1. 打开一个网页的过程

（很经典的题目，考察对整个web架构的认识）

1. 域名->ip，即DNS服务，涉及本地网卡iptables，各级DNS服务器，DNS负载均衡
2. http请求发往指定IP，这个过程可以讲网络4层模型（7层我认为没意义），TCP三次握手
3. 服务器收到请求，一般会重定向https，（或者如果有HSTS则直接在浏览器内重定向了）
4. HTTPS的7次握手（TCP三次，SSL四次）
5. 服务器正式处理请求，路由判断，返回html（可以八股HTTP报文）
6. 浏览器收到html，解析，请求js+css等资源，这个多次通信的过程可以有HTTP1.1或者HTTP/2的优化
7. 跨域请求
8. 浏览器解析html，css，初次渲染（DOM树，CSSDOM树，合成渲染树，flow重排）；
9. 浏览器执行js，正式进入应用
10. （硬八股）TCP四次挥手

参考阅读：

- [7次握手，9倍时延](https://draveness.me/whys-the-design-https-latency/)
- [HTTPS通信的过程的三个随机数的作用](https://blog.csdn.net/qq_31442743/article/details/116199453)

### 2. HTTP2 HTTP3

首先是HTTP/1.1 对于1.0的优化：

- 默认长连接（但是依然每个连接同时只能处理一个请求，这点可以从后端web框架源码中验证）
- Cache-Control，ETag等缓存相关的拓展

其实我个人觉得，有上述两个特性，就已经在很大程度上解决了网络传输的问题。但是精益求精，HTTP/1.1还存在这些主要问题：

1. 在现代web应用中，一个页面会有大量的资源请求（js、css、jpg等），1.1的并发能力有限，在劣质网络环境下表现不佳
2. 现代风控系统在Header部分设置了大量的内容，每个请求都携带完整头部导致传输效率降低

因此HTTP/2提供了下列特性：

1. 在HTTP应用层中又垫了一层叫『二进制分帧层』，新增了一个『流stream』的概念，在一个连接中实现多路复用（以及配套的流量控制、优先级、重置连接等能力），提升并发能力
2. 文本格式改为二进制格式，减小数据体积
3. 头部压缩（HPACK算法，两端共同维护一份字典）
4. 服务端主动推送（客户端发1个请求，服务端预测多个响应提前发送）

这样HTTP2的设计对于协议本身的利用效率可说已经达到极致了。

但是接下来还有人嫌弃底层的TCP协议，由于它的一些特性（TCP和SSL多次握手延迟、TCP慢启动等），在某些极端网络条件下依然会表现非常糟糕，因此业界提出：用UDP替代TCP，这就是HTTP/3 。

HTTP3关键概念：在UDP上面增加了一层`QUIC`层，它整合了TLS，实现了类似TCP的可靠连接特性同时直接交换密钥，实现了更低延迟（初次只需要1次握手，后续复用则是0次） 

以我个人的实践经验，浏览器初次访问网站时，依然会使用HTTP/2以下的版本。若服务端支持HTTP3则在响应头部声明，客户端可以记录，后续连接可以选择切换到HTTP3 .但是对于网络条件较好的应用来说，可能在HTTP3建立之前就已经通过HTTP2完成了请求，所以HTTP3只是可选的。

## 网络TCP

### 1. 基础概念

参考阅读： [一文搞定 UDP 和 TCP 高频面试题！](https://zhuanlan.zhihu.com/p/108822858)

头部格式：这个是真·八股，我是真背不出来。

![三次握手](https://pic4.zhimg.com/80/v2-0673bbc84fe4440aed9d1dadc67ae79b_1440w.jpg)

↑ 三次握手：由于TCP是全双工的连接，因此C/S双方都必须确认对方能够收到自己的消息，因此至少必须是3次握手（有两个动作合二为一了）。

![四次挥手](https://pic2.zhimg.com/80/v2-8bf6f231cdd87b2613554f54424e8201_1440w.jpg)

↑ 四次挥手：当一方通知关闭连接时，另一方依然可以继续发送数据；由于“断开连接”这个动作属于“上层的意志”，TCP本身并不能决定立即断开连接，因此另一方的关闭动作可能稍晚一些，因此比挥手是4次，比握手多了一次。

握手/挥手的消息格式：分别有一个bit来表示握手/挥手动作（SYNbit, FINbit, ACKbit），并且都会发送一个seq（顺序号）；响应时要回seq+1

TIME_WAIT：挥手执行到第3次之后，最后的第4次挥手是没有响应的，因此收到第3次挥手的一方（即先挥手的一方）会等待2MSL的时间，一定程度上保证对方收到第四次握手的ACK 。另外，也是为了一定程度上保证当前TCP连接的所有报文都消失在网络中，避免对后续连接的干扰。

### 2. TCP的粘包和拆包

为什么UDP没有这种现象？因为UDP的头部有字段来标明报文长度。

而TCP没有长度，整个TCP就是一个字节流。由于缓冲区的设置，小于缓冲区就粘，大于缓冲区就拆。

解决方法关键就是怎么定义边界：

- 消息定长
- 特殊符号作为边界（例如FTP协议以回车结尾）
- 应用层内再加一个头（定义消息长度）

### 3. TCP滑动窗口与流量控制

双方分别有接收窗口和发送窗口；发送窗口的尺寸和移动都依赖于对方的接收窗口（只有ACK了才能移动窗口位置），以此实现流量控制。

### 4. TCP拥塞控制

![TCP拥塞控制](https://pic1.zhimg.com/80/v2-a62edcee3fb47ed147e56bdc8001feec_1440w.jpg)

拥塞窗口`cwnd`从很小的值开始，先指数上升（称为慢开始/冷启动），随后达到一个阈值`ssthresh`时，进入固定斜率增长状态（称为拥塞避免阶段）。

此时，如果出现超时（说明比较严重了），则直接重新**慢开始**并降低阈值`ssthresh`；如果收到连续3个相同的ACK（说明丢了中间一部分报文），则执行**快重传**（即重发丢失的那个报文）并降低`cwnd`和`ssthresh`（cwnd降低到阈值而不是1，这被称为快恢复）。

随后，理论上`cwnd`应该在`ssthresh`上方小范围震荡，即不断发生快重传和快恢复，达到一个动态平衡状态。

## 面经-1

岗位核心要求：熟悉Python，知识面广；

公司情况：金融行业企业软件定制，项目组主要做RPA

在这家公司面试，体验非常好：

- HR很专业，沟通很舒服。
- 一面技术，聊的过程中我就能感到面试官确实经验非常丰富，而且为人实在，好相处。
- 二面应该是总监级别的领导，大半个小时的时间跟我**聊人生**。关于这点，可能有些急躁的同学会很反感，不过我觉得我跟他还是挺聊得来的，他评价我心智成熟，我也从他的观点中获得了很多启发，回家后思考了很多。

**Q1：为什么学go，平时怎么学的？**

**Q2：Golang数组与切片的区别？**

最显著的区别，数组是固定长度的，而切片是不固定的。

如果是作为参数传递，在Go里都是传值的，传数组的话会做浅拷贝。（这个点我当时没说，因为没get到面试官的意思）

参数传切片的话，如果没有扩容那么切片指向的是原来那个底层数组，扩容之后可能会变化。

**Q3：defer的顺序？chan的顺序？**

defer是先定义的后执行。

chan是先进先出，可以理解为是一个循环链表（循环数组）。

**Q4：会用go协程吗，哪些场景用到，python协程了解过吗？**

IO密集或者计算密集任务都可以使用go程。

python协程主要是`async/await`那一套，没怎么用过。（在实践中一般通过gevent打补丁实现，或者对于性能要求高的服务直接选用其他语言）

（这里呢，其实python中的生成器`yield`从定义来说也算是协程，但应该不是我们这个语境想要讨论的东西。）

**Q5：new和make的区别？**

`new`会返回一个指针。

`make`一般用于构造那几种内置数据结构，map, slice, chan等。

**Q：redis主从集群怎么做？**

**Q：redis数据结构类型？**

**Q：如果要实现一个日活统计，怎么做？**

**Q：mongo单个索引的最大长度？**

### mongo小结

[MongoDB Limits and Thresholds](https://www.mongodb.com/docs/manual/reference/limits/#Index%20Key) 列举一些我认为需要注意的mongo中的限制：

1. 单个文档最大尺寸16MB，BSON深度不超过100级
2. db名称最多64字符，col名称最多255字符，index名称最多127字符
3. 一个col最多64个索引
4. 复合索引最多复合32个字段，排序最多依赖32个字段
5. 如果限定col的最大行数，那么最多2^32个doc；不指定的话就不限制doc数量
6. 单个索引值不能超过1024B，但是v4.2版本之后移除了这个限制。

### 思考人生

我依然坚持这个观点：『技术不是万能的，但没有技术是万万不能的』

作为技术人，我们应该思考自己做的事情到底创造了什么价值。有很多团队就是奔着赚快钱的思路去的，前几年典型的是p2p，近几年典型的是区块链、web3 。可能有很多人梦想一夜暴富，但我不是那种人。只有选择有意义的行业去深耕，才有机会走出一条康庄大道，而不是做个每天在刀口上舔血亡命之徒。

——所以接下来我会慎重选择我的行业，应该就两条路：回归金融行业，或者继续在电商/直播这条互联网道路上奋斗下去。

另外是关于思考问题的角度。二面面试官说：“我去年面试xxx（一面面试官）的时候，他一腔热情，连薪资都没谈就来了；他看问题的角度跟你不一样。”

关于这个评价我稍微有些委屈，因为一面面试官他是从大厂出来、有十几年研发经验的大佬了，至少他已经经历过互联网红利，无论是从经济需求、人生阶段、还是职位高度来说，他考虑的东西肯定跟我不一样。

但是这番评价，也确实提醒到我，我目前技术水平已经达到一定高度了，接下来要以更加宏观的视角去看业务，即重点关注“如何用技术去给业务赋能，创造价值”，同时也是提升自己的综合竞争力。

最近带了几个前端后辈，有的同学展现出了极高的学习能力和自驱力，连我这种内卷王也不得不感慨：后生可畏。如果当年我自学的时候，遇到像现在的我这样优秀的领路人，我想，我可以取得比现在更高的成就吧。我替他们感到幸运，也为他们骄傲。

虽然后生可畏，但我需要做的不是去打压或者限制他人的成长。在我这个阶段，我应该以更高的视角去提供不一样的团队资源，而不是继续埋头在技术的世界里争个高低。——这就是二面面试官所谓的“看问题的角度”吧。

## 面经-2

岗位要求：纯前端

公司情况：跨境电商toC业务，主要业务似乎是用大数据向C端客户推荐商品

我必须要**吐槽这家公司**：英祐科技

- 首先HR就挺不专业的，这个岗位与我的简历并不太符合，一面就让我大老远跑去现场面试，去了那边也没人接应我，让我在大厅里等了好久。
- 晚上7点到他们公司，公司里还是一幅热火朝天在正常工作的样子。
- 面试官，全程面无表情，没有任何反馈。简历也不看，项目也不问，就只问八股。

**Q： koa中间件有没有写过？**

重点：koa是一个洋葱模型，每个中间件可以从`ctx`里访问request, response等对象，然后执行`next()`

**Q： webpack优化做过哪些？**

可以[参考](https://segmentfault.com/a/1190000022561279) 太多了

**Q： webpack plugin写过吗？有哪些生命周期？**

**Q： webpack5有哪些新特性？**

**Q： webpack联邦 了解吗？**

**Q： TS的interface和type有什么区别？**

可以[参考](https://juejin.cn/post/6844903749501059085)

简而言之，两者的功能基本相同，只是语法上略有区别。

type可以用作别名，可以有更丰富的运算和定义形式。

**Q： TS泛型有哪些应用？**

我个人感受，主要应用：

1. 取出类型，参与类型运算
2. 声明约束条件

**Q： js中object与Map有何区别？遍历时有何区别？**

可以[参考](https://www.jianshu.com/p/94cf51649517)

核心区别：Map的键不限类型、有迭代器（可以用`for of`或者`.forEach()`）、有序、有长度。

Object只能以字符串（或Symbol）作为键，只能通过`for in`迭代。但是可以通过给`Object.prototype[Symbol.iterator]`赋值来实现迭代器。

**Q： React Hooks有哪些好处？使用时需要注意什么？有没有自己写过Hooks？**

优点：代码量更少，更好写。参考[官方文档](https://reactjs.org/docs/hooks-intro.html#motivation) ：

1. 类组件不利于代码复用，要通过HOC（高阶组件）来实现
2. 类组件有显式的生命周期函数，一套业务逻辑可能会分散在多个生命周期里，不利于代码维护
3. js的类 比较难以学习，特别是`this`相关的知识
4. 函数组件的性能比类组件更优秀一些，它没有instance

缺点：闭包效应（指在异步调用时依然保存着旧的状态引用），依赖参数导致限制多。

缺点解决方案：使用class组件，或者useRef，或者MVVM框架例如`mobx`

首先只能在函数组件里使用，然后还要注意不要在循环或者条件语句里使用Hooks，总之要保证Hooks数量不变。

我认为"自定义Hook"实质上只是代码复用的一种形式罢了，只要理解其核心是通过this来传递上下文即可。一般我们写过的比较典型的有`useRequest`这种封装一些网络请求的处理。

**Q： React Hooks要求数量不变，其底层原理是什么？**

因为React使用链表来保存Hook相关信息，它是有序的，而且没有类似id的字段，只能通过索引顺序来保证；否则会导致错位。 [参考](https://juejin.cn/post/6959086536834940965)

**Q： React useEffect与useLayoutEffect有何区别？**

参考：[官方文档](https://reactjs.org/docs/hooks-reference.html#uselayouteffect)

`useLayoutEffect`中产生的更新会立即同步地re-render，执行过程中浏览器没有机会再次刷新。

因此用途之一是可以用来优化闪烁问题。官方建议尽量不要使用这个Hook。

### React18小结

**Q： React18有何新特性，迁移时需要注意什么？**

参考：[官方博客](https://reactjs.org/blog/2022/03/29/react-v18.html)

最大的特性：concurrence（并发），这个对于一般开发者来说无需考虑，以后我有机会再整理一下。

新特性：

- 批量状态更新（auto batching），会把多个setState合并在一次render里执行。
- 低优先级的过渡（Transition），可以告诉react某些更新可以是低优先级的。
- Suspense支持服务端渲染和最新的并发特性了。
- ReactDOM提供了几个新的API，使用他们来激活react18的新特性
- 新的严格模式（略）

新的钩子：

- `useId`
- `useTransition`指定低优先级的状态更新
- `useDeferredValue`类似防抖（debouncing）
- `useSyncExternalStore`（略）
- `useInsertionEffect`（略）

简单概括一下，对于开发者来说，最大的更新就是 auto-batching 和 useTransition 这两项。

## 面经-3

岗位要求：全栈偏前端，知识面广，技能不设边界

公司情况：web3行业创业公司，过了种子轮，研发团队<10人

面试官似乎是通过我的github和个人博客就已经非常认同我的技术实力了，全程都在聊项目和未来发展，后来还是我主动问起技术才稍微聊了一会儿技术，主要关注点在用过哪些技术、怎么学习技术的。

后来再次联系，去了一趟公司现场，地点是在杭州附近一个度假村里的一栋小楼。地理位置还是比较偏僻的，周围没有正经的都市生活带，在那里的话估计只能一心写代码了。（顺带一提，聊天过程中我还被蚊子咬了两个大包，好痒……）

技术方面聊到一些很实用的内容：

- 云主机、ECS、lambda三者的区别，关键区别就是运维操作对象的层级不同。ECS是直接管理容器/镜像、不管宿主，lambda则是抛弃了所有的运维、直接干业务逻辑。
- CI/CD在实际工程中的应用（我前端后端项目分别讲了讲）
- 『智能合约』的概念，说实质上就是运行在链上的lambda服务。
- 加密货币的代币与普通币的区别。
- 区块链中的『gas fee』，概念我之前就知道，但这个名词是第一次听到，还是挺有趣的。

### 思考人生3

CTO聊到另一个候选人，说今年33岁了，今年年初从成都来杭州做web3创业，结果前阵子币圈大跌搞得他直接无法经营了，才找工作找到这家公司这里。

我问，那他的家人都还在成都？还要长期跟家人异地？——然后我得到了肯定的答复。

我在内心就叹了一口气。33岁，应该有老婆有小孩了吧。从这片言只语的描述，我感觉，这次创业更像是一场有勇无谋的豪赌。我不知道这位老哥到底经历了什么，还是有多缺钱，才会选择离开家人来到杭州。

对于“创业”，人们总是更容易看见那些成功的例子，看到他们鲜衣怒马吃香喝辣，就开始焦虑、蠢蠢欲动。可是所谓大浪淘沙，更多的倒在半路的创业者 他们所经历的痛苦和伤害，却被很多人视而不见。

我觉得，创业本身没问题，但是要看创业的方式、以及创业的人。不是谁都适合创业的。

## 面经-4

岗位要求：资深全栈，偏c++

公司情况：我关注很久的一家公司，原来是做量化私募的，后来似乎转型做AI了，AI量化私募只是他们的其中一个方向。

做了一次笔试题，在牛客网上，不得不提牛客用到的技术比我想象中厉害，要求候选人做题的时候全程开启摄像头，并且还要屏幕录屏。

笔试题先是单选题和多选题，包括：

- 一些操作系统知识，（例如：下面哪个事件不可能在用户态发生）
- 一些c++语言特性（这个我只能根据其他语言经验来猜了）
- 一些算法相关题，（例如：二叉堆经过一轮pop-down之后会变成什么样子？xx算法的复杂度？）

然后编程题就非常离谱了，具体题目我就不泄露了，说个大概：

1. 一个抽奖活动，问中奖概率
2. 实现一个语法解析器，能够解析：支持赋值、加减法、条件语句、打印三种功能的编程语言。
3. 给出一段压缩算法的实现代码，请写出对应的解压缩算法代码

这三题做得我怀疑人生，直接提前交白卷了。我面试也参加过十几二十多场了，从未见过如此离谱的题目。

然后我找了一个在大厂做算法岗位的同学聊了聊，她也觉得这三题过于离谱。我们的理解是，哪怕是算法岗位，一般工作内容也就是算法的具体应用或者简单优化（例如NLP算法应用到工程中）；而从这家公司的笔试题来看，他们想招的应该是**会写代码的数学家**，而不是一般意义上的全栈研发工程师。 当然，如果真有能做出这三题的候选人，我承认他很厉害，也配得上这家公司给出的高额薪资。

这家公司想组建一个严格的精英团队的这种思想，挺大胆的，但我觉得未必是高效的。因为根据我的从业经验来看，那些能快速学习技术并有效落地实施的人 与 那些精通抽象算法的人，基本上是不重叠的，因为这两种角色所需要的精神特质是完全不同的。

我以后还会关注这家公司，我很好奇他们后续的发展。

## 面经-5

岗位要求：Python+懂一点运维

公司情况：有几个项目线，最初做了一个app，后来两个项目是政府/国企项目。

直接跟CTO聊的，人挺实在的，先介绍了项目情况、技术栈情况，然后聊了聊我的未来规划。然后进入技术部分，先让我讲讲我做过的比较有特色的项目，然后从项目里挖掘技术点，先主问后端，然后问了很多前端。（其实前端问得比后端还多……）

最后被评价：”你这个前端水平，写业务足够了，但是要自己写个框架的话还需要更加深入的研究“，以及”你会去学前端可能是因为前端所见即所得，相对后端更没那么枯燥“

后来我自己也思考了一下：

首先，前端的知识确实可以比我想象中复杂得多，特别是涉及一些古老的特性以及历史发展过程，这里坑就很深了。换句话说，如果只是中规中矩地在符合现代浏览器标准条件下的前端开发，可以很轻松，但是现实工作中经常会遇到各种坑，要能从容解决它们确实需要一定的理论知识水平。

第二，我想我也并没有特别喜欢”写前端“，我喜欢的其实是`typescript`，不得不说，它的类型系统是我所见过最强大的类型系统没有之一了，再加上js本身脚本语言的特性，又同时兼顾了灵活性；另外，`React Hooks`也是我所喜爱的，函数式的语法以及灵活的生命周期用法让我欲罢不能，总之用ts+react来写业务是真的轻松加愉快。

第三，其实一般意义上的”全栈“应该指的是以前端为主，兼顾`node.js`的”大前端“，而我这种把后端打通关了又把前端打通关了的狠人，其实是超越了企业的实际需求的，说点现实的，就叫——投入产出比很低。

就我个人而言，前端、后端两手都抓，也确实在少许程度上阻碍了深度的发展；虽然跟周围的人比一比好像两手抓两手硬还挺厉害的，但是在跟真正的大佬切磋的时候，还是会显得功力不足的。

**Q：js事件循环原理？自己实现一个事件循环？**

**Q：es6怎么变成es5的？**

**Q：sourcemap做了什么，怎么配置？**

**Q：webpack中plugin与loader的区别？**

追问：为什么css-extractor是plugin而不是loader？

**Q：如何把静态资源传到cdn？**

追问：让你选择的话，你选shell脚本做，还是用webpack插件去做？

这个问题有点意思的，我作为一个后端程序员，我们后端构建一般用的都是shell脚本或者写在dockerfile里的shell命令，而且之前我们用阿里云OSS也是用他的shell命令行工具来操作，所以我凭直觉就回答了：“我会选shell脚本做”。

然后对方马上就笑了，问我：“你既然会用webpack了，为什么不用插件做？”我稍微想了想，好像确实也是可以的。这或许算是一个我的“盲区”吧；当然我觉得如果等我亲手操作的时候，我最终也应该会选择webpack而不是shell来做的。

**Q：React比jQuery性能高在哪里？**

追问：React是如何处理事件的？

追问：React更新状态后立即查询状态会查到什么值？

**Q：可控组件与非可控组件的区别？**

**Q：为什么没用Redis的PubSub做队列？**

这个问题其实是从我项目里引申出来的，其实我们项目一开始用的是`RabbitMQ`呢，后来才换回Redis Streams 。 另外从我的面试经验来看，目前还没有任何一个面试官听说过`Stream`这个东西（某种程度上也算是把面试官难到了？笑）

参考：[Redis知识点总结](../2022/220517-redis-bagu.md#Redis作队列)

**Q：讲讲Redis的持久化？**

这个问题是从 用Pub/Sub做任务队列 引申出来的。

## 面经-6

岗位要求：全栈

公司情况：私募基金公司，在这个行业里可以算是老牌了，公司环境看起来挺好的，几个HR也都很有礼貌。

招聘节奏推进得比较慢。过了一个多星期才电话沟通，然后第二周才约了第一次笔试。

说起私募的笔试，前阵子我面试另一家给出的那几题变态算法题看来是给我留下心理阴影了，这次一说要笔试，我立马就感觉心里毛毛的。

这次笔试的形式比较独特，用腾讯会议APP，不开摄像头，只共享桌面；然后题目是通过腾讯文档分享过来的，直接在题目下面作答。

看到题目的一瞬间，心里安定了许多。题目大概构成：

- 9题思考人生题：你熟悉什么编辑器、操作系统、语言、框架、数据库，未来职业规划等。（这里我稍微展开讲了讲）
- 3题智力逻辑题：有些绕弯的数学推理，例如买个东西卖个东西亏了多少钱这种。要描述推理过程。
- 2题算法题：题目描述很简单，以至于很多边界场景没有界定清楚。如果只是简单作答可以认为是easy难度，但是如果把所有场景考虑完整的话至少medium难度。（我在能力和时间范围内尽量考虑了多的边界场景）

预定时间是1-1.5小时。也许是因为在前面那些题目浪费太多时间了吧，最后编程题没有很充足的时间，我看着时间差不多到1.5小时的时候，虽然HR没有催我，但我主动交卷了。

说起来这次还真有考试的感觉，拿到卷子，我先整体浏览了一遍，（其实也是先确认一下编程题是我可以做得出来的），然后从前往后做，不确定的题留下了标记，最后再整体检查一遍。这熟练的流程说明：我可能确实是个老好学生了吧（笑）。

## 朋友的面经-7

岗位：字节 飞书 前端

**Q：JS实现扁平化数据->树状结构**

题目可以参考：[这篇文章](https://juejin.cn/post/6987224048564437029)

比较简易的思路，用一个递归，达到 n*n 的时间复杂度。具体实现上用reduce会显得比较炫酷。

我听了之后提问：请尝试借助一个Map，用n的空间复杂度达到n的时间复杂度。

后续还可以进一步深入：尝试解决循环引用等异常情况。（其实核心思路跟链表算法类似）

所以这题感觉还是挺好的，以后我面试别人的时候我会考这题。

**Q：浏览器插件各个部分的作用？**

这个是我的专业领域，之前也给小伙伴们详细分享过，答得怎么样就看缘分了 ：）

**Q：CORS CSRF**

**Q：webpack性能优化，分包技术？**

"分包"这两个字听得我有点蒙蔽，不确定是不是指的是"chunk"的意思。这块内容我虽然有一些实践，但是没有总结过。

搜到[这篇文章](https://segmentfault.com/a/1190000040049242) 感觉讲的不错。大概意思是，entry、异步模块、runtime 分别打包。

感觉在实践中一般就考虑异步模块分包吧，很容易实现。要用多个entry的话我认为就涉及微前端的领域了。

**Q：js bridge**

这个是用在webview里的，对于我这个后端出身的全栈来说还是稍微有些遥远了。

简单了解了一下用法，感觉其实跟js跨页面的`postMessage`等工具的原理和用法都是类似的。

**Q：css实现元素固定宽高比**

一个挺有意思的问题。参考阅读：[面试官：CSS如何实现固定宽高比？](https://juejin.cn/post/6844904070679887886)

我的第一个想法，用`aspect-ratio`之类的属性来定义，不过它的兼容性不太好。另一个想法，手动计算宽高，在js里定义好、或者借助css变量。

**Q：js事件循环**

给一堆 setTimeout Promise，让判断执行顺序。

这里有一个小插曲，我们发现在node10版本下，micro-task的执行顺序是与node其他版本以及浏览器中是不同的。看看代码：

```js
(function () {
  console.log(1);
  setTimeout(() => {
    console.log(2);
  });
  (async function () {
    console.log(3);
    await Promise.resolve();
    console.log(4);
  })();

  const bb = new Promise((resolve) => {
    resolve();
    console.log(5);
  });

  console.log(6);
  bb.then((res) => {
    console.log(7);
  });

  console.log(8);
})();
```

在node10环境下输出结果是`13568742`，在其他环境下输出结果是`13568472`（我们思考得出的答案也是这个），注意`74`和`47`的顺序颠倒了。猜测是由于`Promise.resolve()`的运行实现不一致。

参考阅读：[浏览器与Node的事件循环(Event Loop)有何区别?](https://juejin.cn/post/6844903761949753352)

**Q：css盒模型**

**EXTRA：实现一个Promise Chain**

```typescript
function run(list: (() => Promise<unknown>)[]) {
  let last = Promise.resolve();
  for (const f of list) {
    last = new Promise((resolve) => {
      last.then(() => f().finally(resolve));
    });
  }
}
```

核心思想类似链表算法的遍历，每次保存上一个"指针"。

如果我是面试官，我还可以追问：如何实现最大2个Promise并发执行？如何执行到一半的时候终止执行？

**EXTRA：倒计时组件**

## offer与小结

这一波大概投了12家公司，6个面试（含2个笔试），3个进入offer谈薪阶段。

（顺带吐槽，那两个做笔试的基金公司我觉得他们根本就不想招人）

最高的offer能给到30%的涨幅。在这样一个经济下行、到处裁员的大背景下，我这样算是什么水平，我觉得应该算厉害了吧。

但是我最后还是放弃了。这只是个人选择问题。这里也对几位HR和面试官表示抱歉。

一开始我以为『钱』是我选择工作的最重要的因素，可等我要做选择的时候，我发现它并不是。

以前想要钱，可能是因为穷怕了——这个“穷”并不是说吃不起饭的那种穷，而是这个社会对于未婚男性的压力所造成的“穷”。而现在的我，虽说也不算有钱，但也足够满足我还算是清贫的物质需求了。所以我似乎更加重视其他东西——可能是成就感，可能是生活感，又或者还没想清楚，但是需要更多时间去思考。

## 后记（2022-09-18）

过了小半年，我再重新回来看这篇文章。

然后我突发奇想，之前给过我offer的那几家公司，现在发展得怎么样了？毕竟当时加了好几个HR和面试官的微信呢。

可是我回忆了半天也没任何印象。只有那两家被我吐槽说根本不想招人的基金公司的HR的微信号会经常发一些公司动态，其他公司几乎就没有消息了。

之前我就有类似的理解了，这次再次感慨一下：HR真的是一家公司的门面，是一个重要的资源位。

当然必须强调的是，我认为朋友圈本来应当是私人的东西，不应该与工作混为一谈。但办法总比困难多，我就随便一想就想到至少3个解决方案，只要想做，完全可以做得到。

那么对于一个程序员来说，他的朋友圈（或者任意社交圈子渠道）能够发挥什么作用呢？这个问题值得思考。
